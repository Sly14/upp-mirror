#include "Builders.h"

// Hardcoded paths.
String sdkPath = "/home/klugier/AndroidStudio/sdk";
String sdkPlatform = "";
String jdkPath = "/usr/lib/jvm/java-7-oracle";

String AndroidSDKBuilder::GetTargetExt() const
{
	return ".apk";
}

bool AndroidSDKBuilder::BuildPackage(const String& package, Vector<String>& linkfile,
	                                 Vector<String>&, String& linkoptions,
	                                 const Vector<String>& all_uses,
	                                 const Vector<String>& all_libraries,
	                                 int)
{
	ResetVariables();
	
	String packageUppManifestPath = PackagePath(package);
	packageDir = GetFileFolder(packageUppManifestPath);
	packageName = package;
	
	ChDir(packageDir);
	PutVerbose("cd " + packageDir);
	
	Package pkg;
	pkg.Load(packageUppManifestPath);
	
	Vector<String> packageSourceFiles; // <- Paths releated to project
	Vector<String> sourceFiles; // <- Paths releated to operating system
	Vector<String> sourceObjectFiles; // <- Objects file paths
	Vector<String> sourceOptions;
	bool error = false;
	for(int i = 0; i < pkg.GetCount(); i++) {
		if(!IdeIsBuilding())
			return false;
		if(!pkg[i].separator) {
			// TODO: add global options aka gop support
			Vector<String> allPackageFiles = CustomStep(pkg[i], package, error);
			if(!allPackageFiles.GetCount())
				error = true;
			for (int j = 0; j < allPackageFiles.GetCount(); j++) {
				String filePath = allPackageFiles[j];
				String fileExt = ToLower(GetFileExt(filePath));
				
				if(fileExt == ".java") {
					// TODO: how to handle project source (aka. "java") dir tree.
					String packageFile = AppendFileName(package, pkg[i]);
					String objectFile = NativePath(CatAnyPath(outdir, packageFile));
					
					packageSourceFiles.Add(packageFile);
					sourceFiles.Add(filePath);
					sourceObjectFiles.Add(objectFile);
				}
				else
				if(fileExt == ".xml") {
					if(pkg[i] == "AndroidManifest.xml") {
						if(androidManifestPath.GetCount()) {
							PutConsole("AndroidManifest.xml is duplicated.");
							return false;
						}
						
						androidManifestPath = packageDir + DIR_SEPS + pkg[i];
					}
				}
			}
		}
	}
	
	if(!androidManifestPath.GetCount()) {
		PutConsole("Package " + package + " dosen't contain Android manifest file (\"AndroidManifest.xml\").");
		return false;
	}
	
	if (!GenerateRFile())
		return false;
	
	// TODO: do we need to add R.java to source files???
	
	if(!error && HasFlag("MAIN") && !sourceFiles.IsEmpty()) {
		objectsDir = outdir + DIR_SEPS + "obj";
		
		if(!RealizeDirectory(objectsDir)) {
			PutConsole("Creating directory " + objectsDir + " failed.");
			return false;
		}
		
		String linkcmd;
		linkcmd << JavacPath() << " ";
		linkcmd << "-d "<< objectsDir <<  " ";
		linkcmd << "-classpath " << PlatformDir() << DIR_SEPS << "android.jar" << JavacDelimiter() << objectsDir << " ";
		linkcmd << "-sourcepath " << packageDir << DIR_SEPS << "java ";
		for(int i = 0; i < sourceFiles.GetCount(); i++) {
			linkcmd << sourceFiles[i];
			if(i < sourceFiles.GetCount() - 1)
				linkcmd << " ";
		}
		
		linkoptions = linkcmd;
	}
	
	return !error;
}

// linkfile
// linkoptions - compilation command
bool AndroidSDKBuilder::Link(const Vector<String>& linkfile, const String& linkoptions,
	                         bool createmap)
{
	StringStream ss;
	
	//PutConsole("Linkoptions: " + linkoptions);
	int time = GetTickCount();
	PutConsole("Compiling...");
	if(Execute(linkoptions, ss) != 0) {
		PutConsole(ss.GetResult());
		return false;
	}
	PutVerbose("compiled in " + GetPrintTime(time));
	
	PutConsole("Creating dex file...");
	String dxCommand = DxPath() + " --dex " +
		"--output=" + outdir + DIR_SEPS + "classes.dex " +
		objectsDir;
	// PutConsole(dxCommand);
	if(Execute(dxCommand, ss) != 0) {
		PutConsole(ss.GetResult());
		return false;
	}
	
	PutConsole("Creating apk file...");
	String unsignedApkPath = outdir + DIR_SEPS + packageName + ".unsigned.apk";
	String signedApkPath = outdir + DIR_SEPS + packageName + ".signed.apk";
	DeleteFile(unsignedApkPath);
	String apkCommand = AaptPath() + " package -v -f " +
		"-S " + packageDir + DIR_SEPS + "res " +
		"-M " + androidManifestPath + " " +
		"-I " + PlatformDir() + DIR_SEPS + "android.jar " +
		"-F " + unsignedApkPath + " " +
		outdir;
	// PutConsole(apkCommand);
	if(Execute(apkCommand, ss) != 0) {
		PutConsole(ss.GetResult());
		return false;
	}
	
	// TODO: add debug apk signing: http://developer.android.com/tools/publishing/app-signing.html
	// in release mode we definitly shouldn't signing apk!!!
	
	if(HasFlag("DEBUG")) {
		String debugKeystorePath = outdir + DIR_SEPS + "debug.keystore";
		if(!FileExists(debugKeystorePath)) { 
			PutConsole("Generating debug key...");
			String keytoolCommand = KeytoolPath() + " -genkeypair -alias androiddebugkey -keypass android " + 
				"-keystore " + debugKeystorePath + " " + 
				"-storepass android -dname \"CN=Android Debug,O=Android,C=US\" -validity 10000";
			
			//PutConsole(keytoolCommand);
			if(Execute(keytoolCommand, ss) != 0) {
				PutConsole(ss.GetResult());
				return false;
			}
		}
	
		PutConsole("Signing apk file...");
		DeleteFile(signedApkPath);
		String jarsignerCommand = JarsignerPath() + " " +
			"-keystore " + debugKeystorePath + " " +
			"-storepass android " +
			"-keypass android " +
			"-signedjar " + signedApkPath + " " +
			unsignedApkPath + " " +
			"androiddebugkey";
		//PutConsole(jarsignerCommand);
		if(Execute(jarsignerCommand, ss) != 0) {
			PutConsole(ss.GetResult());
			return false;
		}
	}
	
	// TODO: should we align unsigned apk???
	PutConsole("Aliging apk file...");
	DeleteFile(target);
	String zipalignCommand = ZipalignPath() + " -v -f 4 " +
		(HasFlag("DEBUG") ? signedApkPath : unsignedApkPath) + " " +
		target;
	//PutConsole(zipalignCommand);
	if(Execute(zipalignCommand, ss) != 0) {
		PutConsole(ss.GetResult());
		return false;
	}
	
	return true;
}

bool AndroidSDKBuilder::PreprocesAndroidManifest()
{
	// TODO: use XML module to get important information from manifest file.
	
	return true;
}

bool AndroidSDKBuilder::GenerateRFile()
{
	// QUESTION: what is the best way to handle res/java folder in upp package structure???
	
	StringStream ss;
	String aaptCommand = AaptPath() + " package -v -f -m " +
		"-S " + packageDir + DIR_SEPS + "res " +
		"-J " + packageDir + DIR_SEPS + "java " +
		"-M " + packageDir + DIR_SEPS + "AndroidManifest.xml " +
		"-I " + PlatformDir() + DIR_SEPS + "android.jar";
	
	if(Execute(aaptCommand, ss)) {
		PutConsole(ss.GetResult());
		return false;
	}
	
	return true;
}

String AndroidSDKBuilder::BuildToolsDir() const
{
	return sdkPath + DIR_SEPS + "build-tools/19.1.0";
}

String AndroidSDKBuilder::PlatformDir() const
{
	// TODO: platform detection
	return sdkPath + DIR_SEPS + "platforms/android-22";
}

String AndroidSDKBuilder::AaptPath() const
{
	// TODO: build tools detection
	return BuildToolsDir() + DIR_SEPS + "aapt";
}

String AndroidSDKBuilder::DxPath() const
{
	return BuildToolsDir() + DIR_SEPS + "dx";
}

String AndroidSDKBuilder::ZipalignPath() const
{
	return BuildToolsDir() + DIR_SEPS + "zipalign";
}

String AndroidSDKBuilder::JavacPath() const
{
	return jdkPath + DIR_SEPS + "bin" + DIR_SEPS + "javac";
}

String AndroidSDKBuilder::JarsignerPath() const
{
	return jdkPath + DIR_SEPS + "bin" + DIR_SEPS + "jarsigner";
}

String AndroidSDKBuilder::KeytoolPath() const
{
	return jdkPath + DIR_SEPS + "bin" + DIR_SEPS + "keytool";
}

String AndroidSDKBuilder::JavacDelimiter() const
{
#if defined(PLATFORM_WIN32) || defined(PLATFORM_WIN64)
	return ";";
#else
	return ":";
#endif
}

void AndroidSDKBuilder::ResetVariables()
{
	androidManifestPath.Clear();
	packageName.Clear();
	packageDir.Clear();
	objectsDir.Clear();
}

Builder *CreateAndroidSDKBuilder()
{
	return new AndroidSDKBuilder();
}

INITBLOCK
{
	RegisterBuilder("Android_SDK", &CreateAndroidSDKBuilder);
}
