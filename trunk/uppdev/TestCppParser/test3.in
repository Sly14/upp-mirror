extern "C++" // templates cannot be declared to have 'C' linkage
template <typename T, size_t N>
char (*RtlpNumberOf(  T (&)[N] ))[N];

#define _WINNT_








extern "C" {



#define ANYSIZE_ARRAY 1       

//
// For compilers that don't support nameless unions/structs
//


#define DUMMYUNIONNAME   u
#define DUMMYUNIONNAME2  u2
#define DUMMYUNIONNAME3  u3
#define DUMMYUNIONNAME4  u4
#define DUMMYUNIONNAME5  u5
#define DUMMYUNIONNAME6  u6
#define DUMMYUNIONNAME7  u7
#define DUMMYUNIONNAME8  u8
#define DUMMYUNIONNAME9  u9

#define DUMMYUNIONNAME
#define DUMMYUNIONNAME2
#define DUMMYUNIONNAME3
#define DUMMYUNIONNAME4
#define DUMMYUNIONNAME5
#define DUMMYUNIONNAME6
#define DUMMYUNIONNAME7
#define DUMMYUNIONNAME8
#define DUMMYUNIONNAME9





#define DUMMYSTRUCTNAME  s
#define DUMMYSTRUCTNAME2 s2
#define DUMMYSTRUCTNAME3 s3
#define DUMMYSTRUCTNAME4 s4
#define DUMMYSTRUCTNAME5 s5

#define DUMMYSTRUCTNAME
#define DUMMYSTRUCTNAME2
#define DUMMYSTRUCTNAME3
#define DUMMYSTRUCTNAME4
#define DUMMYSTRUCTNAME5











#define RESTRICTED_POINTER __restrict

#define RESTRICTED_POINTER



#define ALIGNMENT_MACHINE
#define UNALIGNED __unaligned

#define UNALIGNED64 __unaligned

#define UNALIGNED64


#undef ALIGNMENT_MACHINE
#define UNALIGNED
#define UNALIGNED64




#define MAX_NATURAL_ALIGNMENT sizeof(ULONGLONG)
#define MEMORY_ALLOCATION_ALIGNMENT 16

#define MAX_NATURAL_ALIGNMENT sizeof(DWORD)
#define MEMORY_ALLOCATION_ALIGNMENT 8


//
// TYPE_ALIGNMENT will return the alignment requirements of a given type for
// the current platform.
//



#define TYPE_ALIGNMENT( t ) __alignof(t)


#define TYPE_ALIGNMENT( t )     FIELD_OFFSET( struct { char x; t test; }, test )






#define PROBE_ALIGNMENT( _s ) TYPE_ALIGNMENT( DWORD )

#define PROBE_ALIGNMENT( _s ) (TYPE_ALIGNMENT( _s ) > TYPE_ALIGNMENT( DWORD ) ?                               TYPE_ALIGNMENT( _s ) : TYPE_ALIGNMENT( DWORD ))





#define PROBE_ALIGNMENT32( _s ) TYPE_ALIGNMENT( DWORD )



#define PROBE_ALIGNMENT( _s ) TYPE_ALIGNMENT( DWORD )



//
// C_ASSERT() can be used to perform many compile-time assertions:
//            type sizes, field offsets, etc.
//
// An assertion failure results in error C2118: negative subscript.
//


#define C_ASSERT(e) typedef char __C_ASSERT__[(e)?1:-1]

#define C_ASSERT(e)              






#define DECLSPEC_IMPORT __declspec(dllimport)

#define DECLSPEC_IMPORT




#define DECLSPEC_NORETURN   __declspec(noreturn)

#define DECLSPEC_NORETURN





#define DECLSPEC_NOTHROW   __declspec(nothrow)

#define DECLSPEC_NOTHROW





#define DECLSPEC_ALIGN(x)   __declspec(align(x))

#define DECLSPEC_ALIGN(x)





#define SYSTEM_CACHE_ALIGNMENT_SIZE 64

#define SYSTEM_CACHE_ALIGNMENT_SIZE 128




#define DECLSPEC_CACHEALIGN DECLSPEC_ALIGN(SYSTEM_CACHE_ALIGNMENT_SIZE)




#define DECLSPEC_UUID(x)    __declspec(uuid(x))

#define DECLSPEC_UUID(x)





#define DECLSPEC_NOVTABLE   __declspec(novtable)

#define DECLSPEC_NOVTABLE





#define DECLSPEC_SELECTANY  __declspec(selectany)

#define DECLSPEC_SELECTANY





#define NOP_FUNCTION __noop

#define NOP_FUNCTION (void)0





#define DECLSPEC_ADDRSAFE  __declspec(address_safe)

#define DECLSPEC_ADDRSAFE





#define DECLSPEC_NOINLINE  __declspec(noinline)

#define DECLSPEC_NOINLINE





#define FORCEINLINE __forceinline

#define FORCEINLINE __inline





#define DECLSPEC_DEPRECATED   __declspec(deprecated)
#define DEPRECATE_SUPPORTED

#define DECLSPEC_DEPRECATED
#undef  DEPRECATE_SUPPORTED





#define DECLSPEC_DEPRECATED_DDK DECLSPEC_DEPRECATED

#define PRAGMA_DEPRECATED_DDK 1


#define DECLSPEC_DEPRECATED_DDK
#define PRAGMA_DEPRECATED_DDK 1


#define DECLSPEC_DEPRECATED_DDK
#define PRAGMA_DEPRECATED_DDK 0


//
// Void
//

typedef void *PVOID;
typedef void *  PVOID64;



#define NTAPI __stdcall

#define _cdecl
#define __cdecl
#define NTAPI



#define NTAPI_INLINE    NTAPI

#define NTAPI_INLINE


//
// Define API decoration for direct importing system DLL references.
//


#define NTSYSAPI     DECLSPEC_IMPORT
#define NTSYSCALLAPI DECLSPEC_IMPORT

#define NTSYSAPI

#define NTSYSCALLAPI

#define NTSYSCALLAPI DECLSPEC_ADDRSAFE





//
// Basics
//


#define VOID void
typedef char CHAR;
typedef short SHORT;
typedef long LONG;

typedef int INT;



//
// UNICODE (Wide Character) types
//


typedef wchar_t WCHAR;    // wc,   16-bit UNICODE character





typedef WCHAR *PWCHAR, *LPWCH, *PWCH;
typedef                const WCHAR *LPCWCH, *PCWCH;

typedef                       WCHAR *NWPSTR, *LPWSTR, *PWSTR;
typedef                       PWSTR *PZPWSTR;
typedef                                      const PWSTR *PCZPWSTR;
typedef                       WCHAR  *LPUWSTR, *PUWSTR;
typedef                                      const WCHAR *LPCWSTR, *PCWSTR;
typedef                       PCWSTR *PZPCWSTR;
typedef                                      const WCHAR  *LPCUWSTR, *PCUWSTR;

typedef                   WCHAR *PZZWSTR;
typedef                                  const WCHAR *PCZZWSTR;
typedef                   WCHAR  *PUZZWSTR;
typedef                                  const WCHAR  *PCUZZWSTR;

typedef      [OnParameterOrReturnOnly]  WCHAR *PNZWCH;
typedef      [OnParameterOrReturnOnly]                 const WCHAR *PCNZWCH;
typedef      [OnParameterOrReturnOnly]  WCHAR  *PUNZWCH;
typedef      [OnParameterOrReturnOnly]                 const WCHAR  *PCUNZWCH;



typedef                const WCHAR *LPCWCHAR, *PCWCHAR;
typedef                const WCHAR  *LPCUWCHAR, *PCUWCHAR;

//
//  UCS (Universal Character Set) types
//

typedef unsigned long UCSCHAR;

//
//  Even pre-Unicode agreement, UCS values are always in the
//  range U+00000000 to U+7FFFFFFF, so we'll pick an obvious
//  value.

#define UCSCHAR_INVALID_CHARACTER (0xffffffff)

#define MIN_UCSCHAR (0)

//
//  We'll assume here that the ISO-10646 / Unicode agreement
//  not to assign code points after U+0010FFFF holds so that
//  we do not have to have separate "UCSCHAR" and "UNICODECHAR"
//  types.
//

#define MAX_UCSCHAR (0x0010FFFF)

typedef UCSCHAR *PUCSCHAR;
typedef const UCSCHAR *PCUCSCHAR;

typedef UCSCHAR *PUCSSTR;
typedef UCSCHAR  *PUUCSSTR;

typedef const UCSCHAR *PCUCSSTR;
typedef const UCSCHAR  *PCUUCSSTR;

typedef UCSCHAR  *PUUCSCHAR;
typedef const UCSCHAR  *PCUUCSCHAR;




//
// ANSI (Multi-byte Character) types
//
typedef CHAR *PCHAR, *LPCH, *PCH;
typedef                const CHAR *LPCCH, *PCCH;

typedef                       CHAR *NPSTR, *LPSTR, *PSTR;
typedef                       PSTR *PZPSTR;
typedef                                      const PSTR *PCZPSTR;
typedef                                      const CHAR *LPCSTR, *PCSTR;
typedef                       PCSTR *PZPCSTR;

typedef                   CHAR *PZZSTR;
typedef                                  const CHAR *PCZZSTR;

typedef      [OnParameterOrReturnOnly]  CHAR *PNZCH;
typedef      [OnParameterOrReturnOnly]                 const CHAR *PCNZCH;

//
// Neutral ANSI/UNICODE types and macros
//



typedef WCHAR TCHAR, *PTCHAR;
typedef WCHAR TBYTE , *PTBYTE ;
#define _TCHAR_DEFINED


typedef LPWCH LPTCH, PTCH;
typedef LPCWCH LPCTCH, PCTCH;
typedef LPWSTR PTSTR, LPTSTR;
typedef LPCWSTR PCTSTR, LPCTSTR;
typedef LPUWSTR PUTSTR, LPUTSTR;
typedef LPCUWSTR PCUTSTR, LPCUTSTR;
typedef LPWSTR LP;
typedef PZZWSTR PZZTSTR;
typedef PCZZWSTR PCZZTSTR;
typedef PUZZWSTR PUZZTSTR;
typedef PCUZZWSTR PCUZZTSTR;
typedef PNZWCH PNZTCH;
typedef PCNZWCH PCNZTCH;
typedef PUNZWCH PUNZTCH;
typedef PCUNZWCH PCUNZTCH;
#define __TEXT(quote) L##quote      // r_winnt






#define _TCHAR_DEFINED










#define __TEXT(quote) quote         // r_winnt


#define TEXT(quote) __TEXT(quote)   // r_winnt


typedef SHORT *PSHORT;  
typedef LONG *PLONG;    

#define ALL_PROCESSOR_GROUPS        0xffff

//
// Structure to represent a system wide processor number. It contains a
// group number and relative processor number within the group.
//

typedef struct _PROCESSOR_NUMBER {
    WORD   Group;
    BYTE  Number;
    BYTE  Reserved;
} PROCESSOR_NUMBER, *PPROCESSOR_NUMBER;

//
// Structure to represent a group-specific affinity, such as that of a
// thread.  Specifies the group number and the affinity within that group.
//

typedef struct _GROUP_AFFINITY {
    KAFFINITY Mask;
    WORD   Group;
    WORD   Reserved[3];
} GROUP_AFFINITY, *PGROUP_AFFINITY;

//
// Handle to an Object
//


typedef void *HANDLE;

#define DECLARE_HANDLE(name) struct name##__; typedef struct name##__ *name

#define DECLARE_HANDLE(name) struct name##__{int unused;}; typedef struct name##__ *name



#define DECLARE_HANDLE(name) typedef HANDLE name

typedef HANDLE *PHANDLE;

//
// Flag (bit) fields
//

typedef BYTE   FCHAR;
typedef WORD   FSHORT;
typedef DWORD  FLONG;

// Component Object Model defines, and macros


#define _HRESULT_DEFINED

typedef LONG HRESULT;






    #define EXTERN_C    extern "C"

    #define EXTERN_C    extern




// Win32 doesn't support __export


#define STDMETHODCALLTYPE       __cdecl

#define STDMETHODCALLTYPE       __stdcall

#define STDMETHODVCALLTYPE      __cdecl

#define STDAPICALLTYPE          __stdcall
#define STDAPIVCALLTYPE         __cdecl



#define STDMETHODCALLTYPE       __export __stdcall
#define STDMETHODVCALLTYPE      __export __cdecl

#define STDAPICALLTYPE          __export __stdcall
#define STDAPIVCALLTYPE         __export __cdecl




#define STDAPI                  EXTERN_C HRESULT STDAPICALLTYPE
#define STDAPI_(type)           EXTERN_C type STDAPICALLTYPE

#define STDMETHODIMP            HRESULT STDMETHODCALLTYPE
#define STDMETHODIMP_(type)     type STDMETHODCALLTYPE

#define STDOVERRIDEMETHODIMP        __override STDMETHODIMP
#define STDOVERRIDEMETHODIMP_(type) __override STDMETHODIMP_(type)

#define IFACEMETHODIMP          __override STDMETHODIMP
#define IFACEMETHODIMP_(type)   __override STDMETHODIMP_(type)

// The 'V' versions allow Variable Argument lists.

#define STDAPIV                 EXTERN_C HRESULT STDAPIVCALLTYPE
#define STDAPIV_(type)          EXTERN_C type STDAPIVCALLTYPE

#define STDMETHODIMPV           HRESULT STDMETHODVCALLTYPE
#define STDMETHODIMPV_(type)    type STDMETHODVCALLTYPE

#define STDOVERRIDEMETHODIMPV        __override STDMETHODIMPV
#define STDOVERRIDEMETHODIMPV_(type) __override STDMETHODIMPV_(type)

#define IFACEMETHODIMPV          __override STDMETHODIMPV
#define IFACEMETHODIMPV_(type)   __override STDMETHODIMPV_(type)

typedef char CCHAR;          
typedef DWORD LCID;         
typedef PDWORD PLCID;       
typedef WORD   LANGID;      
#define APPLICATION_ERROR_MASK       0x20000000
#define ERROR_SEVERITY_SUCCESS       0x00000000
#define ERROR_SEVERITY_INFORMATIONAL 0x40000000
#define ERROR_SEVERITY_WARNING       0x80000000
#define ERROR_SEVERITY_ERROR         0xC0000000

//
// _M_IX86 included so that EM CONTEXT structure compiles with
// x86 programs. *** TBD should this be for all architectures?
//

//
// 16 byte aligned type for 128 bit floats
//

//
// For we define a 128 bit structure and use __declspec(align(16)) pragma to
// align to 128 bits.
//




typedef struct _FLOAT128 {
    __int64 LowPart;
    __int64 HighPart;
} FLOAT128;

typedef FLOAT128 *PFLOAT128;


//
// __int64 is only supported by 2.0 and later midl.
// __midl is set by the 2.0 midl and not by 1.0 midl.
//

#define _ULONGLONG_

typedef __int64 LONGLONG;
typedef unsigned __int64 ULONGLONG;

#define MAXLONGLONG                         (0x7fffffffffffffff)








#define MAXLONGLONG                      (0x7fffffffffffffff)









typedef LONGLONG *PLONGLONG;
typedef ULONGLONG *PULONGLONG;

// Update Sequence Number

typedef LONGLONG USN;


typedef struct _LARGE_INTEGER {











    LONGLONG QuadPart;
} LARGE_INTEGER;

typedef LARGE_INTEGER *PLARGE_INTEGER;


typedef struct _ULARGE_INTEGER {











    ULONGLONG QuadPart;
} ULARGE_INTEGER;

typedef ULARGE_INTEGER *PULARGE_INTEGER;

// end_ntminiport end_ntndis end_ntminitape


//
// Locally Unique Identifier
//

typedef struct _LUID {
    DWORD LowPart;
    LONG HighPart;
} LUID, *PLUID;

#define _DWORDLONG_
typedef ULONGLONG  DWORDLONG;
typedef DWORDLONG *PDWORDLONG;


//
// Define operations to logically shift an int64 by 0..31 bits and to multiply
// 32-bits by 32-bits to form a 64-bit product.
//





//
// Midl does not understand inline assembler. Therefore, the Rtl functions
// are used for shifts by 0..31 and multiplies of 32-bits times 32-bits to
// form a 64-bit product.
//
//
// IA64 and AMD64 have native 64-bit operations that are just as fast as their
// 32-bit counter parts. Therefore, the int64 data type is used directly to form
// shifts of 0..31 and multiplies of 32-bits times 32-bits to form a 64-bit
// product.
//

#define Int32x32To64(a, b)  (((__int64)((long)(a))) * ((__int64)((long)(b))))
#define UInt32x32To64(a, b) (((unsigned __int64)((unsigned int)(a))) * ((unsigned __int64)((unsigned int)(b))))

#define Int64ShllMod32(a, b) (((unsigned __int64)(a)) << (b))
#define Int64ShraMod32(a, b) (((__int64)(a)) >> (b))
#define Int64ShrlMod32(a, b) (((unsigned __int64)(a)) >> (b))











#define Int32x32To64(a, b)  ((__int64)(((__int64)((long)(a))) * ((long)(b))))
#define UInt32x32To64(a, b) ((unsigned __int64)(((unsigned __int64)((unsigned int)(a))) * ((unsigned int)(b))))
























































































//
// Define rotate intrinsics.
//


extern "C" {




#define RotateLeft8 _rotl8
#define RotateLeft16 _rotl16
#define RotateRight8 _rotr8
#define RotateRight16 _rotr16

unsigned char

_rotl8 (
                                               [OnParameterOnly] unsigned char Value,
                                               [OnParameterOnly] unsigned char Shift
    );

unsigned short

_rotl16 (
                                               [OnParameterOnly] unsigned short Value,
                                               [OnParameterOnly] unsigned char Shift
    );

unsigned char

_rotr8 (
                                               [OnParameterOnly] unsigned char Value,
                                               [OnParameterOnly] unsigned char Shift
    );

unsigned short

_rotr16 (
                                               [OnParameterOnly] unsigned short Value,
                                               [OnParameterOnly] unsigned char Shift
    );










#define RotateLeft32 _rotl
#define RotateLeft64 _rotl64
#define RotateRight32 _rotr
#define RotateRight64 _rotr64

             [method: OnFunctionOnly]
unsigned int

_rotl (
                                               [OnParameterOnly] unsigned int Value,
                                               [OnParameterOnly] int Shift
    );

             [method: OnFunctionOnly]
unsigned __int64

_rotl64 (
                                               [OnParameterOnly] unsigned __int64 Value,
                                               [OnParameterOnly] int Shift
    );

             [method: OnFunctionOnly]
unsigned int

_rotr (
                                               [OnParameterOnly] unsigned int Value,
                                               [OnParameterOnly] int Shift
    );

             [method: OnFunctionOnly]
unsigned __int64

_rotr64 (
                                               [OnParameterOnly] unsigned __int64 Value,
                                               [OnParameterOnly] int Shift
    );









}


#define ANSI_NULL ((CHAR)0)     
#define UNICODE_NULL ((WCHAR)0) 
#define UNICODE_STRING_MAX_BYTES ((WORD  ) 65534) 
#define UNICODE_STRING_MAX_CHARS (32767) 
typedef BYTE  BOOLEAN;           
typedef BOOLEAN *PBOOLEAN;       
//
//  Doubly linked list structure.  Can be used as either a list head, or
//  as link words.
//

typedef struct _LIST_ENTRY {
   struct _LIST_ENTRY *Flink;
   struct _LIST_ENTRY *Blink;
} LIST_ENTRY, *PLIST_ENTRY, * PRLIST_ENTRY;

//
//  Singly linked list structure. Can be used as either a list head, or
//  as link words.
//

typedef struct _SINGLE_LIST_ENTRY {
    struct _SINGLE_LIST_ENTRY *Next;
} SINGLE_LIST_ENTRY, *PSINGLE_LIST_ENTRY;


//
// These are needed for portable debugger support.
//

typedef struct LIST_ENTRY32 {
    DWORD Flink;
    DWORD Blink;
} LIST_ENTRY32;
typedef LIST_ENTRY32 *PLIST_ENTRY32;

typedef struct LIST_ENTRY64 {
    ULONGLONG Flink;
    ULONGLONG Blink;
} LIST_ENTRY64;
typedef LIST_ENTRY64 *PLIST_ENTRY64;





#define __OBJECTID_DEFINED

typedef struct  _OBJECTID {     // size is 20
    GUID Lineage;
    DWORD Uniquifier;
} OBJECTID;


#define MINCHAR     0x80        
#define MAXCHAR     0x7f        
#define MINSHORT    0x8000      
#define MAXSHORT    0x7fff      
#define MINLONG     0x80000000  
#define MAXLONG     0x7fffffff  
#define MAXBYTE     0xff        
#define MAXWORD     0xffff      
#define MAXDWORD    0xffffffff  
//
// Calculate the byte offset of a field in a structure of type type.
//

#define FIELD_OFFSET(type, field)    ((LONG)(LONG_PTR)&(((type *)0)->field))

//
// Calculate the size of a field in a structure of type type, without
// knowing or stating the type of the field.
//
#define RTL_FIELD_SIZE(type, field) (sizeof(((type *)0)->field))

//
// Calculate the size of a structure of type type up through and
// including a field.
//
#define RTL_SIZEOF_THROUGH_FIELD(type, field)     (FIELD_OFFSET(type, field) + RTL_FIELD_SIZE(type, field))


//
//  RTL_CONTAINS_FIELD usage:
//
//      if (RTL_CONTAINS_FIELD(pBlock, pBlock->cbSize, dwMumble)) { // safe to use pBlock->dwMumble
//
#define RTL_CONTAINS_FIELD(Struct, Size, Field)     ( (((PCHAR)(&(Struct)->Field)) + sizeof((Struct)->Field)) <= (((PCHAR)(Struct))+(Size)) )


//
// Return the number of elements in a statically sized array.
//   DWORD Buffer[100];
//   RTL_NUMBER_OF(Buffer) == 100
// This is also popularly known as: NUMBER_OF, ARRSIZE, _countof, NELEM, etc.
//
#define RTL_NUMBER_OF_V1(A) (sizeof(A)/sizeof((A)[0]))







//
// RtlpNumberOf is a function that takes a reference to an array of N Ts.
//
// typedef T array_of_T[N];
// typedef array_of_T &reference_to_array_of_T;
//
// RtlpNumberOf returns a pointer to an array of N chars.
// We could return a reference instead of a pointer but older compilers do not accept that.
//
// typedef char array_of_char[N];
// typedef array_of_char *pointer_to_array_of_char;
//
// sizeof(array_of_char) == N
// sizeof(*pointer_to_array_of_char) == N
//
// pointer_to_array_of_char RtlpNumberOf(reference_to_array_of_T);
//
// We never even call RtlpNumberOf, we just take the size of dereferencing its return type.
// We do not even implement RtlpNumberOf, we just decare it.
//
// Attempts to pass pointers instead of arrays to this macro result in compile time errors.
// That is the point.
//
extern "C++" // templates cannot be declared to have 'C' linkage
template <typename T, size_t N>
char (*RtlpNumberOf(  T (&)[N] ))[N];

#define RTL_NUMBER_OF_V2(A) (sizeof(*RtlpNumberOf(A)))

//
// This does not work with:
//
// void Foo()
// {
//    struct { int x; } y[2];
//    RTL_NUMBER_OF_V2(y); // illegal use of anonymous local type in template instantiation
// }
//
// You must instead do:
//
// struct Foo1 { int x; };
//
// void Foo()
// {
//    Foo1 y[2];
//    RTL_NUMBER_OF_V2(y); // ok
// }
//
// OR
//
// void Foo()
// {
//    struct { int x; } y[2];
//    RTL_NUMBER_OF_V1(y); // ok
// }
//
// OR
//
// void Foo()
// {
//    struct { int x; } y[2];
//    _ARRAYSIZE(y); // ok
// }
//


#define RTL_NUMBER_OF_V2(A) RTL_NUMBER_OF_V1(A)



#define RTL_NUMBER_OF(A) RTL_NUMBER_OF_V2(A)

#define RTL_NUMBER_OF(A) RTL_NUMBER_OF_V1(A)


//
// ARRAYSIZE is more readable version of RTL_NUMBER_OF_V2, and uses
// it regardless of ENABLE_RTL_NUMBER_OF_V2
//
// _ARRAYSIZE is a version useful for anonymous types
//
#define ARRAYSIZE(A)    RTL_NUMBER_OF_V2(A)
#define _ARRAYSIZE(A)   RTL_NUMBER_OF_V1(A)

//
// An expression that yields the type of a field in a struct.
//
#define RTL_FIELD_TYPE(type, field) (((type*)0)->field)

// RTL_ to avoid collisions in the global namespace.
//
// Given typedef struct _FOO { BYTE Bar[123]; } FOO;
// RTL_NUMBER_OF_FIELD(FOO, Bar) == 123
//
#define RTL_NUMBER_OF_FIELD(type, field) (RTL_NUMBER_OF(RTL_FIELD_TYPE(type, field)))

//
// eg:
// typedef struct FOO {
//   DWORD Integer;
//   PVOID Pointer;
// } FOO;
//
// RTL_PADDING_BETWEEN_FIELDS(FOO, Integer, Pointer) == 0 for Win32, 4 for Win64
//
#define RTL_PADDING_BETWEEN_FIELDS(T, F1, F2)     ((FIELD_OFFSET(T, F2) > FIELD_OFFSET(T, F1))         ? (FIELD_OFFSET(T, F2) - FIELD_OFFSET(T, F1) - RTL_FIELD_SIZE(T, F1))         : (FIELD_OFFSET(T, F1) - FIELD_OFFSET(T, F2) - RTL_FIELD_SIZE(T, F2)))




// RTL_ to avoid collisions in the global namespace.

#define RTL_CONST_CAST(type) const_cast<type>

#define RTL_CONST_CAST(type) (type)



// like sizeof
// usually this would be * CHAR_BIT, but we don't necessarily have #include <limits.h>
#define RTL_BITS_OF(sizeOfArg) (sizeof(sizeOfArg) * 8)

#define RTL_BITS_OF_FIELD(type, field) (RTL_BITS_OF(RTL_FIELD_TYPE(type, field)))

//
// Calculate the address of the base of the structure given its type, and an
// address of a field within the structure.
//

#define CONTAINING_RECORD(address, type, field) ((type *)(                                                   (PCHAR)(address) -                                                   (ULONG_PTR)(&((type *)0)->field)))



// end_ntminiport end_ntndis

//
// Exception handler routine definition.
//



typedef
		               
               
EXCEPTION_DISPOSITION

EXCEPTION_ROUTINE (
                                            [OnParameterOnly] struct _EXCEPTION_RECORD *ExceptionRecord,
                                               [OnParameterOnly] PVOID EstablisherFrame,
                                            [OnParameterOnly] struct _CONTEXT *ContextRecord,
                                               [OnParameterOnly] PVOID DispatcherContext
    );

typedef EXCEPTION_ROUTINE *PEXCEPTION_ROUTINE;


#define VER_SERVER_NT                       0x80000000
#define VER_WORKSTATION_NT                  0x40000000
#define VER_SUITE_SMALLBUSINESS             0x00000001
#define VER_SUITE_ENTERPRISE                0x00000002
#define VER_SUITE_BACKOFFICE                0x00000004
#define VER_SUITE_COMMUNICATIONS            0x00000008
#define VER_SUITE_TERMINAL                  0x00000010
#define VER_SUITE_SMALLBUSINESS_RESTRICTED  0x00000020
#define VER_SUITE_EMBEDDEDNT                0x00000040
#define VER_SUITE_DATACENTER                0x00000080
#define VER_SUITE_SINGLEUSERTS              0x00000100
#define VER_SUITE_PERSONAL                  0x00000200
#define VER_SUITE_BLADE                     0x00000400
#define VER_SUITE_EMBEDDED_RESTRICTED       0x00000800
#define VER_SUITE_SECURITY_APPLIANCE        0x00001000
#define VER_SUITE_STORAGE_SERVER            0x00002000
#define VER_SUITE_COMPUTE_SERVER            0x00004000
#define VER_SUITE_WH_SERVER                 0x00008000


//
// Product types
// This list grows with each OS release.
//
// There is no ordering of values to ensure callers
// do an equality test i.e. greater-than and less-than
// comparisons are not useful.
//
// NOTE: Values in this list should never be deleted.
//       When a product-type 'X' gets dropped from a
//       OS release onwards, the value of 'X' continues
//       to be used in the mapping table of GetProductInfo.
//

#define PRODUCT_UNDEFINED                           0x00000000

#define PRODUCT_ULTIMATE                            0x00000001
#define PRODUCT_HOME_BASIC                          0x00000002
#define PRODUCT_HOME_PREMIUM                        0x00000003
#define PRODUCT_ENTERPRISE                          0x00000004
#define PRODUCT_HOME_BASIC_N                        0x00000005
#define PRODUCT_BUSINESS                            0x00000006
#define PRODUCT_STANDARD_SERVER                     0x00000007
#define PRODUCT_DATACENTER_SERVER                   0x00000008
#define PRODUCT_SMALLBUSINESS_SERVER                0x00000009
#define PRODUCT_ENTERPRISE_SERVER                   0x0000000A
#define PRODUCT_STARTER                             0x0000000B
#define PRODUCT_DATACENTER_SERVER_CORE              0x0000000C
#define PRODUCT_STANDARD_SERVER_CORE                0x0000000D
#define PRODUCT_ENTERPRISE_SERVER_CORE              0x0000000E
#define PRODUCT_ENTERPRISE_SERVER_IA64              0x0000000F
#define PRODUCT_BUSINESS_N                          0x00000010
#define PRODUCT_WEB_SERVER                          0x00000011
#define PRODUCT_CLUSTER_SERVER                      0x00000012
#define PRODUCT_HOME_SERVER                         0x00000013
#define PRODUCT_STORAGE_EXPRESS_SERVER              0x00000014
#define PRODUCT_STORAGE_STANDARD_SERVER             0x00000015
#define PRODUCT_STORAGE_WORKGROUP_SERVER            0x00000016
#define PRODUCT_STORAGE_ENTERPRISE_SERVER           0x00000017
#define PRODUCT_SERVER_FOR_SMALLBUSINESS            0x00000018
#define PRODUCT_SMALLBUSINESS_SERVER_PREMIUM        0x00000019
#define PRODUCT_HOME_PREMIUM_N                      0x0000001A
#define PRODUCT_ENTERPRISE_N                        0x0000001B
#define PRODUCT_ULTIMATE_N                          0x0000001C
#define PRODUCT_WEB_SERVER_CORE                     0x0000001D
#define PRODUCT_MEDIUMBUSINESS_SERVER_MANAGEMENT    0x0000001E
#define PRODUCT_MEDIUMBUSINESS_SERVER_SECURITY      0x0000001F
#define PRODUCT_MEDIUMBUSINESS_SERVER_MESSAGING     0x00000020
#define PRODUCT_SERVER_FOUNDATION                   0x00000021
#define PRODUCT_HOME_PREMIUM_SERVER                 0x00000022
#define PRODUCT_SERVER_FOR_SMALLBUSINESS_V          0x00000023
#define PRODUCT_STANDARD_SERVER_V                   0x00000024
#define PRODUCT_DATACENTER_SERVER_V                 0x00000025
#define PRODUCT_ENTERPRISE_SERVER_V                 0x00000026
#define PRODUCT_DATACENTER_SERVER_CORE_V            0x00000027
#define PRODUCT_STANDARD_SERVER_CORE_V              0x00000028
#define PRODUCT_ENTERPRISE_SERVER_CORE_V            0x00000029
#define PRODUCT_HYPERV                              0x0000002A
#define PRODUCT_STORAGE_EXPRESS_SERVER_CORE         0x0000002B
#define PRODUCT_STORAGE_STANDARD_SERVER_CORE        0x0000002C
#define PRODUCT_STORAGE_WORKGROUP_SERVER_CORE       0x0000002D
#define PRODUCT_STORAGE_ENTERPRISE_SERVER_CORE      0x0000002E
#define PRODUCT_STARTER_N                           0x0000002F
#define PRODUCT_PROFESSIONAL                        0x00000030
#define PRODUCT_PROFESSIONAL_N                      0x00000031
#define PRODUCT_SB_SOLUTION_SERVER                  0x00000032
#define PRODUCT_SERVER_FOR_SB_SOLUTIONS             0x00000033
#define PRODUCT_STANDARD_SERVER_SOLUTIONS           0x00000034
#define PRODUCT_STANDARD_SERVER_SOLUTIONS_CORE      0x00000035
#define PRODUCT_SB_SOLUTION_SERVER_EM               0x00000036
#define PRODUCT_SERVER_FOR_SB_SOLUTIONS_EM          0x00000037
#define PRODUCT_SOLUTION_EMBEDDEDSERVER             0x00000038
#define PRODUCT_SOLUTION_EMBEDDEDSERVER_CORE        0x00000039
#define PRODUCT_SMALLBUSINESS_SERVER_PREMIUM_CORE   0x0000003F
#define PRODUCT_ESSENTIALBUSINESS_SERVER_MGMT       0x0000003B
#define PRODUCT_ESSENTIALBUSINESS_SERVER_ADDL       0x0000003C
#define PRODUCT_ESSENTIALBUSINESS_SERVER_MGMTSVC    0x0000003D
#define PRODUCT_ESSENTIALBUSINESS_SERVER_ADDLSVC    0x0000003E
#define PRODUCT_CLUSTER_SERVER_V                    0x00000040
#define PRODUCT_EMBEDDED                            0x00000041
#define PRODUCT_STARTER_E                           0x00000042
#define PRODUCT_HOME_BASIC_E                        0x00000043
#define PRODUCT_HOME_PREMIUM_E                      0x00000044
#define PRODUCT_PROFESSIONAL_E                      0x00000045
#define PRODUCT_ENTERPRISE_E                        0x00000046
#define PRODUCT_ULTIMATE_E                          0x00000047

#define PRODUCT_UNLICENSED                          0xABCDABCD



//
//  Language IDs.
//
//  Note that the named locale APIs (eg GetLocaleInfoEx) are preferred.
//
//  Not all locales have unique Language IDs
//
//  The following two combinations of primary language ID and
//  sublanguage ID have special semantics:
//
//    Primary Language ID   Sublanguage ID      Result
//    -------------------   ---------------     ------------------------
//    LANG_NEUTRAL          SUBLANG_NEUTRAL     Language neutral
//    LANG_NEUTRAL          SUBLANG_DEFAULT     User default language
//    LANG_NEUTRAL          SUBLANG_SYS_DEFAULT System default language
//    LANG_INVARIANT        SUBLANG_NEUTRAL     Invariant locale
//
//  It is recommended that applications test for locale names instead of
//  Language IDs / LCIDs.

//
//  Primary language IDs.
//
//  WARNING: These aren't always unique.  Bosnian, Serbian & Croation for example.
//
//  It is recommended that applications test for locale names or actual LCIDs.
//
//  Note that the LANG, SUBLANG construction is not always consistent.
//  The named locale APIs (eg GetLocaleInfoEx) are recommended.
//
#define LANG_NEUTRAL                     0x00
#define LANG_INVARIANT                   0x7f

#define LANG_AFRIKAANS                   0x36
#define LANG_ALBANIAN                    0x1c
#define LANG_ALSATIAN                    0x84
#define LANG_AMHARIC                     0x5e
#define LANG_ARABIC                      0x01
#define LANG_ARMENIAN                    0x2b
#define LANG_ASSAMESE                    0x4d
#define LANG_AZERI                       0x2c
#define LANG_BASHKIR                     0x6d
#define LANG_BASQUE                      0x2d
#define LANG_BELARUSIAN                  0x23
#define LANG_BENGALI                     0x45
#define LANG_BRETON                      0x7e
#define LANG_BOSNIAN                     0x1a   // Use with SUBLANG_BOSNIAN_* Sublanguage IDs
#define LANG_BOSNIAN_NEUTRAL           0x781a   // Use with the ConvertDefaultLocale function
#define LANG_BULGARIAN                   0x02
#define LANG_CATALAN                     0x03
#define LANG_CHINESE                     0x04   // Use with SUBLANG_CHINESE_* Sublanguage IDs
#define LANG_CHINESE_SIMPLIFIED          0x04   // Use with the ConvertDefaultLocale function
#define LANG_CHINESE_TRADITIONAL       0x7c04   // Use with the ConvertDefaultLocale function
#define LANG_CORSICAN                    0x83
#define LANG_CROATIAN                    0x1a
#define LANG_CZECH                       0x05
#define LANG_DANISH                      0x06
#define LANG_DARI                        0x8c
#define LANG_DIVEHI                      0x65
#define LANG_DUTCH                       0x13
#define LANG_ENGLISH                     0x09
#define LANG_ESTONIAN                    0x25
#define LANG_FAEROESE                    0x38
#define LANG_FARSI                       0x29   // Deprecated: use LANG_PERSIAN instead
#define LANG_FILIPINO                    0x64
#define LANG_FINNISH                     0x0b
#define LANG_FRENCH                      0x0c
#define LANG_FRISIAN                     0x62
#define LANG_GALICIAN                    0x56
#define LANG_GEORGIAN                    0x37
#define LANG_GERMAN                      0x07
#define LANG_GREEK                       0x08
#define LANG_GREENLANDIC                 0x6f
#define LANG_GUJARATI                    0x47
#define LANG_HAUSA                       0x68
#define LANG_HEBREW                      0x0d
#define LANG_HINDI                       0x39
#define LANG_HUNGARIAN                   0x0e
#define LANG_ICELANDIC                   0x0f
#define LANG_IGBO                        0x70
#define LANG_INDONESIAN                  0x21
#define LANG_INUKTITUT                   0x5d
#define LANG_IRISH                       0x3c   // Use with the SUBLANG_IRISH_IRELAND Sublanguage ID
#define LANG_ITALIAN                     0x10
#define LANG_JAPANESE                    0x11
#define LANG_KANNADA                     0x4b
#define LANG_KASHMIRI                    0x60
#define LANG_KAZAK                       0x3f
#define LANG_KHMER                       0x53
#define LANG_KICHE                       0x86
#define LANG_KINYARWANDA                 0x87
#define LANG_KONKANI                     0x57
#define LANG_KOREAN                      0x12
#define LANG_KYRGYZ                      0x40
#define LANG_LAO                         0x54
#define LANG_LATVIAN                     0x26
#define LANG_LITHUANIAN                  0x27
#define LANG_LOWER_SORBIAN               0x2e
#define LANG_LUXEMBOURGISH               0x6e
#define LANG_MACEDONIAN                  0x2f   // the Former Yugoslav Republic of Macedonia
#define LANG_MALAY                       0x3e
#define LANG_MALAYALAM                   0x4c
#define LANG_MALTESE                     0x3a
#define LANG_MANIPURI                    0x58
#define LANG_MAORI                       0x81
#define LANG_MAPUDUNGUN                  0x7a
#define LANG_MARATHI                     0x4e
#define LANG_MOHAWK                      0x7c
#define LANG_MONGOLIAN                   0x50
#define LANG_NEPALI                      0x61
#define LANG_NORWEGIAN                   0x14
#define LANG_OCCITAN                     0x82
#define LANG_ORIYA                       0x48
#define LANG_PASHTO                      0x63
#define LANG_PERSIAN                     0x29
#define LANG_POLISH                      0x15
#define LANG_PORTUGUESE                  0x16
#define LANG_PUNJABI                     0x46
#define LANG_QUECHUA                     0x6b
#define LANG_ROMANIAN                    0x18
#define LANG_ROMANSH                     0x17
#define LANG_RUSSIAN                     0x19
#define LANG_SAMI                        0x3b
#define LANG_SANSKRIT                    0x4f
#define LANG_SCOTTISH_GAELIC             0x91
#define LANG_SERBIAN                     0x1a   // Use with the SUBLANG_SERBIAN_* Sublanguage IDs
#define LANG_SERBIAN_NEUTRAL           0x7c1a   // Use with the ConvertDefaultLocale function
#define LANG_SINDHI                      0x59
#define LANG_SINHALESE                   0x5b
#define LANG_SLOVAK                      0x1b
#define LANG_SLOVENIAN                   0x24
#define LANG_SOTHO                       0x6c
#define LANG_SPANISH                     0x0a
#define LANG_SWAHILI                     0x41
#define LANG_SWEDISH                     0x1d
#define LANG_SYRIAC                      0x5a
#define LANG_TAJIK                       0x28
#define LANG_TAMAZIGHT                   0x5f
#define LANG_TAMIL                       0x49
#define LANG_TATAR                       0x44
#define LANG_TELUGU                      0x4a
#define LANG_THAI                        0x1e
#define LANG_TIBETAN                     0x51
#define LANG_TIGRIGNA                    0x73
#define LANG_TSWANA                      0x32
#define LANG_TURKISH                     0x1f
#define LANG_TURKMEN                     0x42
#define LANG_UIGHUR                      0x80
#define LANG_UKRAINIAN                   0x22
#define LANG_UPPER_SORBIAN               0x2e
#define LANG_URDU                        0x20
#define LANG_UZBEK                       0x43
#define LANG_VIETNAMESE                  0x2a
#define LANG_WELSH                       0x52
#define LANG_WOLOF                       0x88
#define LANG_XHOSA                       0x34
#define LANG_YAKUT                       0x85
#define LANG_YI                          0x78
#define LANG_YORUBA                      0x6a
#define LANG_ZULU                        0x35

//
//  Sublanguage IDs.
//
//  The name immediately following SUBLANG_ dictates which primary
//  language ID that sublanguage ID can be combined with to form a
//  valid language ID.
//
//  Note that the LANG, SUBLANG construction is not always consistent.
//  The named locale APIs (eg GetLocaleInfoEx) are recommended.
//

#define SUBLANG_NEUTRAL                             0x00    // language neutral
#define SUBLANG_DEFAULT                             0x01    // user default
#define SUBLANG_SYS_DEFAULT                         0x02    // system default
#define SUBLANG_CUSTOM_DEFAULT                      0x03    // default custom language/locale
#define SUBLANG_CUSTOM_UNSPECIFIED                  0x04    // custom language/locale
#define SUBLANG_UI_CUSTOM_DEFAULT                   0x05    // Default custom MUI language/locale


#define SUBLANG_AFRIKAANS_SOUTH_AFRICA              0x01    // Afrikaans (South Africa) 0x0436 af-ZA
#define SUBLANG_ALBANIAN_ALBANIA                    0x01    // Albanian (Albania) 0x041c sq-AL
#define SUBLANG_ALSATIAN_FRANCE                     0x01    // Alsatian (France) 0x0484
#define SUBLANG_AMHARIC_ETHIOPIA                    0x01    // Amharic (Ethiopia) 0x045e
#define SUBLANG_ARABIC_SAUDI_ARABIA                 0x01    // Arabic (Saudi Arabia)
#define SUBLANG_ARABIC_IRAQ                         0x02    // Arabic (Iraq)
#define SUBLANG_ARABIC_EGYPT                        0x03    // Arabic (Egypt)
#define SUBLANG_ARABIC_LIBYA                        0x04    // Arabic (Libya)
#define SUBLANG_ARABIC_ALGERIA                      0x05    // Arabic (Algeria)
#define SUBLANG_ARABIC_MOROCCO                      0x06    // Arabic (Morocco)
#define SUBLANG_ARABIC_TUNISIA                      0x07    // Arabic (Tunisia)
#define SUBLANG_ARABIC_OMAN                         0x08    // Arabic (Oman)
#define SUBLANG_ARABIC_YEMEN                        0x09    // Arabic (Yemen)
#define SUBLANG_ARABIC_SYRIA                        0x0a    // Arabic (Syria)
#define SUBLANG_ARABIC_JORDAN                       0x0b    // Arabic (Jordan)
#define SUBLANG_ARABIC_LEBANON                      0x0c    // Arabic (Lebanon)
#define SUBLANG_ARABIC_KUWAIT                       0x0d    // Arabic (Kuwait)
#define SUBLANG_ARABIC_UAE                          0x0e    // Arabic (U.A.E)
#define SUBLANG_ARABIC_BAHRAIN                      0x0f    // Arabic (Bahrain)
#define SUBLANG_ARABIC_QATAR                        0x10    // Arabic (Qatar)
#define SUBLANG_ARMENIAN_ARMENIA                    0x01    // Armenian (Armenia) 0x042b hy-AM
#define SUBLANG_ASSAMESE_INDIA                      0x01    // Assamese (India) 0x044d
#define SUBLANG_AZERI_LATIN                         0x01    // Azeri (Latin)
#define SUBLANG_AZERI_CYRILLIC                      0x02    // Azeri (Cyrillic)
#define SUBLANG_BASHKIR_RUSSIA                      0x01    // Bashkir (Russia) 0x046d ba-RU
#define SUBLANG_BASQUE_BASQUE                       0x01    // Basque (Basque) 0x042d eu-ES
#define SUBLANG_BELARUSIAN_BELARUS                  0x01    // Belarusian (Belarus) 0x0423 be-BY
#define SUBLANG_BENGALI_INDIA                       0x01    // Bengali (India)
#define SUBLANG_BENGALI_BANGLADESH                  0x02    // Bengali (Bangladesh)
#define SUBLANG_BOSNIAN_BOSNIA_HERZEGOVINA_LATIN    0x05    // Bosnian (Bosnia and Herzegovina - Latin) 0x141a bs-BA-Latn
#define SUBLANG_BOSNIAN_BOSNIA_HERZEGOVINA_CYRILLIC 0x08    // Bosnian (Bosnia and Herzegovina - Cyrillic) 0x201a bs-BA-Cyrl
#define SUBLANG_BRETON_FRANCE                       0x01    // Breton (France) 0x047e
#define SUBLANG_BULGARIAN_BULGARIA                  0x01    // Bulgarian (Bulgaria) 0x0402
#define SUBLANG_CATALAN_CATALAN                     0x01    // Catalan (Catalan) 0x0403
#define SUBLANG_CHINESE_TRADITIONAL                 0x01    // Chinese (Taiwan) 0x0404 zh-TW
#define SUBLANG_CHINESE_SIMPLIFIED                  0x02    // Chinese (PR China) 0x0804 zh-CN
#define SUBLANG_CHINESE_HONGKONG                    0x03    // Chinese (Hong Kong S.A.R., P.R.C.) 0x0c04 zh-HK
#define SUBLANG_CHINESE_SINGAPORE                   0x04    // Chinese (Singapore) 0x1004 zh-SG
#define SUBLANG_CHINESE_MACAU                       0x05    // Chinese (Macau S.A.R.) 0x1404 zh-MO
#define SUBLANG_CORSICAN_FRANCE                     0x01    // Corsican (France) 0x0483
#define SUBLANG_CZECH_CZECH_REPUBLIC                0x01    // Czech (Czech Republic) 0x0405
#define SUBLANG_CROATIAN_CROATIA                    0x01    // Croatian (Croatia)
#define SUBLANG_CROATIAN_BOSNIA_HERZEGOVINA_LATIN   0x04    // Croatian (Bosnia and Herzegovina - Latin) 0x101a hr-BA
#define SUBLANG_DANISH_DENMARK                      0x01    // Danish (Denmark) 0x0406
#define SUBLANG_DARI_AFGHANISTAN                    0x01    // Dari (Afghanistan)
#define SUBLANG_DIVEHI_MALDIVES                     0x01    // Divehi (Maldives) 0x0465 div-MV
#define SUBLANG_DUTCH                               0x01    // Dutch
#define SUBLANG_DUTCH_BELGIAN                       0x02    // Dutch (Belgian)
#define SUBLANG_ENGLISH_US                          0x01    // English (USA)
#define SUBLANG_ENGLISH_UK                          0x02    // English (UK)
#define SUBLANG_ENGLISH_AUS                         0x03    // English (Australian)
#define SUBLANG_ENGLISH_CAN                         0x04    // English (Canadian)
#define SUBLANG_ENGLISH_NZ                          0x05    // English (New Zealand)
#define SUBLANG_ENGLISH_EIRE                        0x06    // English (Irish)
#define SUBLANG_ENGLISH_SOUTH_AFRICA                0x07    // English (South Africa)
#define SUBLANG_ENGLISH_JAMAICA                     0x08    // English (Jamaica)
#define SUBLANG_ENGLISH_CARIBBEAN                   0x09    // English (Caribbean)
#define SUBLANG_ENGLISH_BELIZE                      0x0a    // English (Belize)
#define SUBLANG_ENGLISH_TRINIDAD                    0x0b    // English (Trinidad)
#define SUBLANG_ENGLISH_ZIMBABWE                    0x0c    // English (Zimbabwe)
#define SUBLANG_ENGLISH_PHILIPPINES                 0x0d    // English (Philippines)
#define SUBLANG_ENGLISH_INDIA                       0x10    // English (India)
#define SUBLANG_ENGLISH_MALAYSIA                    0x11    // English (Malaysia)
#define SUBLANG_ENGLISH_SINGAPORE                   0x12    // English (Singapore)
#define SUBLANG_ESTONIAN_ESTONIA                    0x01    // Estonian (Estonia) 0x0425 et-EE
#define SUBLANG_FAEROESE_FAROE_ISLANDS              0x01    // Faroese (Faroe Islands) 0x0438 fo-FO
#define SUBLANG_FILIPINO_PHILIPPINES                0x01    // Filipino (Philippines) 0x0464 fil-PH
#define SUBLANG_FINNISH_FINLAND                     0x01    // Finnish (Finland) 0x040b
#define SUBLANG_FRENCH                              0x01    // French
#define SUBLANG_FRENCH_BELGIAN                      0x02    // French (Belgian)
#define SUBLANG_FRENCH_CANADIAN                     0x03    // French (Canadian)
#define SUBLANG_FRENCH_SWISS                        0x04    // French (Swiss)
#define SUBLANG_FRENCH_LUXEMBOURG                   0x05    // French (Luxembourg)
#define SUBLANG_FRENCH_MONACO                       0x06    // French (Monaco)
#define SUBLANG_FRISIAN_NETHERLANDS                 0x01    // Frisian (Netherlands) 0x0462 fy-NL
#define SUBLANG_GALICIAN_GALICIAN                   0x01    // Galician (Galician) 0x0456 gl-ES
#define SUBLANG_GEORGIAN_GEORGIA                    0x01    // Georgian (Georgia) 0x0437 ka-GE
#define SUBLANG_GERMAN                              0x01    // German
#define SUBLANG_GERMAN_SWISS                        0x02    // German (Swiss)
#define SUBLANG_GERMAN_AUSTRIAN                     0x03    // German (Austrian)
#define SUBLANG_GERMAN_LUXEMBOURG                   0x04    // German (Luxembourg)
#define SUBLANG_GERMAN_LIECHTENSTEIN                0x05    // German (Liechtenstein)
#define SUBLANG_GREEK_GREECE                        0x01    // Greek (Greece)
#define SUBLANG_GREENLANDIC_GREENLAND               0x01    // Greenlandic (Greenland) 0x046f kl-GL
#define SUBLANG_GUJARATI_INDIA                      0x01    // Gujarati (India (Gujarati Script)) 0x0447 gu-IN
#define SUBLANG_HAUSA_NIGERIA_LATIN                 0x01    // Hausa (Latin, Nigeria) 0x0468 ha-NG-Latn
#define SUBLANG_HEBREW_ISRAEL                       0x01    // Hebrew (Israel) 0x040d
#define SUBLANG_HINDI_INDIA                         0x01    // Hindi (India) 0x0439 hi-IN
#define SUBLANG_HUNGARIAN_HUNGARY                   0x01    // Hungarian (Hungary) 0x040e
#define SUBLANG_ICELANDIC_ICELAND                   0x01    // Icelandic (Iceland) 0x040f
#define SUBLANG_IGBO_NIGERIA                        0x01    // Igbo (Nigeria) 0x0470 ig-NG
#define SUBLANG_INDONESIAN_INDONESIA                0x01    // Indonesian (Indonesia) 0x0421 id-ID
#define SUBLANG_INUKTITUT_CANADA                    0x01    // Inuktitut (Syllabics) (Canada) 0x045d iu-CA-Cans
#define SUBLANG_INUKTITUT_CANADA_LATIN              0x02    // Inuktitut (Canada - Latin)
#define SUBLANG_IRISH_IRELAND                       0x02    // Irish (Ireland)
#define SUBLANG_ITALIAN                             0x01    // Italian
#define SUBLANG_ITALIAN_SWISS                       0x02    // Italian (Swiss)
#define SUBLANG_JAPANESE_JAPAN                      0x01    // Japanese (Japan) 0x0411
#define SUBLANG_KANNADA_INDIA                       0x01    // Kannada (India (Kannada Script)) 0x044b kn-IN
#define SUBLANG_KASHMIRI_SASIA                      0x02    // Kashmiri (South Asia)
#define SUBLANG_KASHMIRI_INDIA                      0x02    // For app compatibility only
#define SUBLANG_KAZAK_KAZAKHSTAN                    0x01    // Kazakh (Kazakhstan) 0x043f kk-KZ
#define SUBLANG_KHMER_CAMBODIA                      0x01    // Khmer (Cambodia) 0x0453 kh-KH
#define SUBLANG_KICHE_GUATEMALA                     0x01    // K'iche (Guatemala)
#define SUBLANG_KINYARWANDA_RWANDA                  0x01    // Kinyarwanda (Rwanda) 0x0487 rw-RW
#define SUBLANG_KONKANI_INDIA                       0x01    // Konkani (India) 0x0457 kok-IN
#define SUBLANG_KOREAN                              0x01    // Korean (Extended Wansung)
#define SUBLANG_KYRGYZ_KYRGYZSTAN                   0x01    // Kyrgyz (Kyrgyzstan) 0x0440 ky-KG
#define SUBLANG_LAO_LAO                             0x01    // Lao (Lao PDR) 0x0454 lo-LA
#define SUBLANG_LATVIAN_LATVIA                      0x01    // Latvian (Latvia) 0x0426 lv-LV
#define SUBLANG_LITHUANIAN                          0x01    // Lithuanian
#define SUBLANG_LOWER_SORBIAN_GERMANY               0x02    // Lower Sorbian (Germany) 0x082e wee-DE
#define SUBLANG_LUXEMBOURGISH_LUXEMBOURG            0x01    // Luxembourgish (Luxembourg) 0x046e lb-LU
#define SUBLANG_MACEDONIAN_MACEDONIA                0x01    // Macedonian (Macedonia (FYROM)) 0x042f mk-MK
#define SUBLANG_MALAY_MALAYSIA                      0x01    // Malay (Malaysia)
#define SUBLANG_MALAY_BRUNEI_DARUSSALAM             0x02    // Malay (Brunei Darussalam)
#define SUBLANG_MALAYALAM_INDIA                     0x01    // Malayalam (India (Malayalam Script) ) 0x044c ml-IN
#define SUBLANG_MALTESE_MALTA                       0x01    // Maltese (Malta) 0x043a mt-MT
#define SUBLANG_MAORI_NEW_ZEALAND                   0x01    // Maori (New Zealand) 0x0481 mi-NZ
#define SUBLANG_MAPUDUNGUN_CHILE                    0x01    // Mapudungun (Chile) 0x047a arn-CL
#define SUBLANG_MARATHI_INDIA                       0x01    // Marathi (India) 0x044e mr-IN
#define SUBLANG_MOHAWK_MOHAWK                       0x01    // Mohawk (Mohawk) 0x047c moh-CA
#define SUBLANG_MONGOLIAN_CYRILLIC_MONGOLIA         0x01    // Mongolian (Cyrillic, Mongolia)
#define SUBLANG_MONGOLIAN_PRC                       0x02    // Mongolian (PRC)
#define SUBLANG_NEPALI_INDIA                        0x02    // Nepali (India)
#define SUBLANG_NEPALI_NEPAL                        0x01    // Nepali (Nepal) 0x0461 ne-NP
#define SUBLANG_NORWEGIAN_BOKMAL                    0x01    // Norwegian (Bokmal)
#define SUBLANG_NORWEGIAN_NYNORSK                   0x02    // Norwegian (Nynorsk)
#define SUBLANG_OCCITAN_FRANCE                      0x01    // Occitan (France) 0x0482 oc-FR
#define SUBLANG_ORIYA_INDIA                         0x01    // Oriya (India (Oriya Script)) 0x0448 or-IN
#define SUBLANG_PASHTO_AFGHANISTAN                  0x01    // Pashto (Afghanistan)
#define SUBLANG_PERSIAN_IRAN                        0x01    // Persian (Iran) 0x0429 fa-IR
#define SUBLANG_POLISH_POLAND                       0x01    // Polish (Poland) 0x0415
#define SUBLANG_PORTUGUESE                          0x02    // Portuguese
#define SUBLANG_PORTUGUESE_BRAZILIAN                0x01    // Portuguese (Brazilian)
#define SUBLANG_PUNJABI_INDIA                       0x01    // Punjabi (India (Gurmukhi Script)) 0x0446 pa-IN
#define SUBLANG_QUECHUA_BOLIVIA                     0x01    // Quechua (Bolivia)
#define SUBLANG_QUECHUA_ECUADOR                     0x02    // Quechua (Ecuador)
#define SUBLANG_QUECHUA_PERU                        0x03    // Quechua (Peru)
#define SUBLANG_ROMANIAN_ROMANIA                    0x01    // Romanian (Romania) 0x0418
#define SUBLANG_ROMANSH_SWITZERLAND                 0x01    // Romansh (Switzerland) 0x0417 rm-CH
#define SUBLANG_RUSSIAN_RUSSIA                      0x01    // Russian (Russia) 0x0419
#define SUBLANG_SAMI_NORTHERN_NORWAY                0x01    // Northern Sami (Norway)
#define SUBLANG_SAMI_NORTHERN_SWEDEN                0x02    // Northern Sami (Sweden)
#define SUBLANG_SAMI_NORTHERN_FINLAND               0x03    // Northern Sami (Finland)
#define SUBLANG_SAMI_LULE_NORWAY                    0x04    // Lule Sami (Norway)
#define SUBLANG_SAMI_LULE_SWEDEN                    0x05    // Lule Sami (Sweden)
#define SUBLANG_SAMI_SOUTHERN_NORWAY                0x06    // Southern Sami (Norway)
#define SUBLANG_SAMI_SOUTHERN_SWEDEN                0x07    // Southern Sami (Sweden)
#define SUBLANG_SAMI_SKOLT_FINLAND                  0x08    // Skolt Sami (Finland)
#define SUBLANG_SAMI_INARI_FINLAND                  0x09    // Inari Sami (Finland)
#define SUBLANG_SANSKRIT_INDIA                      0x01    // Sanskrit (India) 0x044f sa-IN
#define SUBLANG_SCOTTISH_GAELIC                     0x01    // Scottish Gaelic (United Kingdom) 0x0491 gd-GB
#define SUBLANG_SERBIAN_BOSNIA_HERZEGOVINA_LATIN    0x06    // Serbian (Bosnia and Herzegovina - Latin)
#define SUBLANG_SERBIAN_BOSNIA_HERZEGOVINA_CYRILLIC 0x07    // Serbian (Bosnia and Herzegovina - Cyrillic)
#define SUBLANG_SERBIAN_MONTENEGRO_LATIN            0x0b    // Serbian (Montenegro - Latn)
#define SUBLANG_SERBIAN_MONTENEGRO_CYRILLIC         0x0c    // Serbian (Montenegro - Cyrillic)
#define SUBLANG_SERBIAN_SERBIA_LATIN                0x09    // Serbian (Serbia - Latin)
#define SUBLANG_SERBIAN_SERBIA_CYRILLIC             0x0a    // Serbian (Serbia - Cyrillic)
#define SUBLANG_SERBIAN_CROATIA                     0x01    // Croatian (Croatia) 0x041a hr-HR
#define SUBLANG_SERBIAN_LATIN                       0x02    // Serbian (Latin)
#define SUBLANG_SERBIAN_CYRILLIC                    0x03    // Serbian (Cyrillic)
#define SUBLANG_SINDHI_INDIA                        0x01    // Sindhi (India) reserved 0x0459
#define SUBLANG_SINDHI_PAKISTAN                     0x02    // Sindhi (Pakistan) reserved 0x0859
#define SUBLANG_SINDHI_AFGHANISTAN                  0x02    // For app compatibility only
#define SUBLANG_SINHALESE_SRI_LANKA                 0x01    // Sinhalese (Sri Lanka)
#define SUBLANG_SOTHO_NORTHERN_SOUTH_AFRICA         0x01    // Northern Sotho (South Africa)
#define SUBLANG_SLOVAK_SLOVAKIA                     0x01    // Slovak (Slovakia) 0x041b sk-SK
#define SUBLANG_SLOVENIAN_SLOVENIA                  0x01    // Slovenian (Slovenia) 0x0424 sl-SI
#define SUBLANG_SPANISH                             0x01    // Spanish (Castilian)
#define SUBLANG_SPANISH_MEXICAN                     0x02    // Spanish (Mexican)
#define SUBLANG_SPANISH_MODERN                      0x03    // Spanish (Modern)
#define SUBLANG_SPANISH_GUATEMALA                   0x04    // Spanish (Guatemala)
#define SUBLANG_SPANISH_COSTA_RICA                  0x05    // Spanish (Costa Rica)
#define SUBLANG_SPANISH_PANAMA                      0x06    // Spanish (Panama)
#define SUBLANG_SPANISH_DOMINICAN_REPUBLIC          0x07    // Spanish (Dominican Republic)
#define SUBLANG_SPANISH_VENEZUELA                   0x08    // Spanish (Venezuela)
#define SUBLANG_SPANISH_COLOMBIA                    0x09    // Spanish (Colombia)
#define SUBLANG_SPANISH_PERU                        0x0a    // Spanish (Peru)
#define SUBLANG_SPANISH_ARGENTINA                   0x0b    // Spanish (Argentina)
#define SUBLANG_SPANISH_ECUADOR                     0x0c    // Spanish (Ecuador)
#define SUBLANG_SPANISH_CHILE                       0x0d    // Spanish (Chile)
#define SUBLANG_SPANISH_URUGUAY                     0x0e    // Spanish (Uruguay)
#define SUBLANG_SPANISH_PARAGUAY                    0x0f    // Spanish (Paraguay)
#define SUBLANG_SPANISH_BOLIVIA                     0x10    // Spanish (Bolivia)
#define SUBLANG_SPANISH_EL_SALVADOR                 0x11    // Spanish (El Salvador)
#define SUBLANG_SPANISH_HONDURAS                    0x12    // Spanish (Honduras)
#define SUBLANG_SPANISH_NICARAGUA                   0x13    // Spanish (Nicaragua)
#define SUBLANG_SPANISH_PUERTO_RICO                 0x14    // Spanish (Puerto Rico)
#define SUBLANG_SPANISH_US                          0x15    // Spanish (United States)
#define SUBLANG_SWAHILI_KENYA                       0x01    // Swahili (Kenya) 0x0441 sw-KE
#define SUBLANG_SWEDISH                             0x01    // Swedish
#define SUBLANG_SWEDISH_FINLAND                     0x02    // Swedish (Finland)
#define SUBLANG_SYRIAC_SYRIA                        0x01    // Syriac (Syria) 0x045a syr-SY
#define SUBLANG_TAJIK_TAJIKISTAN                    0x01    // Tajik (Tajikistan) 0x0428 tg-TJ-Cyrl
#define SUBLANG_TAMAZIGHT_ALGERIA_LATIN             0x02    // Tamazight (Latin, Algeria) 0x085f tmz-DZ-Latn
#define SUBLANG_TAMIL_INDIA                         0x01    // Tamil (India)
#define SUBLANG_TATAR_RUSSIA                        0x01    // Tatar (Russia) 0x0444 tt-RU
#define SUBLANG_TELUGU_INDIA                        0x01    // Telugu (India (Telugu Script)) 0x044a te-IN
#define SUBLANG_THAI_THAILAND                       0x01    // Thai (Thailand) 0x041e th-TH
#define SUBLANG_TIBETAN_PRC                         0x01    // Tibetan (PRC)
#define SUBLANG_TIGRIGNA_ERITREA                    0x02    // Tigrigna (Eritrea)
#define SUBLANG_TSWANA_SOUTH_AFRICA                 0x01    // Setswana / Tswana (South Africa) 0x0432 tn-ZA
#define SUBLANG_TURKISH_TURKEY                      0x01    // Turkish (Turkey) 0x041f tr-TR
#define SUBLANG_TURKMEN_TURKMENISTAN                0x01    // Turkmen (Turkmenistan) 0x0442 tk-TM
#define SUBLANG_UIGHUR_PRC                          0x01    // Uighur (PRC) 0x0480 ug-CN
#define SUBLANG_UKRAINIAN_UKRAINE                   0x01    // Ukrainian (Ukraine) 0x0422 uk-UA
#define SUBLANG_UPPER_SORBIAN_GERMANY               0x01    // Upper Sorbian (Germany) 0x042e wen-DE
#define SUBLANG_URDU_PAKISTAN                       0x01    // Urdu (Pakistan)
#define SUBLANG_URDU_INDIA                          0x02    // Urdu (India)
#define SUBLANG_UZBEK_LATIN                         0x01    // Uzbek (Latin)
#define SUBLANG_UZBEK_CYRILLIC                      0x02    // Uzbek (Cyrillic)
#define SUBLANG_VIETNAMESE_VIETNAM                  0x01    // Vietnamese (Vietnam) 0x042a vi-VN
#define SUBLANG_WELSH_UNITED_KINGDOM                0x01    // Welsh (United Kingdom) 0x0452 cy-GB
#define SUBLANG_WOLOF_SENEGAL                       0x01    // Wolof (Senegal)
#define SUBLANG_XHOSA_SOUTH_AFRICA                  0x01    // isiXhosa / Xhosa (South Africa) 0x0434 xh-ZA
#define SUBLANG_YAKUT_RUSSIA                        0x01    // Yakut (Russia) 0x0485 sah-RU
#define SUBLANG_YI_PRC                              0x01    // Yi (PRC)) 0x0478
#define SUBLANG_YORUBA_NIGERIA                      0x01    // Yoruba (Nigeria) 046a yo-NG
#define SUBLANG_ZULU_SOUTH_AFRICA                   0x01    // isiZulu / Zulu (South Africa) 0x0435 zu-ZA




//
//  Sorting IDs.
//
//  Note that the named locale APIs (eg CompareStringExEx) are recommended.
//

#define SORT_DEFAULT                     0x0     // sorting default

#define SORT_INVARIANT_MATH              0x1     // Invariant (Mathematical Symbols)

#define SORT_JAPANESE_XJIS               0x0     // Japanese XJIS order
#define SORT_JAPANESE_UNICODE            0x1     // Japanese Unicode order (no longer supported)
#define SORT_JAPANESE_RADICALSTROKE      0x4     // Japanese radical/stroke order

#define SORT_CHINESE_BIG5                0x0     // Chinese BIG5 order
#define SORT_CHINESE_PRCP                0x0     // PRC Chinese Phonetic order
#define SORT_CHINESE_UNICODE             0x1     // Chinese Unicode order (no longer supported)
#define SORT_CHINESE_PRC                 0x2     // PRC Chinese Stroke Count order
#define SORT_CHINESE_BOPOMOFO            0x3     // Traditional Chinese Bopomofo order
#define SORT_CHINESE_RADICALSTROKE       0x4     // Traditional Chinese radical/stroke order.

#define SORT_KOREAN_KSC                  0x0     // Korean KSC order
#define SORT_KOREAN_UNICODE              0x1     // Korean Unicode order (no longer supported)

#define SORT_GERMAN_PHONE_BOOK           0x1     // German Phone Book order

#define SORT_HUNGARIAN_DEFAULT           0x0     // Hungarian Default order
#define SORT_HUNGARIAN_TECHNICAL         0x1     // Hungarian Technical order

#define SORT_GEORGIAN_TRADITIONAL        0x0     // Georgian Traditional order
#define SORT_GEORGIAN_MODERN             0x1     // Georgian Modern order

// end_r_winnt

//
//  A language ID is a 16 bit value which is the combination of a
//  primary language ID and a secondary language ID.  The bits are
//  allocated as follows:
//
//       +-----------------------+-------------------------+
//       |     Sublanguage ID    |   Primary Language ID   |
//       +-----------------------+-------------------------+
//        15                   10 9                       0   bit
//
//  WARNING:  This pattern isn't always follows, Serbina, Bosnian & Croation
//            for example.
//
//  It is recommended that applications test for locale names or actual LCIDs.
//
//  Language ID creation/extraction macros:
//
//    MAKELANGID    - construct language id from a primary language id and
//                    a sublanguage id.
//    PRIMARYLANGID - extract primary language id from a language id.
//    SUBLANGID     - extract sublanguage id from a language id.
//
//  Note that the LANG, SUBLANG construction is not always consistent.
//  The named locale APIs (eg GetLocaleInfoEx) are recommended.
//
//  Language IDs do not exist for all locales
//
#define MAKELANGID(p, s)       ((((WORD  )(s)) << 10) | (WORD  )(p))
#define PRIMARYLANGID(lgid)    ((WORD  )(lgid) & 0x3ff)
#define SUBLANGID(lgid)        ((WORD  )(lgid) >> 10)


//
//  A locale ID is a 32 bit value which is the combination of a
//  language ID, a sort ID, and a reserved area.  The bits are
//  allocated as follows:
//
//       +-------------+---------+-------------------------+
//       |   Reserved  | Sort ID |      Language ID        |
//       +-------------+---------+-------------------------+
//        31         20 19     16 15                      0   bit
//
//  WARNING: This pattern isn't always followed (es-ES_tradnl vs es-ES for example)
//
//  It is recommended that applications test for locale names or actual LCIDs.
//
//  Locale ID creation/extraction macros:
//
//    MAKELCID            - construct the locale id from a language id and a sort id.
//    MAKESORTLCID        - construct the locale id from a language id, sort id, and sort version.
//    LANGIDFROMLCID      - extract the language id from a locale id.
//    SORTIDFROMLCID      - extract the sort id from a locale id.
//    SORTVERSIONFROMLCID - extract the sort version from a locale id.
//
//  Note that the LANG, SUBLANG construction is not always consistent.
//  The named locale APIs (eg GetLocaleInfoEx) are recommended.
//
//  LCIDs do not exist for all locales.
//
#define NLS_VALID_LOCALE_MASK  0x000fffff

#define MAKELCID(lgid, srtid)  ((DWORD)((((DWORD)((WORD  )(srtid))) << 16) |                                           ((DWORD)((WORD  )(lgid)))))

#define MAKESORTLCID(lgid, srtid, ver)                                                                           ((DWORD)((MAKELCID(lgid, srtid)) |                                                 (((DWORD)((WORD  )(ver))) << 20)))


#define LANGIDFROMLCID(lcid)   ((WORD  )(lcid))
#define SORTIDFROMLCID(lcid)   ((WORD  )((((DWORD)(lcid)) >> 16) & 0xf))
#define SORTVERSIONFROMLCID(lcid)  ((WORD  )((((DWORD)(lcid)) >> 20) & 0xf))

// 8 characters for language
// 8 characters for region
// 64 characters for suffix (script)
// 2 characters for '-' separators
// 2 characters for prefix like "i-" or "x-"
// 1 null termination
#define LOCALE_NAME_MAX_LENGTH   85

//
//  Default System and User IDs for language and locale.
//  Locale names such as LOCALE_NAME_SYSTEM_DEFAULT, LOCALE_NAME_USER_DEFAULT,
//  and LOCALE_NAME_INVARIANT are preferred.
//

#define LANG_SYSTEM_DEFAULT    (MAKELANGID(LANG_NEUTRAL, SUBLANG_SYS_DEFAULT))
#define LANG_USER_DEFAULT      (MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT))

#define LOCALE_SYSTEM_DEFAULT  (MAKELCID(LANG_SYSTEM_DEFAULT, SORT_DEFAULT))
#define LOCALE_USER_DEFAULT    (MAKELCID(LANG_USER_DEFAULT, SORT_DEFAULT))

//
//  Other special IDs for language and locale.
//
#define LOCALE_CUSTOM_DEFAULT                                                           (MAKELCID(MAKELANGID(LANG_NEUTRAL, SUBLANG_CUSTOM_DEFAULT), SORT_DEFAULT))


#define LOCALE_CUSTOM_UNSPECIFIED                                                       (MAKELCID(MAKELANGID(LANG_NEUTRAL, SUBLANG_CUSTOM_UNSPECIFIED), SORT_DEFAULT))


#define LOCALE_CUSTOM_UI_DEFAULT                                                        (MAKELCID(MAKELANGID(LANG_NEUTRAL, SUBLANG_UI_CUSTOM_DEFAULT), SORT_DEFAULT))


#define LOCALE_NEUTRAL                                                                  (MAKELCID(MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL), SORT_DEFAULT))


#define LOCALE_INVARIANT                                                                (MAKELCID(MAKELANGID(LANG_INVARIANT, SUBLANG_NEUTRAL), SORT_DEFAULT))


// begin_ntminiport begin_ntndis begin_ntminitape

//
// Macros used to eliminate compiler warning generated when formal
// parameters or local variables are not declared.
//
// Use DBG_UNREFERENCED_PARAMETER() when a parameter is not yet
// referenced but will be once the module is completely developed.
//
// Use DBG_UNREFERENCED_LOCAL_VARIABLE() when a local variable is not yet
// referenced but will be once the module is completely developed.
//
// Use UNREFERENCED_PARAMETER() if a parameter will never be referenced.
//
// DBG_UNREFERENCED_PARAMETER and DBG_UNREFERENCED_LOCAL_VARIABLE will
// eventually be made into a null macro to help determine whether there
// is unfinished work.
//


#define UNREFERENCED_PARAMETER(P)          (P)
#define DBG_UNREFERENCED_PARAMETER(P)      (P)
#define DBG_UNREFERENCED_LOCAL_VARIABLE(V) (V)







#define UNREFERENCED_PARAMETER(P)                                              {         (P) = (P);     }                       





#define DBG_UNREFERENCED_PARAMETER(P)                                          {         (P) = (P);     }                       





#define DBG_UNREFERENCED_LOCAL_VARIABLE(V)                                     {         (V) = (V);     }                       








//
// Macro used to eliminate compiler warning 4715 within a switch statement
// when all possible cases have already been accounted for.
//
// switch (a & 3) {
//     case 0: return 1;
//     case 1: return Foo();
//     case 2: return Bar();
//     case 3: return 1;
//     DEFAULT_UNREACHABLE;
//


#define DEFAULT_UNREACHABLE default: __assume(0)







#define DEFAULT_UNREACHABLE





// Define operator overloads to enable bit operations on enum values that are 
// used to define flags. Use DEFINE_ENUM_FLAG_OPERATORS(YOUR_TYPE) to enable these 
// operators on YOUR_TYPE.

// Moved here from objbase.w.

#define DEFINE_ENUM_FLAG_OPERATORS(ENUMTYPE) extern "C++" { inline ENUMTYPE operator | (ENUMTYPE a, ENUMTYPE b) { return ENUMTYPE(((int)a) | ((int)b)); } inline ENUMTYPE &operator |= (ENUMTYPE &a, ENUMTYPE b) { return (ENUMTYPE &)(((int &)a) |= ((int)b)); } inline ENUMTYPE operator & (ENUMTYPE a, ENUMTYPE b) { return ENUMTYPE(((int)a) & ((int)b)); } inline ENUMTYPE &operator &= (ENUMTYPE &a, ENUMTYPE b) { return (ENUMTYPE &)(((int &)a) &= ((int)b)); } inline ENUMTYPE operator ~ (ENUMTYPE a) { return ENUMTYPE(~((int)a)); } inline ENUMTYPE operator ^ (ENUMTYPE a, ENUMTYPE b) { return ENUMTYPE(((int)a) ^ ((int)b)); } inline ENUMTYPE &operator ^= (ENUMTYPE &a, ENUMTYPE b) { return (ENUMTYPE &)(((int &)a) ^= ((int)b)); } }










#define DEFINE_ENUM_FLAG_OPERATORS(ENUMTYPE) // NOP, C allows these operators.


// Compile-time macros for initializing flag values in const data.
// 
// When using DEFINE_ENUM_FLAG_OPERATORS for enum values you should use the macros below
// when you need to initialize global const data.  Without these macros the inline operators 
// from DEFINE_ENUM_FLAG_OPERATORS force a runtime initialization rather than a
// compile time initialization.  This applies even if you have declared the data as const.
#define COMPILETIME_OR_2FLAGS(a,b)          ((UINT)(a)|(UINT)(b))
#define COMPILETIME_OR_3FLAGS(a,b,c)        ((UINT)(a)|(UINT)(b)|(UINT)(c))
#define COMPILETIME_OR_4FLAGS(a,b,c,d)      ((UINT)(a)|(UINT)(b)|(UINT)(c)|(UINT)(d))
#define COMPILETIME_OR_5FLAGS(a,b,c,d,e)    ((UINT)(a)|(UINT)(b)|(UINT)(c)|(UINT)(d)|(UINT)(e))


                       
#define STATUS_WAIT_0                    ((DWORD   )0x00000000L)    
#define STATUS_ABANDONED_WAIT_0          ((DWORD   )0x00000080L)    
#define STATUS_USER_APC                  ((DWORD   )0x000000C0L)    
#define STATUS_TIMEOUT                   ((DWORD   )0x00000102L)    
#define STATUS_PENDING                   ((DWORD   )0x00000103L)    
#define DBG_EXCEPTION_HANDLED            ((DWORD   )0x00010001L)    
#define DBG_CONTINUE                     ((DWORD   )0x00010002L)    
#define STATUS_SEGMENT_NOTIFICATION      ((DWORD   )0x40000005L)    
#define DBG_TERMINATE_THREAD             ((DWORD   )0x40010003L)    
#define DBG_TERMINATE_PROCESS            ((DWORD   )0x40010004L)    
#define DBG_CONTROL_C                    ((DWORD   )0x40010005L)    
#define DBG_PRINTEXCEPTION_C             ((DWORD   )0x40010006L)    
#define DBG_RIPEXCEPTION                 ((DWORD   )0x40010007L)    
#define DBG_CONTROL_BREAK                ((DWORD   )0x40010008L)    
#define DBG_COMMAND_EXCEPTION            ((DWORD   )0x40010009L)    
#define STATUS_GUARD_PAGE_VIOLATION      ((DWORD   )0x80000001L)    
#define STATUS_DATATYPE_MISALIGNMENT     ((DWORD   )0x80000002L)    
#define STATUS_BREAKPOINT                ((DWORD   )0x80000003L)    
#define STATUS_SINGLE_STEP               ((DWORD   )0x80000004L)    
#define STATUS_LONGJUMP                  ((DWORD   )0x80000026L)    
#define STATUS_UNWIND_CONSOLIDATE        ((DWORD   )0x80000029L)    
#define DBG_EXCEPTION_NOT_HANDLED        ((DWORD   )0x80010001L)    
#define STATUS_ACCESS_VIOLATION          ((DWORD   )0xC0000005L)    
#define STATUS_IN_PAGE_ERROR             ((DWORD   )0xC0000006L)    
#define STATUS_INVALID_HANDLE            ((DWORD   )0xC0000008L)    
#define STATUS_INVALID_PARAMETER         ((DWORD   )0xC000000DL)    
#define STATUS_NO_MEMORY                 ((DWORD   )0xC0000017L)    
#define STATUS_ILLEGAL_INSTRUCTION       ((DWORD   )0xC000001DL)    
#define STATUS_NONCONTINUABLE_EXCEPTION  ((DWORD   )0xC0000025L)    
#define STATUS_INVALID_DISPOSITION       ((DWORD   )0xC0000026L)    
#define STATUS_ARRAY_BOUNDS_EXCEEDED     ((DWORD   )0xC000008CL)    
#define STATUS_FLOAT_DENORMAL_OPERAND    ((DWORD   )0xC000008DL)    
#define STATUS_FLOAT_DIVIDE_BY_ZERO      ((DWORD   )0xC000008EL)    
#define STATUS_FLOAT_INEXACT_RESULT      ((DWORD   )0xC000008FL)    
#define STATUS_FLOAT_INVALID_OPERATION   ((DWORD   )0xC0000090L)    
#define STATUS_FLOAT_OVERFLOW            ((DWORD   )0xC0000091L)    
#define STATUS_FLOAT_STACK_CHECK         ((DWORD   )0xC0000092L)    
#define STATUS_FLOAT_UNDERFLOW           ((DWORD   )0xC0000093L)    
#define STATUS_INTEGER_DIVIDE_BY_ZERO    ((DWORD   )0xC0000094L)    
#define STATUS_INTEGER_OVERFLOW          ((DWORD   )0xC0000095L)    
#define STATUS_PRIVILEGED_INSTRUCTION    ((DWORD   )0xC0000096L)    
#define STATUS_STACK_OVERFLOW            ((DWORD   )0xC00000FDL)    
#define STATUS_DLL_NOT_FOUND             ((DWORD   )0xC0000135L)    
#define STATUS_ORDINAL_NOT_FOUND         ((DWORD   )0xC0000138L)    
#define STATUS_ENTRYPOINT_NOT_FOUND      ((DWORD   )0xC0000139L)    
#define STATUS_CONTROL_C_EXIT            ((DWORD   )0xC000013AL)    
#define STATUS_DLL_INIT_FAILED           ((DWORD   )0xC0000142L)    
#define STATUS_FLOAT_MULTIPLE_FAULTS     ((DWORD   )0xC00002B4L)    
#define STATUS_FLOAT_MULTIPLE_TRAPS      ((DWORD   )0xC00002B5L)    
#define STATUS_REG_NAT_CONSUMPTION       ((DWORD   )0xC00002C9L)    
#define STATUS_STACK_BUFFER_OVERRUN      ((DWORD   )0xC0000409L)    
#define STATUS_INVALID_CRUNTIME_PARAMETER ((DWORD   )0xC0000417L)    
#define STATUS_ASSERTION_FAILURE         ((DWORD   )0xC0000420L)    

#define STATUS_SXS_EARLY_DEACTIVATION    ((DWORD   )0xC015000FL)    
#define STATUS_SXS_INVALID_DEACTIVATION  ((DWORD   )0xC0150010L)    

                    

#define MAXIMUM_WAIT_OBJECTS 64     // Maximum number of wait objects

#define MAXIMUM_SUSPEND_COUNT MAXCHAR // Maximum times thread can be suspended

typedef ULONG_PTR KSPIN_LOCK;
typedef KSPIN_LOCK *PKSPIN_LOCK;


//
// Define 128-bit 16-byte aligned xmm register type.
//

typedef struct  _M128A {
    ULONGLONG Low;
    LONGLONG High;
} M128A, *PM128A;

//
// Format of data for (F)XSAVE/(F)XRSTOR instruction
//

typedef struct  _XSAVE_FORMAT {
    WORD   ControlWord;
    WORD   StatusWord;
    BYTE  TagWord;
    BYTE  Reserved1;
    WORD   ErrorOpcode;
    DWORD ErrorOffset;
    WORD   ErrorSelector;
    WORD   Reserved2;
    DWORD DataOffset;
    WORD   DataSelector;
    WORD   Reserved3;
    DWORD MxCsr;
    DWORD MxCsr_Mask;
    M128A FloatRegisters[8];



    M128A XmmRegisters[16];
    BYTE  Reserved4[96];

















} XSAVE_FORMAT, *PXSAVE_FORMAT;

typedef struct  _XSAVE_AREA_HEADER {
    DWORD64 Mask;
    DWORD64 Reserved[7];
} XSAVE_AREA_HEADER, *PXSAVE_AREA_HEADER;

typedef struct  _XSAVE_AREA {
    XSAVE_FORMAT LegacyState;
    XSAVE_AREA_HEADER Header;
} XSAVE_AREA, *PXSAVE_AREA;

typedef struct _XSTATE_CONTEXT {
    DWORD64 Mask;
    DWORD Length;
    DWORD Reserved1;
     [OnFieldOnly] PXSAVE_AREA Area;


    DWORD Reserved2;


    PVOID Buffer;


    DWORD Reserved3;


} XSTATE_CONTEXT, *PXSTATE_CONTEXT;


#define XSAVE_ALIGN                 64
#define MINIMAL_XSTATE_AREA_LENGTH  sizeof(XSAVE_AREA)


//
// This structure specifies an offset (from the beginning of CONTEXT_EX
// structure) and size of a single chunk of an extended context structure.
//
// N.B. Offset may be negative.
//

typedef struct _CONTEXT_CHUNK {
    LONG Offset;
    DWORD Length;
} CONTEXT_CHUNK, *PCONTEXT_CHUNK;

//
// CONTEXT_EX structure is an extension to CONTEXT structure. It defines
// a context record as a set of disjoint variable-sized buffers (chunks)
// each containing a portion of processor state. Currently there are only
// two buffers (chunks) are defined:
//
//   - Legacy, that stores traditional CONTEXT structure;
//   - XState, that stores XSAVE save area buffer starting from
//     XSAVE_AREA_HEADER, i.e. without the first 512 bytes.
//
// There a few assumptions exists that simplify conversion of PCONTEXT
// pointer to PCONTEXT_EX pointer.
//
// 1. APIs that work with PCONTEXT pointers assume that CONTEXT_EX is
//    stored right after the CONTEXT structure. It is also assumed that
//    CONTEXT_EX is present if and only if corresponding CONTEXT_XXX
//    flags are set in CONTEXT.ContextFlags.
//
// 2. CONTEXT_EX.Legacy is always present if CONTEXT_EX structure is
//    present. All other chunks are optional.
//
// 3. CONTEXT.ContextFlags unambigiously define which chunks are
//    present. I.e. if CONTEXT_XSTATE is set CONTEXT_EX.XState is valid.
//

typedef struct _CONTEXT_EX {

    //
    // The total length of the structure starting from the chunk with
    // the smallest offset. N.B. that the offset may be negative.
    //

    CONTEXT_CHUNK All;

    //
    // Wrapper for the traditional CONTEXT structure. N.B. the size of
    // the chunk may be less than sizeof(CONTEXT) is some cases (when
    // CONTEXT_EXTENDED_REGISTERS is not set on x86 for instance).
    //

    CONTEXT_CHUNK Legacy;

    //
    // CONTEXT_XSTATE: Extended processor state chunk. The state is
    // stored in the same format XSAVE operation strores it with
    // exception of the first 512 bytes, i.e. staring from
    // XSAVE_AREA_HEADER. The lower two bits corresponding FP and
    // SSE state must be zero.
    //

    CONTEXT_CHUNK XState;

} CONTEXT_EX, *PCONTEXT_EX;

#define CONTEXT_EX_LENGTH   ALIGN_UP_BY(sizeof(CONTEXT_EX), STACK_ALIGN)

//
// These macros make context chunks manupulations easier.
//

#define RTL_CONTEXT_EX_OFFSET(ContextEx, Chunk)             ((ContextEx)->Chunk.Offset)


#define RTL_CONTEXT_EX_LENGTH(ContextEx, Chunk)             ((ContextEx)->Chunk.Length)


#define RTL_CONTEXT_EX_CHUNK(Base, Layout, Chunk)           ((PVOID)((PCHAR)(Base) + RTL_CONTEXT_EX_OFFSET(Layout, Chunk)))


#define RTL_CONTEXT_OFFSET(Context, Chunk)                  RTL_CONTEXT_EX_OFFSET((PCONTEXT_EX)(Context + 1), Chunk)


#define RTL_CONTEXT_LENGTH(Context, Chunk)                  RTL_CONTEXT_EX_LENGTH((PCONTEXT_EX)(Context + 1), Chunk)


#define RTL_CONTEXT_CHUNK(Context, Chunk)                   RTL_CONTEXT_EX_CHUNK((PCONTEXT_EX)(Context + 1),                             (PCONTEXT_EX)(Context + 1),                             Chunk)







//
// XSAVE/XRSTOR save area should be aligned on 64 byte boundary
//

;
;

// XSAVE_AREA structure must be sized uniformly on all architectures
;









//
// Define bit test intrinsics.
//


extern "C" {


#define BitTest _bittest
#define BitTestAndComplement _bittestandcomplement
#define BitTestAndSet _bittestandset
#define BitTestAndReset _bittestandreset
#define InterlockedBitTestAndSet _interlockedbittestandset
#define InterlockedBitTestAndReset _interlockedbittestandreset

#define BitTest64 _bittest64
#define BitTestAndComplement64 _bittestandcomplement64
#define BitTestAndSet64 _bittestandset64
#define BitTestAndReset64 _bittestandreset64
#define InterlockedBitTestAndSet64 _interlockedbittestandset64
#define InterlockedBitTestAndReset64 _interlockedbittestandreset64

             [method: OnFunctionOnly]
BOOLEAN
_bittest (
     [OnParameterOnly] LONG const *Base,
                                               [OnParameterOnly] LONG Offset
    );

BOOLEAN
_bittestandcomplement (
     [OnParameterOnly] LONG *Base,
                                               [OnParameterOnly] LONG Offset
    );

BOOLEAN
_bittestandset (
     [OnParameterOnly] LONG *Base,
                                               [OnParameterOnly] LONG Offset
    );

BOOLEAN
_bittestandreset (
     [OnParameterOnly] LONG *Base,
                                               [OnParameterOnly] LONG Offset
    );

BOOLEAN
_interlockedbittestandset (
     [OnParameterOnly]                   LONG volatile *Base,
                                               [OnParameterOnly] LONG Offset
    );

BOOLEAN
_interlockedbittestandreset (
     [OnParameterOnly]                   LONG volatile *Base,
                                               [OnParameterOnly] LONG Offset
    );

BOOLEAN
_bittest64 (
     [OnParameterOnly] LONG64 const *Base,
                                               [OnParameterOnly] LONG64 Offset
    );

BOOLEAN
_bittestandcomplement64 (
     [OnParameterOnly] LONG64 *Base,
                                               [OnParameterOnly] LONG64 Offset
    );

BOOLEAN
_bittestandset64 (
     [OnParameterOnly] LONG64 *Base,
                                               [OnParameterOnly] LONG64 Offset
    );

BOOLEAN
_bittestandreset64 (
     [OnParameterOnly] LONG64 *Base,
                                               [OnParameterOnly] LONG64 Offset
    );

BOOLEAN
_interlockedbittestandset64 (
     [OnParameterOnly]                   LONG64 volatile *Base,
                                               [OnParameterOnly] LONG64 Offset
    );

BOOLEAN
_interlockedbittestandreset64 (
     [OnParameterOnly]                   LONG64 volatile *Base,
                                               [OnParameterOnly] LONG64 Offset
    );















//
// Define bit scan intrinsics.
//

#define BitScanForward _BitScanForward
#define BitScanReverse _BitScanReverse
#define BitScanForward64 _BitScanForward64
#define BitScanReverse64 _BitScanReverse64

            
BOOLEAN
_BitScanForward (
                                              [OnParameterOnly] DWORD *Index,
                                               [OnParameterOnly] DWORD Mask
    );

            
BOOLEAN
_BitScanReverse (
                                              [OnParameterOnly] DWORD *Index,
                                               [OnParameterOnly] DWORD Mask
    );

            
BOOLEAN
_BitScanForward64 (
                                              [OnParameterOnly] DWORD *Index,
                                               [OnParameterOnly] DWORD64 Mask
    );

            
BOOLEAN
_BitScanReverse64 (
                                              [OnParameterOnly] DWORD *Index,
                                               [OnParameterOnly] DWORD64 Mask
    );






//
// Interlocked intrinsic functions.
//

#define InterlockedIncrement16 _InterlockedIncrement16
#define InterlockedDecrement16 _InterlockedDecrement16
#define InterlockedCompareExchange16 _InterlockedCompareExchange16

#define InterlockedAnd _InterlockedAnd
#define InterlockedAndAcquire _InterlockedAnd
#define InterlockedAndRelease _InterlockedAnd
#define InterlockedOr _InterlockedOr
#define InterlockedOrAcquire _InterlockedOr
#define InterlockedOrRelease _InterlockedOr
#define InterlockedXor _InterlockedXor
#define InterlockedIncrement _InterlockedIncrement
#define InterlockedIncrementAcquire InterlockedIncrement
#define InterlockedIncrementRelease InterlockedIncrement
#define InterlockedDecrement _InterlockedDecrement
#define InterlockedDecrementAcquire InterlockedDecrement
#define InterlockedDecrementRelease InterlockedDecrement
#define InterlockedAdd _InterlockedAdd
#define InterlockedExchange _InterlockedExchange
#define InterlockedExchangeAdd _InterlockedExchangeAdd
#define InterlockedCompareExchange _InterlockedCompareExchange
#define InterlockedCompareExchangeAcquire InterlockedCompareExchange
#define InterlockedCompareExchangeRelease InterlockedCompareExchange

#define InterlockedAnd64 _InterlockedAnd64
#define InterlockedAnd64Acquire _InterlockedAnd64
#define InterlockedAnd64Release _InterlockedAnd64
#define InterlockedAndAffinity InterlockedAnd64
#define InterlockedOr64 _InterlockedOr64
#define InterlockedOr64Acquire _InterlockedOr64
#define InterlockedOr64Release _InterlockedOr64
#define InterlockedOrAffinity InterlockedOr64
#define InterlockedXor64 _InterlockedXor64
#define InterlockedIncrement64 _InterlockedIncrement64
#define InterlockedDecrement64 _InterlockedDecrement64
#define InterlockedAdd64 _InterlockedAdd64
#define InterlockedExchange64 _InterlockedExchange64
#define InterlockedExchangeAcquire64 InterlockedExchange64
#define InterlockedExchangeAdd64 _InterlockedExchangeAdd64
#define InterlockedCompareExchange64 _InterlockedCompareExchange64
#define InterlockedCompareExchangeAcquire64 InterlockedCompareExchange64
#define InterlockedCompareExchangeRelease64 InterlockedCompareExchange64

#define InterlockedExchangePointer _InterlockedExchangePointer
#define InterlockedCompareExchangePointer _InterlockedCompareExchangePointer
#define InterlockedCompareExchangePointerAcquire _InterlockedCompareExchangePointer
#define InterlockedCompareExchangePointerRelease _InterlockedCompareExchangePointer

#define InterlockedExchangeAddSizeT(a, b) InterlockedExchangeAdd64((LONG64 *)a, b)
#define InterlockedIncrementSizeT(a) InterlockedIncrement64((LONG64 *)a)
#define InterlockedDecrementSizeT(a) InterlockedDecrement64((LONG64 *)a)

SHORT
 _InterlockedIncrement16 (
                                            [OnParameterOnly]                   SHORT volatile *Addend
    );

SHORT
 _InterlockedDecrement16 (
                                            [OnParameterOnly]                   SHORT volatile *Addend
    );

SHORT
 _InterlockedCompareExchange16 (
                                            [OnParameterOnly]                   SHORT volatile *Destination,
                                               [OnParameterOnly] SHORT ExChange,
                                               [OnParameterOnly] SHORT Comperand
    );

LONG
 _InterlockedAnd (
                                            [OnParameterOnly]                   LONG volatile *Destination,
                                               [OnParameterOnly] LONG Value
    );

LONG
 _InterlockedOr (
                                            [OnParameterOnly]                   LONG volatile *Destination,
                                               [OnParameterOnly] LONG Value
    );

LONG
 _InterlockedXor (
                                            [OnParameterOnly]                   LONG volatile *Destination,
                                               [OnParameterOnly] LONG Value
    );

LONG64
 _InterlockedAnd64 (
                                            [OnParameterOnly]                   LONG64 volatile *Destination,
                                               [OnParameterOnly] LONG64 Value
    );

LONG64
 _InterlockedOr64 (
                                            [OnParameterOnly]                   LONG64 volatile *Destination,
                                               [OnParameterOnly] LONG64 Value
    );

LONG64
 _InterlockedXor64 (
                                            [OnParameterOnly]                   LONG64 volatile *Destination,
                                               [OnParameterOnly] LONG64 Value
    );

LONG
 _InterlockedIncrement(
                                            [OnParameterOnly]                   LONG volatile *Addend
    );

LONG
 _InterlockedDecrement(
                                            [OnParameterOnly]                   LONG volatile *Addend
    );

LONG
 _InterlockedExchange(
                                            [OnParameterOnly]                   LONG volatile *Target,
                                               [OnParameterOnly] LONG Value
    );

LONG
 _InterlockedExchangeAdd(
                                            [OnParameterOnly]                   LONG volatile *Addend,
                                               [OnParameterOnly] LONG Value
    );




LONG
 _InterlockedAdd(
                                            [OnParameterOnly]                   LONG volatile *Addend,
                                               [OnParameterOnly] LONG Value
    )

{
    return  _InterlockedExchangeAdd(Addend, Value) + Value;
}



LONG
 _InterlockedCompareExchange (
                                            [OnParameterOnly]                   LONG volatile *Destination,
                                               [OnParameterOnly] LONG ExChange,
                                               [OnParameterOnly] LONG Comperand
    );

LONG64
 _InterlockedIncrement64(
                                            [OnParameterOnly]                   LONG64 volatile *Addend
    );

LONG64
 _InterlockedDecrement64(
                                            [OnParameterOnly]                   LONG64 volatile *Addend
    );

LONG64
 _InterlockedExchange64(
                                            [OnParameterOnly]                   LONG64 volatile *Target,
                                               [OnParameterOnly] LONG64 Value
    );

LONG64
 _InterlockedExchangeAdd64(
                                            [OnParameterOnly]                   LONG64 volatile *Addend,
                                               [OnParameterOnly] LONG64 Value
    );




LONG64
 _InterlockedAdd64(
                                            [OnParameterOnly]                   LONG64 volatile *Addend,
                                               [OnParameterOnly] LONG64 Value
    )

{
    return  _InterlockedExchangeAdd64(Addend, Value) + Value;
}



LONG64
 _InterlockedCompareExchange64 (
                                            [OnParameterOnly]                   LONG64 volatile *Destination,
                                               [OnParameterOnly] LONG64 ExChange,
                                               [OnParameterOnly] LONG64 Comperand
    );

PVOID
 _InterlockedCompareExchangePointer (
                                            [OnParameterOnly]                   PVOID volatile *Destination,
                                           [OnParameterOnly] PVOID Exchange,
                                           [OnParameterOnly] PVOID Comperand
    );

PVOID
 _InterlockedExchangePointer(
                                            [OnParameterOnly]                   PVOID volatile *Target,
                                           [OnParameterOnly] PVOID Value
    );

























#define InterlockedAnd8 _InterlockedAnd8
#define InterlockedOr8 _InterlockedOr8
#define InterlockedXor8 _InterlockedXor8
#define InterlockedAnd16 _InterlockedAnd16
#define InterlockedOr16 _InterlockedOr16
#define InterlockedXor16 _InterlockedXor16

char
 _InterlockedAnd8 (
                                            [OnParameterOnly]                   char volatile *Destination,
                                               [OnParameterOnly] char Value
    );

char
 _InterlockedOr8 (
                                            [OnParameterOnly]                   char volatile *Destination,
                                               [OnParameterOnly] char Value
    );

char
 _InterlockedXor8 (
                                            [OnParameterOnly]                   char volatile *Destination,
                                               [OnParameterOnly] char Value
    );

SHORT
 _InterlockedAnd16(
                                            [OnParameterOnly]                   SHORT volatile *Destination,
                                               [OnParameterOnly] SHORT Value
    );

SHORT
 _InterlockedOr16(
                                            [OnParameterOnly]                   SHORT volatile *Destination,
                                               [OnParameterOnly] SHORT Value
    );

SHORT
 _InterlockedXor16(
                                            [OnParameterOnly]                   SHORT volatile *Destination,
                                               [OnParameterOnly] SHORT Value
    );










//
// Define function to flush a cache line.
//

#define CacheLineFlush(Address) _mm_clflush(Address)

 void
_mm_clflush (
                                               [OnParameterOnly]  void const *Address
    );



 void
_ReadWriteBarrier (
     void
    );



//
// Define memory fence intrinsics
//

#define FastFence __faststorefence
#define LoadFence _mm_lfence
#define MemoryFence _mm_mfence
#define StoreFence _mm_sfence

 void
__faststorefence (
     void
    );

 void
_mm_lfence (
     void
    );

 void
_mm_mfence (
     void
    );

 void
_mm_sfence (
     void
    );

 void
_mm_pause (
     void
    );

 void
_mm_prefetch (
                                               [OnParameterOnly] CHAR                const *a,
                                               [OnParameterOnly] int sel
    );

 void
_m_prefetchw (
                                               [OnParameterOnly] volatile                const  void *Source
    );

//
// Define constants for use with _mm_prefetch.
//

#define _MM_HINT_T0     1
#define _MM_HINT_T1     2
#define _MM_HINT_T2     3
#define _MM_HINT_NTA    0









#define YieldProcessor _mm_pause
#define MemoryBarrier __faststorefence
#define PreFetchCacheLine(l, a)  _mm_prefetch((CHAR CONST *) a, l)
#define PrefetchForWrite(p) _m_prefetchw(p)
#define ReadForWriteAccess(p) (_m_prefetchw(p), *(p))

//
// PreFetchCacheLine level defines.
//

#define PF_TEMPORAL_LEVEL_1 _MM_HINT_T0
#define PF_TEMPORAL_LEVEL_2 _MM_HINT_T1
#define PF_TEMPORAL_LEVEL_3 _MM_HINT_T2
#define PF_NON_TEMPORAL_LEVEL_ALL _MM_HINT_NTA

//
// Define get/set MXCSR intrinsics.
//

#define ReadMxCsr _mm_getcsr
#define WriteMxCsr _mm_setcsr

unsigned int
_mm_getcsr (
     void
    );

 void
_mm_setcsr (
                                               [OnParameterOnly] unsigned int MxCsr
    );




//
// Assert exception.
//

 void
__int2c (
     void
    );




 __inline
 void
DbgRaiseAssertionFailure (
     void
    )

{
    __int2c();
}

//
// Define function to get the caller's EFLAGs value.
//

#define GetCallersEflags() __getcallerseflags()

unsigned __int32
__getcallerseflags (
     void
    );



//
// Define function to get segment limit.
//

#define GetSegmentLimit __segmentlimit

DWORD
__segmentlimit (
                                               [OnParameterOnly] DWORD Selector
    );



//
// Define function to read the value of a performance counter.
//

#define ReadPMC __readpmc

DWORD64
__readpmc (
                                               [OnParameterOnly] DWORD Counter
    );



//
// Define function to read the value of the time stamp counter
//

#define ReadTimeStampCounter() __rdtsc()

DWORD64
__rdtsc (
     void
    );



//
// Define functions to move strings as bytes, words, dwords, and qwords.
//

 void
__movsb (
     [OnParameterOnly] PBYTE  Destination,
     [OnParameterOnly] BYTE  const *Source,
                                               [OnParameterOnly] SIZE_T Count
    );

 void
__movsw (
     [OnParameterOnly] PWORD   Destination,
     [OnParameterOnly] WORD   const *Source,
                                               [OnParameterOnly] SIZE_T Count
    );

 void
__movsd (
     [OnParameterOnly] PDWORD Destination,
     [OnParameterOnly] DWORD const *Source,
                                               [OnParameterOnly] SIZE_T Count
    );

 void
__movsq (
     [OnParameterOnly] PDWORD64 Destination,
     [OnParameterOnly] DWORD64 const *Source,
                                               [OnParameterOnly] SIZE_T Count
    );






//
// Define functions to store strings as bytes, words, dwords, and qwords.
//

 void
__stosb (
     [OnParameterOnly] PBYTE  Destination,
                                               [OnParameterOnly] BYTE  Value,
                                               [OnParameterOnly] SIZE_T Count
    );

 void
__stosw (
     [OnParameterOnly] PWORD   Destination,
                                               [OnParameterOnly] WORD   Value,
                                               [OnParameterOnly] SIZE_T Count
    );

 void
__stosd (
     [OnParameterOnly] PDWORD Destination,
                                               [OnParameterOnly] DWORD Value,
                                               [OnParameterOnly] SIZE_T Count
    );

 void
__stosq (
     [OnParameterOnly] PDWORD64 Destination,
                                               [OnParameterOnly] DWORD64 Value,
                                               [OnParameterOnly] SIZE_T Count
    );






//
// Define functions to capture the high 64-bits of a 128-bit multiply.
//

#define MultiplyHigh __mulh
#define UnsignedMultiplyHigh __umulh

LONGLONG
 __mulh (
                                               [OnParameterOnly] LONG64 Multiplier,
                                               [OnParameterOnly] LONG64 Multiplicand
    );

ULONGLONG
 __umulh (
                                               [OnParameterOnly] DWORD64 Multiplier,
                                               [OnParameterOnly] DWORD64 Multiplicand
    );




//
// Define functions to perform 128-bit shifts
//

#define ShiftLeft128 __shiftleft128
#define ShiftRight128 __shiftright128

DWORD64
 __shiftleft128 (
                                               [OnParameterOnly] DWORD64 LowPart,
                                               [OnParameterOnly] DWORD64 HighPart,
                                               [OnParameterOnly] BYTE  Shift
    );

DWORD64
 __shiftright128 (
                                               [OnParameterOnly] DWORD64 LowPart,
                                               [OnParameterOnly] DWORD64 HighPart,
                                               [OnParameterOnly] BYTE  Shift
    );




//
// Define functions to perform 128-bit multiplies.
//

#define Multiply128 _mul128

LONG64
 _mul128 (
                                               [OnParameterOnly] LONG64 Multiplier,
                                               [OnParameterOnly] LONG64 Multiplicand,
                                              [OnParameterOnly] LONG64 *HighProduct
    );





#define UnsignedMultiply128 _umul128

DWORD64
 _umul128 (
                                               [OnParameterOnly] DWORD64 Multiplier,
                                               [OnParameterOnly] DWORD64 Multiplicand,
                                              [OnParameterOnly] DWORD64 *HighProduct
    );






LONG64
MultiplyExtract128 (
                                               [OnParameterOnly] LONG64 Multiplier,
                                               [OnParameterOnly] LONG64 Multiplicand,
                                               [OnParameterOnly] BYTE  Shift
    )

{

    LONG64 extractedProduct;
    LONG64 highProduct;
    LONG64 lowProduct;
    BOOLEAN negate;
    DWORD64 uhighProduct;
    DWORD64 ulowProduct;

    lowProduct =  _mul128(Multiplier, Multiplicand, &highProduct);
    negate =                0;
    uhighProduct = (DWORD64)highProduct;
    ulowProduct = (DWORD64)lowProduct;
    if (highProduct < 0) {
        negate =                 1;
        uhighProduct = (DWORD64)(-highProduct);
        ulowProduct = (DWORD64)(-lowProduct);
        if (ulowProduct != 0) {
            uhighProduct -= 1;
        }
    }

    extractedProduct = (LONG64) __shiftright128(ulowProduct, uhighProduct, Shift);
    if (negate !=                0) {
        extractedProduct = -extractedProduct;
    }

    return extractedProduct;
}


DWORD64
UnsignedMultiplyExtract128 (
                                               [OnParameterOnly] DWORD64 Multiplier,
                                               [OnParameterOnly] DWORD64 Multiplicand,
                                               [OnParameterOnly] BYTE  Shift
    )

{

    DWORD64 extractedProduct;
    DWORD64 highProduct;
    DWORD64 lowProduct;

    lowProduct =  _umul128(Multiplier, Multiplicand, &highProduct);
    extractedProduct =  __shiftright128(lowProduct, highProduct, Shift);
    return extractedProduct;
}

//
// Define functions to read and write the uer TEB and the system PCR/PRCB.
//

BYTE 
__readgsbyte (
                                               [OnParameterOnly] DWORD Offset
    );

WORD  
__readgsword (
                                               [OnParameterOnly] DWORD Offset
    );

DWORD
__readgsdword (
                                               [OnParameterOnly] DWORD Offset
    );

DWORD64
__readgsqword (
                                               [OnParameterOnly] DWORD Offset
    );

 void
__writegsbyte (
                                               [OnParameterOnly] DWORD Offset,
                                               [OnParameterOnly] BYTE  Data
    );

 void
__writegsword (
                                               [OnParameterOnly] DWORD Offset,
                                               [OnParameterOnly] WORD   Data
    );

 void
__writegsdword (
                                               [OnParameterOnly] DWORD Offset,
                                               [OnParameterOnly] DWORD Data
    );

 void
__writegsqword (
                                               [OnParameterOnly] DWORD Offset,
                                               [OnParameterOnly] DWORD64 Data
    );












 void
__incgsbyte (
                                               [OnParameterOnly] DWORD Offset
    );

 void
__addgsbyte (
                                               [OnParameterOnly] DWORD Offset,
                                               [OnParameterOnly] BYTE  Value
    );

 void
__incgsword (
                                               [OnParameterOnly] DWORD Offset
    );

 void
__addgsword (
                                               [OnParameterOnly] DWORD Offset,
                                               [OnParameterOnly] WORD   Value
    );

 void
__incgsdword (
                                               [OnParameterOnly] DWORD Offset
    );

 void
__addgsdword (
                                               [OnParameterOnly] DWORD Offset,
                                               [OnParameterOnly] DWORD Value
    );

 void
__incgsqword (
                                               [OnParameterOnly] DWORD Offset
    );

 void
__addgsqword (
                                               [OnParameterOnly] DWORD Offset,
                                               [OnParameterOnly] DWORD64 Value
    );















}




//
// The following values specify the type of access in the first parameter
// of the exception record whan the exception code specifies an access
// violation.
//

#define EXCEPTION_READ_FAULT 0          // exception caused by a read
#define EXCEPTION_WRITE_FAULT 1         // exception caused by a write
#define EXCEPTION_EXECUTE_FAULT 8       // exception caused by an instruction fetch

// begin_wx86
//
// The following flags control the contents of the CONTEXT structure.
//



#define CONTEXT_AMD64   0x100000

// end_wx86

#define CONTEXT_CONTROL (CONTEXT_AMD64 | 0x1L)
#define CONTEXT_INTEGER (CONTEXT_AMD64 | 0x2L)
#define CONTEXT_SEGMENTS (CONTEXT_AMD64 | 0x4L)
#define CONTEXT_FLOATING_POINT  (CONTEXT_AMD64 | 0x8L)
#define CONTEXT_DEBUG_REGISTERS (CONTEXT_AMD64 | 0x10L)

#define CONTEXT_FULL (CONTEXT_CONTROL | CONTEXT_INTEGER | CONTEXT_FLOATING_POINT)

#define CONTEXT_ALL (CONTEXT_CONTROL | CONTEXT_INTEGER | CONTEXT_SEGMENTS | CONTEXT_FLOATING_POINT | CONTEXT_DEBUG_REGISTERS)

#define CONTEXT_XSTATE (CONTEXT_AMD64 | 0x20L)

#define CONTEXT_EXCEPTION_ACTIVE 0x8000000
#define CONTEXT_SERVICE_ACTIVE 0x10000000
#define CONTEXT_EXCEPTION_REQUEST 0x40000000
#define CONTEXT_EXCEPTION_REPORTING 0x80000000

// begin_wx86



//
// Define initial MxCsr and FpCsr control.
//

#define INITIAL_MXCSR 0x1f80            // initial MXCSR value
#define INITIAL_FPCSR 0x027f            // initial FPCSR value

// end_ntddk
// begin_wdm begin_ntosp

typedef XSAVE_FORMAT XMM_SAVE_AREA32, *PXMM_SAVE_AREA32;

// end_wdm end_ntosp
// begin_ntddk

//
// Context Frame
//
//  This frame has a several purposes: 1) it is used as an argument to
//  NtContinue, 2) it is used to constuct a call frame for APC delivery,
//  and 3) it is used in the user level thread creation routines.
//
//
// The flags field within this record controls the contents of a CONTEXT
// record.
//
// If the context record is used as an input parameter, then for each
// portion of the context record controlled by a flag whose value is
// set, it is assumed that that portion of the context record contains
// valid context. If the context record is being used to modify a threads
// context, then only that portion of the threads context is modified.
//
// If the context record is used as an output parameter to capture the
// context of a thread, then only those portions of the thread's context
// corresponding to set flags will be returned.
//
// CONTEXT_CONTROL specifies SegSs, Rsp, SegCs, Rip, and EFlags.
//
// CONTEXT_INTEGER specifies Rax, Rcx, Rdx, Rbx, Rbp, Rsi, Rdi, and R8-R15.
//
// CONTEXT_SEGMENTS specifies SegDs, SegEs, SegFs, and SegGs.
//
// CONTEXT_FLOATING_POINT specifies Xmm0-Xmm15.
//
// CONTEXT_DEBUG_REGISTERS specifies Dr0-Dr3 and Dr6-Dr7.
//

typedef struct  _CONTEXT {

    //
    // Register parameter home addresses.
    //
    // N.B. These fields are for convience - they could be used to extend the
    //      context record in the future.
    //

    DWORD64 P1Home;
    DWORD64 P2Home;
    DWORD64 P3Home;
    DWORD64 P4Home;
    DWORD64 P5Home;
    DWORD64 P6Home;

    //
    // Control flags.
    //

    DWORD ContextFlags;
    DWORD MxCsr;

    //
    // Segment Registers and processor flags.
    //

    WORD   SegCs;
    WORD   SegDs;
    WORD   SegEs;
    WORD   SegFs;
    WORD   SegGs;
    WORD   SegSs;
    DWORD EFlags;

    //
    // Debug registers
    //

    DWORD64 Dr0;
    DWORD64 Dr1;
    DWORD64 Dr2;
    DWORD64 Dr3;
    DWORD64 Dr6;
    DWORD64 Dr7;

    //
    // Integer registers.
    //

    DWORD64 Rax;
    DWORD64 Rcx;
    DWORD64 Rdx;
    DWORD64 Rbx;
    DWORD64 Rsp;
    DWORD64 Rbp;
    DWORD64 Rsi;
    DWORD64 Rdi;
    DWORD64 R8;
    DWORD64 R9;
    DWORD64 R10;
    DWORD64 R11;
    DWORD64 R12;
    DWORD64 R13;
    DWORD64 R14;
    DWORD64 R15;

    //
    // Program counter.
    //

    DWORD64 Rip;

    //
    // Floating point state.
    //

    union {
        XMM_SAVE_AREA32 FltSave;
        struct {
            M128A Header[2];
            M128A Legacy[8];
            M128A Xmm0;
            M128A Xmm1;
            M128A Xmm2;
            M128A Xmm3;
            M128A Xmm4;
            M128A Xmm5;
            M128A Xmm6;
            M128A Xmm7;
            M128A Xmm8;
            M128A Xmm9;
            M128A Xmm10;
            M128A Xmm11;
            M128A Xmm12;
            M128A Xmm13;
            M128A Xmm14;
            M128A Xmm15;
        } ;
    } ;

    //
    // Vector registers.
    //

    M128A VectorRegister[26];
    DWORD64 VectorControl;

    //
    // Special debug control registers.
    //

    DWORD64 DebugControl;
    DWORD64 LastBranchToRip;
    DWORD64 LastBranchFromRip;
    DWORD64 LastExceptionToRip;
    DWORD64 LastExceptionFromRip;
} CONTEXT, *PCONTEXT;

//
// Define function table entry - a function table entry is generated for
// each frame function.
//

#define RUNTIME_FUNCTION_INDIRECT 0x1

typedef struct _RUNTIME_FUNCTION {
    DWORD BeginAddress;
    DWORD EndAddress;
    DWORD UnwindData;
} RUNTIME_FUNCTION, *PRUNTIME_FUNCTION;

//
// Define unwind history table structure.
//

#define UNWIND_HISTORY_TABLE_SIZE 12

typedef struct _UNWIND_HISTORY_TABLE_ENTRY {
    DWORD64 ImageBase;
    PRUNTIME_FUNCTION FunctionEntry;
} UNWIND_HISTORY_TABLE_ENTRY, *PUNWIND_HISTORY_TABLE_ENTRY;

typedef struct _UNWIND_HISTORY_TABLE {
    DWORD Count;
    BYTE  LocalHint;
    BYTE  GlobalHint;
    BYTE  Search;
    BYTE  Once;
    DWORD64 LowAddress;
    DWORD64 HighAddress;
    UNWIND_HISTORY_TABLE_ENTRY Entry[ 12];
} UNWIND_HISTORY_TABLE, *PUNWIND_HISTORY_TABLE;

//
// Define dynamic function table entry.
//

typedef
               
PRUNTIME_FUNCTION
GET_RUNTIME_FUNCTION_CALLBACK (
                                               [OnParameterOnly] DWORD64 ControlPc,
                                           [OnParameterOnly] PVOID Context
    );
typedef GET_RUNTIME_FUNCTION_CALLBACK *PGET_RUNTIME_FUNCTION_CALLBACK;

typedef
               
DWORD   
OUT_OF_PROCESS_FUNCTION_TABLE_CALLBACK (
                                               [OnParameterOnly] HANDLE Process,
                                               [OnParameterOnly] PVOID TableAddress,
                                              [OnParameterOnly] PDWORD Entries,
                                              [OnParameterOnly] PRUNTIME_FUNCTION* Functions
    );
typedef OUT_OF_PROCESS_FUNCTION_TABLE_CALLBACK *POUT_OF_PROCESS_FUNCTION_TABLE_CALLBACK;

#define OUT_OF_PROCESS_FUNCTION_TABLE_CALLBACK_EXPORT_NAME     "OutOfProcessFunctionTableCallback"


//
// Define runtime exception handling prototypes.
//


 void

RtlRestoreContext (
                                               [OnParameterOnly] PCONTEXT ContextRecord,
                                           [OnParameterOnly] struct _EXCEPTION_RECORD *ExceptionRecord
    );



BOOLEAN

RtlAddFunctionTable (
     [OnParameterOnly] PRUNTIME_FUNCTION FunctionTable,
                                               [OnParameterOnly] DWORD EntryCount,
                                               [OnParameterOnly] DWORD64 BaseAddress
    );


PRUNTIME_FUNCTION

RtlLookupFunctionEntry (
                                               [OnParameterOnly] DWORD64 ControlPc,
                                              [OnParameterOnly] PDWORD64 ImageBase,
                                        [OnParameterOnly] PUNWIND_HISTORY_TABLE HistoryTable
    );

//
// Nonvolatile context pointer record.
//

typedef struct _KNONVOLATILE_CONTEXT_POINTERS {
    union {
        PM128A FloatingContext[16];
        struct {
            PM128A Xmm0;
            PM128A Xmm1;
            PM128A Xmm2;
            PM128A Xmm3;
            PM128A Xmm4;
            PM128A Xmm5;
            PM128A Xmm6;
            PM128A Xmm7;
            PM128A Xmm8;
            PM128A Xmm9;
            PM128A Xmm10;
            PM128A Xmm11;
            PM128A Xmm12;
            PM128A Xmm13;
            PM128A Xmm14;
            PM128A Xmm15;
        } ;
    } ;

    union {
        PDWORD64 IntegerContext[16];
        struct {
            PDWORD64 Rax;
            PDWORD64 Rcx;
            PDWORD64 Rdx;
            PDWORD64 Rbx;
            PDWORD64 Rsp;
            PDWORD64 Rbp;
            PDWORD64 Rsi;
            PDWORD64 Rdi;
            PDWORD64 R8;
            PDWORD64 R9;
            PDWORD64 R10;
            PDWORD64 R11;
            PDWORD64 R12;
            PDWORD64 R13;
            PDWORD64 R14;
            PDWORD64 R15;
        } ;
    } ;

} KNONVOLATILE_CONTEXT_POINTERS, *PKNONVOLATILE_CONTEXT_POINTERS;


PEXCEPTION_ROUTINE

RtlVirtualUnwind (
                                               [OnParameterOnly] DWORD HandlerType,
                                               [OnParameterOnly] DWORD64 ImageBase,
                                               [OnParameterOnly] DWORD64 ControlPc,
                                               [OnParameterOnly] PRUNTIME_FUNCTION FunctionEntry,
                                            [OnParameterOnly] PCONTEXT ContextRecord,
                                              [OnParameterOnly] PVOID *HandlerData,
                                              [OnParameterOnly] PDWORD64 EstablisherFrame,
                                        [OnParameterOnly] PKNONVOLATILE_CONTEXT_POINTERS ContextPointers
    );


BOOLEAN

RtlInstallFunctionTableCallback (
                                               [OnParameterOnly] DWORD64 TableIdentifier,
                                               [OnParameterOnly] DWORD64 BaseAddress,
                                               [OnParameterOnly] DWORD Length,
                                               [OnParameterOnly] PGET_RUNTIME_FUNCTION_CALLBACK Callback,
                                           [OnParameterOnly] PVOID Context,
                                           [OnParameterOnly] PCWSTR OutOfProcessCallbackDll
    );


BOOLEAN

RtlDeleteFunctionTable (
                                               [OnParameterOnly] PRUNTIME_FUNCTION FunctionTable
    );






//
// Disable these two pragmas that evaluate to "sti" "cli" on x86 so that driver
// writers to not leave them inadvertantly in their code.
//








                                // build with /Od don't get weird errors !














// end_ntddk end_nthal



extern "C" {







//
// Define bit test intrinsics.
//

#define BitTest _bittest
#define BitTestAndComplement _bittestandcomplement
#define BitTestAndSet _bittestandset
#define BitTestAndReset _bittestandreset
#define InterlockedBitTestAndSet _interlockedbittestandset
#define InterlockedBitTestAndReset _interlockedbittestandreset

             [method: OnFunctionOnly]
BOOLEAN
_bittest (
     [OnParameterOnly] LONG const *Base,
                                               [OnParameterOnly] LONG Offset
    );

BOOLEAN
_bittestandcomplement (
     [OnParameterOnly] LONG *Base,
                                               [OnParameterOnly] LONG Offset
    );

BOOLEAN
_bittestandset (
     [OnParameterOnly] LONG *Base,
                                               [OnParameterOnly] LONG Offset
    );

BOOLEAN
_bittestandreset (
     [OnParameterOnly] LONG *Base,
                                               [OnParameterOnly] LONG Offset
    );

BOOLEAN
_interlockedbittestandset (
     [OnParameterOnly]                   LONG volatile *Base,
                                               [OnParameterOnly] LONG Offset
    );

BOOLEAN
_interlockedbittestandreset (
     [OnParameterOnly]                   LONG volatile *Base,
                                               [OnParameterOnly] LONG Offset
    );








//
// Define bit scan intrinsics.
//

#define BitScanForward _BitScanForward
#define BitScanReverse _BitScanReverse

            
BOOLEAN
_BitScanForward (
                                              [OnParameterOnly] DWORD *Index,
                                               [OnParameterOnly] DWORD Mask
    );

            
BOOLEAN
_BitScanReverse (
                                              [OnParameterOnly] DWORD *Index,
                                               [OnParameterOnly] DWORD Mask
    );










































//
// [pfx_parse] - guard against PREfix intrinsic error
//


#define InterlockedAnd16 _InterlockedAnd16
#define InterlockedCompareExchange16 _InterlockedCompareExchange16
#define InterlockedOr16 _InterlockedOr16

SHORT
_InterlockedAnd16 (
                                            [OnParameterOnly]                   SHORT volatile *Destination,
                                               [OnParameterOnly] SHORT Value
    );

SHORT
_InterlockedCompareExchange16 (
                                            [OnParameterOnly]                   SHORT volatile *Destination,
                                               [OnParameterOnly] SHORT ExChange,
                                               [OnParameterOnly] SHORT Comperand
    );

SHORT
_InterlockedOr16 (
                                            [OnParameterOnly]                   SHORT volatile *Destination,
                                               [OnParameterOnly] SHORT Value
    );











 __inline
BOOLEAN
InterlockedBitTestAndComplement (
     [OnParameterOnly]                   LONG volatile *Base,
                                               [OnParameterOnly] LONG Bit
    )
{
    __asm {
           mov eax, Bit
           mov ecx, Base
           lock btc [ecx], eax
           setc al
    };
}



//
// [pfx_parse]
// guard against __readfsbyte parsing error
//


//
// Define FS referencing intrinsics
//

BYTE 
__readfsbyte (
                                               [OnParameterOnly] DWORD Offset
    );

WORD  
__readfsword (
                                               [OnParameterOnly] DWORD Offset
    );

DWORD
__readfsdword (
                                               [OnParameterOnly] DWORD Offset
    );

 void
__writefsbyte (
                                               [OnParameterOnly] DWORD Offset,
                                               [OnParameterOnly] BYTE  Data
    );

 void
__writefsword (
                                               [OnParameterOnly] DWORD Offset,
                                               [OnParameterOnly] WORD   Data
    );

 void
__writefsdword (
                                               [OnParameterOnly] DWORD Offset,
                                               [OnParameterOnly] DWORD Data
    );














 void
__incfsbyte (
                                               [OnParameterOnly] DWORD Offset
    );

 void
__addfsbyte (
                                               [OnParameterOnly] DWORD Offset,
                                               [OnParameterOnly] BYTE  Value
    );

 void
__incfsword (
                                               [OnParameterOnly] DWORD Offset
    );

 void
__addfsword (
                                               [OnParameterOnly] DWORD Offset,
                                               [OnParameterOnly] WORD   Value
    );

 void
__incfsdword (
                                               [OnParameterOnly] DWORD Offset
    );

 void
__addfsdword (
                                               [OnParameterOnly] DWORD Offset,
                                               [OnParameterOnly] DWORD Value
    );














 void
_mm_pause (
     void
    );



#define YieldProcessor _mm_pause




#define YieldProcessor() __asm { rep nop }





}










 __inline
 void
 __faststorefence (
     void
    )
{
    LONG Barrier;
    __asm {
        xchg Barrier, eax
    }
}



//
// Prefetch is not supported on all x86 procssors.
//

#define PreFetchCacheLine(l, a)
#define PrefetchForWrite(p)
#define ReadForWriteAccess(p) (*(p))

//
// PreFetchCacheLine level defines.
//

#define PF_TEMPORAL_LEVEL_1
#define PF_NON_TEMPORAL_LEVEL_ALL

//
// Define function to read the value of a performance counter.
//



#define ReadPMC __readpmc

DWORD64
__readpmc (
                                               [OnParameterOnly] DWORD Counter
    );




















//
// Define function to read the value of the time stamp counter
//



#define ReadTimeStampCounter() __rdtsc()

DWORD64
__rdtsc (
     void
    );

















// end_ntddk
// begin_wdm





 void
__int2c (
     void
    );




 __inline
 void
DbgRaiseAssertionFailure (
     void
    )

{
    __int2c();
}






















// end_wdm



__inline PVOID GetFiberData( void )    { return *(PVOID *) (ULONG_PTR) __readfsdword (0x10);}
__inline PVOID GetCurrentFiber( void ) { return (PVOID) (ULONG_PTR) __readfsdword (0x10);}




















// begin_ntddk

// end_ntddk

//
// The following values specify the type of failing access when the status is
// STATUS_ACCESS_VIOLATION and the first parameter in the execpetion record.
//

#define EXCEPTION_READ_FAULT          0 // Access violation was caused by a read
#define EXCEPTION_WRITE_FAULT         1 // Access violation was caused by a write
#define EXCEPTION_EXECUTE_FAULT       8 // Access violation was caused by an instruction fetch

// begin_wx86
// begin_ntddk

//
//  Define the size of the 80387 save area, which is in the context frame.
//

#define SIZE_OF_80387_REGISTERS      80

//
// The following flags control the contents of the CONTEXT structure.
//



#define CONTEXT_i386    0x00010000    // this assumes that i386 and
#define CONTEXT_i486    0x00010000    // i486 have identical context records

// end_wx86

#define CONTEXT_CONTROL         (CONTEXT_i386 | 0x00000001L) // SS:SP, CS:IP, FLAGS, BP
#define CONTEXT_INTEGER         (CONTEXT_i386 | 0x00000002L) // AX, BX, CX, DX, SI, DI
#define CONTEXT_SEGMENTS        (CONTEXT_i386 | 0x00000004L) // DS, ES, FS, GS
#define CONTEXT_FLOATING_POINT  (CONTEXT_i386 | 0x00000008L) // 387 state
#define CONTEXT_DEBUG_REGISTERS (CONTEXT_i386 | 0x00000010L) // DB 0-3,6,7
#define CONTEXT_EXTENDED_REGISTERS  (CONTEXT_i386 | 0x00000020L) // cpu specific extensions

#define CONTEXT_FULL (CONTEXT_CONTROL | CONTEXT_INTEGER |                      CONTEXT_SEGMENTS)


#define CONTEXT_ALL             (CONTEXT_CONTROL | CONTEXT_INTEGER | CONTEXT_SEGMENTS |                                  CONTEXT_FLOATING_POINT | CONTEXT_DEBUG_REGISTERS |                                  CONTEXT_EXTENDED_REGISTERS)



#define CONTEXT_XSTATE          (CONTEXT_i386 | 0x00000040L)

// begin_wx86



typedef struct _FLOATING_SAVE_AREA {
    DWORD   ControlWord;
    DWORD   StatusWord;
    DWORD   TagWord;
    DWORD   ErrorOffset;
    DWORD   ErrorSelector;
    DWORD   DataOffset;
    DWORD   DataSelector;
    BYTE    RegisterArea[      80];
    DWORD   Cr0NpxState;
} FLOATING_SAVE_AREA;

typedef FLOATING_SAVE_AREA *PFLOATING_SAVE_AREA;


// end_ntddk
// begin_wdm begin_ntosp

#define MAXIMUM_SUPPORTED_EXTENSION     512



;



// end_wdm end_ntosp
// begin_ntddk



//
// Context Frame
//
//  This frame has a several purposes: 1) it is used as an argument to
//  NtContinue, 2) is is used to constuct a call frame for APC delivery,
//  and 3) it is used in the user level thread creation routines.
//
//  The layout of the record conforms to a standard call frame.
//

typedef struct _CONTEXT {

    //
    // The flags values within this flag control the contents of
    // a CONTEXT record.
    //
    // If the context record is used as an input parameter, then
    // for each portion of the context record controlled by a flag
    // whose value is set, it is assumed that that portion of the
    // context record contains valid context. If the context record
    // is being used to modify a threads context, then only that
    // portion of the threads context will be modified.
    //
    // If the context record is used as an IN OUT parameter to capture
    // the context of a thread, then only those portions of the thread's
    // context corresponding to set flags will be returned.
    //
    // The context record is never used as an OUT only parameter.
    //

    DWORD ContextFlags;

    //
    // This section is specified/returned if CONTEXT_DEBUG_REGISTERS is
    // set in ContextFlags.  Note that CONTEXT_DEBUG_REGISTERS is NOT
    // included in CONTEXT_FULL.
    //

    DWORD   Dr0;
    DWORD   Dr1;
    DWORD   Dr2;
    DWORD   Dr3;
    DWORD   Dr6;
    DWORD   Dr7;

    //
    // This section is specified/returned if the
    // ContextFlags word contians the flag CONTEXT_FLOATING_POINT.
    //

    FLOATING_SAVE_AREA FloatSave;

    //
    // This section is specified/returned if the
    // ContextFlags word contians the flag CONTEXT_SEGMENTS.
    //

    DWORD   SegGs;
    DWORD   SegFs;
    DWORD   SegEs;
    DWORD   SegDs;

    //
    // This section is specified/returned if the
    // ContextFlags word contians the flag CONTEXT_INTEGER.
    //

    DWORD   Edi;
    DWORD   Esi;
    DWORD   Ebx;
    DWORD   Edx;
    DWORD   Ecx;
    DWORD   Eax;

    //
    // This section is specified/returned if the
    // ContextFlags word contians the flag CONTEXT_CONTROL.
    //

    DWORD   Ebp;
    DWORD   Eip;
    DWORD   SegCs;              // MUST BE SANITIZED
    DWORD   EFlags;             // MUST BE SANITIZED
    DWORD   Esp;
    DWORD   SegSs;

    //
    // This section is specified/returned if the ContextFlags word
    // contains the flag CONTEXT_EXTENDED_REGISTERS.
    // The format and contexts are processor specific
    //

    BYTE    ExtendedRegisters[     512];

} CONTEXT;

typedef CONTEXT *PCONTEXT;



// begin_ntminiport




#define _LDT_ENTRY_DEFINED

typedef struct _LDT_ENTRY {
    WORD    LimitLow;
    WORD    BaseLow;
    union {
        struct {
            BYTE    BaseMid;
            BYTE    Flags1;     // Declare as bytes to avoid alignment
            BYTE    Flags2;     // Problems.
            BYTE    BaseHi;
        } Bytes;
        struct {
            DWORD   BaseMid : 8;
            DWORD   Type : 5;
            DWORD   Dpl : 2;
            DWORD   Pres : 1;
            DWORD   LimitHi : 4;
            DWORD   Sys : 1;
            DWORD   Reserved_0 : 1;
            DWORD   Default_Big : 1;
            DWORD   Granularity : 1;
            DWORD   BaseHi : 8;
        } Bits;
    } HighWord;
} LDT_ENTRY, *PLDT_ENTRY;







extern "C" {


//
// Define bit test intrinsics.
//

#define BitTest _bittest
#define BitTestAndComplement _bittestandcomplement
#define BitTestAndSet _bittestandset
#define BitTestAndReset _bittestandreset

#define BitTest64 _bittest64
#define BitTestAndComplement64 _bittestandcomplement64
#define BitTestAndSet64 _bittestandset64
#define BitTestAndReset64 _bittestandreset64

             [method: OnFunctionOnly]
BOOLEAN
_bittest (
     [OnParameterOnly] LONG const *Base,
                                               [OnParameterOnly] LONG Offset
    );

BOOLEAN
_bittestandcomplement (
     [OnParameterOnly] LONG *Base,
                                               [OnParameterOnly] LONG Offset
    );

BOOLEAN
_bittestandset (
     [OnParameterOnly] LONG *Base,
                                               [OnParameterOnly] LONG Offset
    );

BOOLEAN
_bittestandreset (
     [OnParameterOnly] LONG *Base,
                                               [OnParameterOnly] LONG Offset
    );

             [method: OnFunctionOnly]
BOOLEAN
_bittest64 (
     [OnParameterOnly] LONG64 const *Base,
                                               [OnParameterOnly] LONG64 Offset
    );

BOOLEAN
_bittestandcomplement64 (
     [OnParameterOnly] LONG64 *Base,
                                               [OnParameterOnly] LONG64 Offset
    );

BOOLEAN
_bittestandset64 (
     [OnParameterOnly] LONG64 *Base,
                                               [OnParameterOnly] LONG64 Offset
    );

BOOLEAN
_bittestandreset64 (
     [OnParameterOnly] LONG64 *Base,
                                               [OnParameterOnly] LONG64 Offset
    );











//
// Define bit scan intrinsics.
//

#define BitScanForward _BitScanForward
#define BitScanReverse _BitScanReverse
#define BitScanForward64 _BitScanForward64
#define BitScanReverse64 _BitScanReverse64

            
BOOLEAN
_BitScanForward (
                                              [OnParameterOnly] DWORD *Index,
                                               [OnParameterOnly] DWORD Mask
    );

            
BOOLEAN
_BitScanReverse (
                                              [OnParameterOnly] DWORD *Index,
                                               [OnParameterOnly] DWORD Mask
    );

            
BOOLEAN
_BitScanForward64 (
                                              [OnParameterOnly] DWORD *Index,
                                               [OnParameterOnly] DWORD64 Mask
    );

            
BOOLEAN
_BitScanReverse64 (
                                              [OnParameterOnly] DWORD *Index,
                                               [OnParameterOnly] DWORD64 Mask
    );






#define InterlockedCompareExchange16 _InterlockedCompareExchange16

SHORT
_InterlockedCompareExchange16 (
                                            [OnParameterOnly]                   SHORT volatile *Destination,
                                               [OnParameterOnly] SHORT ExChange,
                                               [OnParameterOnly] SHORT Comperand
    );




}


#define InterlockedAdd                  _InterlockedAdd
#define InterlockedAddAcquire           _InterlockedAdd_acq
#define InterlockedAddRelease           _InterlockedAdd_rel

#define InterlockedIncrement            _InterlockedIncrement
#define InterlockedIncrementAcquire     _InterlockedIncrement_acq
#define InterlockedIncrementRelease     _InterlockedIncrement_rel

#define InterlockedDecrement            _InterlockedDecrement
#define InterlockedDecrementAcquire     _InterlockedDecrement_acq
#define InterlockedDecrementRelease     _InterlockedDecrement_rel

#define InterlockedExchange             _InterlockedExchange
#define InterlockedExchangeAcquire      _InterlockedExchange_acq

#define InterlockedExchangeAdd          _InterlockedExchangeAdd
#define InterlockedExchangeAddAcquire   _InterlockedExchangeAdd_acq
#define InterlockedExchangeAddRelease   _InterlockedExchangeAdd_rel

#define InterlockedAdd64                _InterlockedAdd64
#define InterlockedAddAcquire64         _InterlockedAdd64_acq
#define InterlockedAddRelease64         _InterlockedAdd64_rel

#define InterlockedIncrement64          _InterlockedIncrement64
#define InterlockedIncrementAcquire64   _InterlockedIncrement64_acq
#define InterlockedIncrementRelease64   _InterlockedIncrement64_rel

#define InterlockedDecrement64          _InterlockedDecrement64
#define InterlockedDecrementAcquire64   _InterlockedDecrement64_acq
#define InterlockedDecrementRelease64   _InterlockedDecrement64_rel

#define InterlockedExchange64           _InterlockedExchange64
#define InterlockedExchangeAcquire64    _InterlockedExchange64_acq

#define InterlockedExchangeAdd64        _InterlockedExchangeAdd64
#define InterlockedExchangeAddAcquire64 _InterlockedExchangeAdd64_acq
#define InterlockedExchangeAddRelease64 _InterlockedExchangeAdd64_rel

#define InterlockedCompareExchange64        _InterlockedCompareExchange64
#define InterlockedCompareExchangeAcquire64 _InterlockedCompareExchange64_acq
#define InterlockedCompareExchangeRelease64 _InterlockedCompareExchange64_rel

#define InterlockedCompare64Exchange128         _InterlockedCompare64Exchange128
#define InterlockedCompare64ExchangeAcquire128  _InterlockedCompare64Exchange128_acq
#define InterlockedCompare64ExchangeRelease128  _InterlockedCompare64Exchange128_rel

#define InterlockedCompareExchange          _InterlockedCompareExchange
#define InterlockedCompareExchangeAcquire   _InterlockedCompareExchange_acq
#define InterlockedCompareExchangeRelease   _InterlockedCompareExchange_rel

#define InterlockedExchangePointer          _InterlockedExchangePointer
#define InterlockedExchangePointerAcquire   _InterlockedExchangePointer_acq

#define InterlockedCompareExchangePointer           _InterlockedCompareExchangePointer
#define InterlockedCompareExchangePointerRelease    _InterlockedCompareExchangePointer_rel
#define InterlockedCompareExchangePointerAcquire    _InterlockedCompareExchangePointer_acq


#define InterlockedExchangeAddSizeT(a, b) InterlockedExchangeAdd64((LONG64 *)a, b)
#define InterlockedIncrementSizeT(a) InterlockedIncrement64((LONG64 *)a)
#define InterlockedDecrementSizeT(a) InterlockedDecrement64((LONG64 *)a)

#define InterlockedOr       _InterlockedOr
#define InterlockedOrAcquire   _InterlockedOr_acq
#define InterlockedOrRelease   _InterlockedOr_rel
#define InterlockedOr8      _InterlockedOr8
#define InterlockedOr8Acquire  _InterlockedOr8_acq
#define InterlockedOr8Release  _InterlockedOr8_rel
#define InterlockedOr16     _InterlockedOr16
#define InterlockedOr16Acquire _InterlockedOr16_acq
#define InterlockedOr16Release _InterlockedOr16_rel
#define InterlockedOr64     _InterlockedOr64
#define InterlockedOr64Acquire _InterlockedOr64_acq
#define InterlockedOr64Release _InterlockedOr64_rel
#define InterlockedXor      _InterlockedXor
#define InterlockedXorAcquire  _InterlockedXor_acq
#define InterlockedXorRelease  _InterlockedXor_rel
#define InterlockedXor8     _InterlockedXor8
#define InterlockedXor8Acquire _InterlockedXor8_acq
#define InterlockedXor8Release _InterlockedXor8_rel
#define InterlockedXor16    _InterlockedXor16
#define InterlockedXor16Acquire _InterlockedXor16_acq
#define InterlockedXor16Release _InterlockedXor16_rel
#define InterlockedXor64     _InterlockedXor64
#define InterlockedXor64Acquire _InterlockedXor64_acq
#define InterlockedXor64Release _InterlockedXor64_rel
#define InterlockedAnd       _InterlockedAnd
#define InterlockedAndAcquire   _InterlockedAnd_acq
#define InterlockedAndRelease   _InterlockedAnd_rel
#define InterlockedAnd8      _InterlockedAnd8
#define InterlockedAnd8Acquire  _InterlockedAnd8_acq
#define InterlockedAnd8Release  _InterlockedAnd8_rel
#define InterlockedAnd16     _InterlockedAnd16
#define InterlockedAnd16Acquire _InterlockedAnd16_acq
#define InterlockedAnd16Release _InterlockedAnd16_rel
#define InterlockedAnd64     _InterlockedAnd64
#define InterlockedAnd64Acquire _InterlockedAnd64_acq
#define InterlockedAnd64Release _InterlockedAnd64_rel


extern "C" {


LONG

                  _InterlockedAdd (
                                            [OnParameterOnly]                   LONG volatile *Addend,
                                               [OnParameterOnly] LONG Value
    );

LONG

           _InterlockedAdd_acq (
                                            [OnParameterOnly]                   LONG volatile *Addend,
                                               [OnParameterOnly] LONG Value
    );

LONG

           _InterlockedAdd_rel (
                                            [OnParameterOnly]                   LONG volatile *Addend,
                                               [OnParameterOnly] LONG Value
    );

LONGLONG

                _InterlockedAdd64 (
                                            [OnParameterOnly]                   LONGLONG volatile *Addend,
                                               [OnParameterOnly] LONGLONG Value
    );

LONGLONG

         _InterlockedAdd64_acq (
                                            [OnParameterOnly]                   LONGLONG volatile *Addend,
                                               [OnParameterOnly] LONGLONG Value
    );


LONGLONG

         _InterlockedAdd64_rel (
                                            [OnParameterOnly]                   LONGLONG volatile *Addend,
                                               [OnParameterOnly] LONGLONG Value
    );

LONG

            _InterlockedIncrement(
                                            [OnParameterOnly]                   LONG volatile *Addend
    );

LONG

            _InterlockedDecrement(
                                            [OnParameterOnly]                   LONG volatile *Addend
    );

LONG

     _InterlockedIncrement_acq(
                                            [OnParameterOnly]                   LONG volatile *Addend
    );

LONG

     _InterlockedDecrement_acq(
                                            [OnParameterOnly]                   LONG volatile *Addend
    );

LONG

     _InterlockedIncrement_rel(
                                            [OnParameterOnly]                   LONG volatile *Addend
    );

LONG

     _InterlockedDecrement_rel(
                                            [OnParameterOnly]                   LONG volatile *Addend
    );

LONG

             _InterlockedExchange(
                                            [OnParameterOnly]                   LONG volatile *Target,
                                               [OnParameterOnly] LONG Value
    );

LONG

      _InterlockedExchange_acq(
                                            [OnParameterOnly]                   LONG volatile *Target,
                                               [OnParameterOnly] LONG Value
    );

LONG

          _InterlockedExchangeAdd(
                                            [OnParameterOnly]                   LONG volatile *Addend,
                                               [OnParameterOnly] LONG Value
    );

LONG

   _InterlockedExchangeAdd_acq(
                                            [OnParameterOnly]                   LONG volatile *Addend,
                                               [OnParameterOnly] LONG Value
    );

LONG

   _InterlockedExchangeAdd_rel(
                                            [OnParameterOnly]                   LONG volatile *Addend,
                                               [OnParameterOnly] LONG Value
    );

LONG

          _InterlockedCompareExchange (
                                            [OnParameterOnly]                   LONG volatile *Destination,
                                               [OnParameterOnly] LONG ExChange,
                                               [OnParameterOnly] LONG Comperand
    );


LONG

   _InterlockedCompareExchange_rel (
                                            [OnParameterOnly]                   LONG volatile *Destination,
                                               [OnParameterOnly] LONG ExChange,
                                               [OnParameterOnly] LONG Comperand
    );


LONG

   _InterlockedCompareExchange_acq (
                                            [OnParameterOnly]                   LONG volatile *Destination,
                                               [OnParameterOnly] LONG ExChange,
                                               [OnParameterOnly] LONG Comperand
    );


LONGLONG

          _InterlockedIncrement64(
                                            [OnParameterOnly]                   LONGLONG volatile *Addend
    );

LONGLONG

   _InterlockedIncrement64_acq(
                                            [OnParameterOnly]                   LONGLONG volatile *Addend
    );

LONGLONG

   _InterlockedIncrement64_rel(
                                            [OnParameterOnly]                   LONGLONG volatile *Addend
    );

LONGLONG

          _InterlockedDecrement64(
                                            [OnParameterOnly]                   LONGLONG volatile *Addend
    );

LONGLONG

   _InterlockedDecrement64_acq(
                                            [OnParameterOnly]                   LONGLONG volatile *Addend
    );

LONGLONG

   _InterlockedDecrement64_rel(
                                            [OnParameterOnly]                   LONGLONG volatile *Addend
    );

LONGLONG

           _InterlockedExchange64(
                                            [OnParameterOnly]                   LONGLONG volatile *Target,
                                               [OnParameterOnly] LONGLONG Value
    );

LONGLONG

    _InterlockedExchange64_acq(
                                            [OnParameterOnly]                   LONGLONG volatile *Target,
                                               [OnParameterOnly] LONGLONG Value
    );

LONGLONG

        _InterlockedExchangeAdd64(
                                            [OnParameterOnly]                   LONGLONG volatile *Addend,
                                               [OnParameterOnly] LONGLONG Value
    );

LONGLONG

 _InterlockedExchangeAdd64_acq(
                                            [OnParameterOnly]                   LONGLONG volatile *Addend,
                                               [OnParameterOnly] LONGLONG Value
    );

LONGLONG

 _InterlockedExchangeAdd64_rel(
                                            [OnParameterOnly]                   LONGLONG volatile *Addend,
                                               [OnParameterOnly] LONGLONG Value
    );

LONGLONG

        _InterlockedCompareExchange64 (
                                            [OnParameterOnly]                   LONGLONG volatile *Destination,
                                               [OnParameterOnly] LONGLONG ExChange,
                                               [OnParameterOnly] LONGLONG Comperand
    );

LONGLONG

 _InterlockedCompareExchange64_acq (
                                            [OnParameterOnly]                   LONGLONG volatile *Destination,
                                               [OnParameterOnly] LONGLONG ExChange,
                                               [OnParameterOnly] LONGLONG Comperand
    );

LONGLONG

 _InterlockedCompareExchange64_rel (
                                            [OnParameterOnly]                   LONGLONG volatile *Destination,
                                               [OnParameterOnly] LONGLONG ExChange,
                                               [OnParameterOnly] LONGLONG Comperand
    );

LONG64

         _InterlockedCompare64Exchange128(
     [OnParameterOnly]                   LONG64 volatile *Destination,
                                               [OnParameterOnly] LONG64 ExchangeHigh,
                                               [OnParameterOnly] LONG64 ExchangeLow,
                                               [OnParameterOnly] LONG64 Comperand
    );

LONG64

  _InterlockedCompare64Exchange128_acq(
     [OnParameterOnly]                   LONG64 volatile *Destination,
                                               [OnParameterOnly] LONG64 ExchangeHigh,
                                               [OnParameterOnly] LONG64 ExchangeLow,
                                               [OnParameterOnly] LONG64 Comperand
    );

LONG64

  _InterlockedCompare64Exchange128_rel(
     [OnParameterOnly]                   LONG64 volatile *Destination,
                                               [OnParameterOnly] LONG64 ExchangeHigh,
                                               [OnParameterOnly] LONG64 ExchangeLow,
                                               [OnParameterOnly] LONG64 Comperand
    );

PVOID

           _InterlockedCompareExchangePointer (
                                            [OnParameterOnly]                   PVOID volatile *Destination,
                                               [OnParameterOnly] PVOID Exchange,
                                               [OnParameterOnly] PVOID Comperand
    );

PVOID

    _InterlockedCompareExchangePointer_acq (
                                            [OnParameterOnly]                   PVOID volatile *Destination,
                                               [OnParameterOnly] PVOID Exchange,
                                               [OnParameterOnly] PVOID Comperand
    );

PVOID

    _InterlockedCompareExchangePointer_rel (
                                            [OnParameterOnly]                   PVOID volatile *Destination,
                                               [OnParameterOnly] PVOID Exchange,
                                               [OnParameterOnly] PVOID Comperand
    );

PVOID

          _InterlockedExchangePointer(
                                            [OnParameterOnly]                   PVOID volatile *Target,
                                               [OnParameterOnly] PVOID Value
    );

PVOID

   _InterlockedExchangePointer_acq(
                                            [OnParameterOnly]                   PVOID volatile *Target,
                                               [OnParameterOnly] PVOID Value
    );

LONG

       _InterlockedOr (
                                            [OnParameterOnly]                   LONG volatile *Destination,
                                               [OnParameterOnly] LONG Value
    );

LONG

   _InterlockedOr_acq (
                                            [OnParameterOnly]                   LONG volatile *Destination,
                                               [OnParameterOnly] LONG Value
    );

LONG

   _InterlockedOr_rel (
                                            [OnParameterOnly]                   LONG volatile *Destination,
                                               [OnParameterOnly] LONG Value
    );

CHAR

      _InterlockedOr8 (
                                            [OnParameterOnly]                   CHAR volatile *Destination,
                                               [OnParameterOnly] CHAR Value
    );

CHAR

  _InterlockedOr8_acq (
                                            [OnParameterOnly]                   CHAR volatile *Destination,
                                               [OnParameterOnly] CHAR Value
    );

CHAR

  _InterlockedOr8_rel (
                                            [OnParameterOnly]                   CHAR volatile *Destination,
                                               [OnParameterOnly] CHAR Value
    );

SHORT

     _InterlockedOr16(
                                            [OnParameterOnly]                   SHORT volatile *Destination,
                                               [OnParameterOnly] SHORT Value
    );

SHORT

 _InterlockedOr16_acq (
                                            [OnParameterOnly]                   SHORT volatile *Destination,
                                               [OnParameterOnly] SHORT Value
    );

SHORT

 _InterlockedOr16_rel (
                                            [OnParameterOnly]                   SHORT volatile *Destination,
                                               [OnParameterOnly] SHORT Value
    );

LONGLONG

     _InterlockedOr64 (
                                            [OnParameterOnly]                   LONGLONG volatile *Destination,
                                               [OnParameterOnly] LONGLONG Value
    );

LONGLONG

 _InterlockedOr64_acq (
                                            [OnParameterOnly]                   LONGLONG volatile *Destination,
                                               [OnParameterOnly] LONGLONG Value
    );

LONGLONG

 _InterlockedOr64_rel (
                                            [OnParameterOnly]                   LONGLONG volatile *Destination,
                                               [OnParameterOnly] LONGLONG Value
    );

LONG

      _InterlockedXor (
                                            [OnParameterOnly]                   LONG volatile *Destination,
                                               [OnParameterOnly] LONG Value
    );

LONG

  _InterlockedXor_acq (
                                            [OnParameterOnly]                   LONG volatile *Destination,
                                               [OnParameterOnly] LONG Value
    );

LONG

  _InterlockedXor_rel (
                                            [OnParameterOnly]                   LONG volatile *Destination,
                                               [OnParameterOnly] LONG Value
    );

CHAR

     _InterlockedXor8 (
                                            [OnParameterOnly]                   CHAR volatile *Destination,
                                               [OnParameterOnly] CHAR Value
    );

CHAR

 _InterlockedXor8_acq (
                                            [OnParameterOnly]                   CHAR volatile *Destination,
                                               [OnParameterOnly] CHAR Value
    );

CHAR

 _InterlockedXor8_rel (
                                            [OnParameterOnly]                   CHAR volatile *Destination,
                                               [OnParameterOnly] CHAR Value
    );

SHORT

    _InterlockedXor16(
                                            [OnParameterOnly]                   SHORT volatile *Destination,
                                               [OnParameterOnly] SHORT Value
    );

SHORT

 _InterlockedXor16_acq (
                                            [OnParameterOnly]                   SHORT volatile *Destination,
                                               [OnParameterOnly] SHORT Value
    );

SHORT

 _InterlockedXor16_rel (
                                            [OnParameterOnly]                   SHORT volatile *Destination,
                                               [OnParameterOnly] SHORT Value
    );

LONGLONG

     _InterlockedXor64 (
                                            [OnParameterOnly]                   LONGLONG volatile *Destination,
                                               [OnParameterOnly] LONGLONG Value
    );

LONGLONG

 _InterlockedXor64_acq (
                                            [OnParameterOnly]                   LONGLONG volatile *Destination,
                                               [OnParameterOnly] LONGLONG Value
    );

LONGLONG

 _InterlockedXor64_rel (
                                            [OnParameterOnly]                   LONGLONG volatile *Destination,
                                               [OnParameterOnly] LONGLONG Value
    );

LONG

       _InterlockedAnd (
                                            [OnParameterOnly]                   LONG volatile *Destination,
                                               [OnParameterOnly] LONG Value
    );

LONG

   _InterlockedAnd_acq (
                                            [OnParameterOnly]                   LONG volatile *Destination,
                                               [OnParameterOnly] LONG Value
    );

LONG

   _InterlockedAnd_rel (
                                            [OnParameterOnly]                   LONG volatile *Destination,
                                               [OnParameterOnly] LONG Value
    );

CHAR

      _InterlockedAnd8 (
                                            [OnParameterOnly]                   CHAR volatile *Destination,
                                               [OnParameterOnly] CHAR Value
    );

CHAR

  _InterlockedAnd8_acq (
                                            [OnParameterOnly]                   CHAR volatile *Destination,
                                               [OnParameterOnly] CHAR Value
    );

CHAR

  _InterlockedAnd8_rel (
                                            [OnParameterOnly]                   CHAR volatile *Destination,
                                               [OnParameterOnly] CHAR Value
    );

SHORT

     _InterlockedAnd16(
                                            [OnParameterOnly]                   SHORT volatile *Destination,
                                               [OnParameterOnly] SHORT Value
    );

SHORT

 _InterlockedAnd16_acq (
                                            [OnParameterOnly]                   SHORT volatile *Destination,
                                               [OnParameterOnly] SHORT Value
    );

SHORT

 _InterlockedAnd16_rel (
                                            [OnParameterOnly]                   SHORT volatile *Destination,
                                               [OnParameterOnly] SHORT Value
    );

LONGLONG

     _InterlockedAnd64 (
                                            [OnParameterOnly]                   LONGLONG volatile *Destination,
                                               [OnParameterOnly] LONGLONG Value
    );

LONGLONG

 _InterlockedAnd64_acq (
                                            [OnParameterOnly]                   LONGLONG volatile *Destination,
                                               [OnParameterOnly] LONGLONG Value
    );

LONGLONG

 _InterlockedAnd64_rel (
                                            [OnParameterOnly]                   LONGLONG volatile *Destination,
                                               [OnParameterOnly] LONGLONG Value
    );


















































































#define InterlockedAnd64 InterlockedAnd64_Inline

LONGLONG
 __inline
InterlockedAnd64_Inline (
                                            [OnParameterOnly]                   LONGLONG volatile *Destination,
                                               [OnParameterOnly] LONGLONG Value
    )
{
    LONGLONG Old;

    do {
        Old = *Destination;
    } while (        _InterlockedCompareExchange64(Destination,
                                          Old & Value,
                                          Old) != Old);

    return Old;
}

