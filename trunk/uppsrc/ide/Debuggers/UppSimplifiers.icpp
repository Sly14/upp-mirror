#include "TypeSimplify.h"

#define EVALDEEP
#define EVALDEEP_VECTOR		5
#define EVALDEEP_ARRAY		5
#define EVALDEEP_VECTORMAP	5
#define EVALDEEP_ARRAYMAP	5
#define EVALDEEP_INDEX		5

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SIMPLIFIERS MUST BE CODED AS STATE MACHINES -- THEY'LL BE CALLED MANY TIMES, WITH A 'step' PARAMETER
// STEP = 0 MEANS BASE SIMPLIFY AND CHECK IF MORE STEPS ARE NEEDED
//          RETURN NEXT STEP, OR 0 IF NONE
// STEP = N MEANS A SIMPLIFY STEP
//          RETURN NEXT STEP, OR 0 IF NONE
// THEY MUST CHANGE 'value' MEMBER OF PASSED VarItem object ON EACH STEP
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#define SLEN 15
#define LLEN 2
static int UppStringSimplify(VarItem &varItem, int step)
{
	union
	{
		char chr[16];
		char  *ptr;
		dword *wptr;
		qword *qptr;
		word   v[8];
		dword  w[4];
		qword  q[2];
	} u;
	
	// see Upp::String code for how it works....
	MIValue val = varItem.EvaluateExpression("(" + varItem.evaluableExpression + ")." + "chr");
	if(!val.IsString())
		return 0;
	String chrs = val.ToString();
	memcpy(u.chr, ~chrs, 16);

	bool isSmall = (u.chr[14] == 0);
	String s;
	if(isSmall)
	{
		byte len = u.chr[SLEN];
		s = chrs.Left(len);
	}
	else
	{
		dword len = u.w[LLEN];
		MIValue val = varItem.EvaluateExpression("(" + varItem.evaluableExpression + ").ptr[0]@" + FormatInt(len));
		if(!val.IsString())
			return 0;
		s = val.ToString();
	}
	varItem.value = "\"" + s + "\"";
	varItem.kind = VarItem::SIMPLE;
	return 0;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
static int UppVectorSimplify(VarItem &varItem, int step)
{
	const char *placeHolder = " = [...]";
	
	// setup item type
	varItem.kind = VarItem::ARRAY;
	
	// if we're just doing first scan phase, signal that we need further evaluation later
#ifdef EVALDEEP
	if(!step)
		// next step is 1
		return 1;
#else
	varItem.value = placeHolder;
	return 0;
#endif
	
	// just getting items count...
	if(step == 1)
	{
		// initialize default value
		varItem.value = "<can't evaluate>";
		
		// get items count
		MIValue val = varItem.EvaluateExpression(varItem.evaluableExpression + ".items");
		if(val.IsError() || !val.IsString())
			return 0;
		varItem.items = atoi(val.ToString());
		
		// update value
		varItem.value = Format("Upp::Vector with %d elements", varItem.items, "");
		
		// if no elements, just quit
		if(!varItem.items)
			return 0;
		return 2;
	}
	
	int count = min(EVALDEEP_VECTOR, varItem.items);
	
	// start from item 0
	step -= 2;
	
	if(!step)
		varItem.value << " = [ ]";
	
	// fetch elements, check on first if they're SIMPLE, so displayable
	VarItem vItem(&varItem.Debugger(), varItem.evaluableExpression + Format(".vector[%d]", step));
	if(!vItem)
	{
		varItem.value = " <can't evaluate contents>";
		return 0;
	}
	if(vItem.kind != VarItem::SIMPLE)
	{
		varItem.value = placeHolder;
		return 0;
	}
	vItem.Simplify();
	const char *sep = step ? " , " : "";
	varItem.value = varItem.value.Left(varItem.value.GetCount() - 2) + sep + vItem.value + " ]";
	if(++step >= count)
		return 0;
	else
		return step + 2;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
static int UppVectorMapSimplify(VarItem &varItem, int step)
{
	const char *placeHolder = " = {...}";
	
	// setup item type
	varItem.kind = VarItem::MAP;
	
	// if we're just doing first scan phase, signal that we need further evaluation later
	// if we're just doing first scan phase, signal that we need further evaluation later
#ifdef EVALDEEP
	if(!step)
		// next step is 1
		return 1;
#else
	varItem.value = placeHolder;
	return 0;
#endif
	
	// just getting items count...
	if(step == 1)
	{
		// initialize default value
		varItem.value = "<can't evaluate>";
		
		// get items count
		MIValue val = varItem.EvaluateExpression(varItem.evaluableExpression + ".key.key.items");
		if(val.IsError() || !val.IsString())
			return 0;
		varItem.items = atoi(val.ToString());
		
		// update value
		varItem.value = Format("Upp::VectorMap with %d elements", varItem.items, "");
		
		// if no elements, just quit
		if(!varItem.items)
			return 0;
		return 2;
	}
	
	int count = min(EVALDEEP_VECTORMAP, varItem.items);
	
	// start from item 0
	step -= 2;
	
	if(!step)
		varItem.value << " = { }";
	
	// fetch elements, check on first if they're SIMPLE, so displayable
	VarItem kItem(&varItem.Debugger(), varItem.evaluableExpression + Format(".key.key.vector[%d]", step));
	if(!kItem)
	{
		varItem.value = " <can't evaluate contents>";
		return 0;
	}
	// for complex types, just return placeholder
	if(kItem.kind != VarItem::SIMPLE)
	{
		varItem.value = placeHolder;
		return 0;
	}
	kItem.Simplify();

	VarItem vItem(&varItem.Debugger(), varItem.evaluableExpression + Format(".value.vector[%d]", step));
	if(!vItem)
	{
		varItem.value = " <can't evaluate contents>";
		return 0;
	}
	// for complex types, just return placeholder
	if(vItem.kind != VarItem::SIMPLE)
	{
		varItem.value = placeHolder;
		return true;
	}
	vItem.Simplify();
	
	const char *sep = step ? " , " : "";
	varItem.value = varItem.value.Left(varItem.value.GetCount() - 2) + sep + "(" + kItem.value + " , " + vItem.value + ") }";
	if(++step >= count)
		return 0;
	else
		return step + 2;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
static int UppArraySimplify(VarItem &varItem, int step)
{
	const char *placeHolder = " = [...]";
	
	// setup item type
	varItem.kind = VarItem::ARRAY;
	
	// if we're just doing first scan phase, signal that we need further evaluation later
#ifdef EVALDEEP
	if(!step)
		// next step is 1
		return 1;
#else
	varItem.value = placeHolder;
	return 0;
#endif
	
	// just getting items count...
	if(step == 1)
	{
		// initialize default value
		varItem.value = "<can't evaluate>";
		
		// get items count
		MIValue val = varItem.EvaluateExpression(varItem.evaluableExpression + ".vector.items");
		if(val.IsError() || !val.IsString())
			return 0;
		varItem.items = atoi(val.ToString());
		
		// update value
		varItem.value = Format("Upp::Array with %d elements", varItem.items, "");
		
		// if no elements, just quit
		if(!varItem.items)
			return 0;
		return 2;
	}
	
	int count = min(EVALDEEP_VECTOR, varItem.items);
	
	// start from item 0
	step -= 2;
	
	if(!step)
		varItem.value << " = [ ]";
	
	// fetch elements, check on first if they're SIMPLE, so displayable
	VarItem vItem(&varItem.Debugger(), varItem.evaluableExpression + Format(".vector.vector[%d][0]", step));
	if(!vItem)
	{
		varItem.value = " <can't evaluate contents>";
		return 0;
	}
	if(vItem.kind != VarItem::SIMPLE)
	{
		varItem.value = placeHolder;
		return 0;
	}
	vItem.Simplify();
	const char *sep = step ? " , " : "";
	varItem.value = varItem.value.Left(varItem.value.GetCount() - 2) + sep + vItem.value + " ]";
	if(++step >= count)
		return 0;
	else
		return step + 2;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
static int UppArrayMapSimplify(VarItem &varItem, int step)
{
	const char *placeHolder = " = {...}";
	
	// setup item type
	varItem.kind = VarItem::MAP;
	
	// if we're just doing first scan phase, signal that we need further evaluation later
	// if we're just doing first scan phase, signal that we need further evaluation later
#ifdef EVALDEEP
	if(!step)
		// next step is 1
		return 1;
#else
	varItem.value = placeHolder;
	return 0;
#endif
	
	// just getting items count...
	if(step == 1)
	{
		// initialize default value
		varItem.value = "<can't evaluate>";
		
		// get items count
		MIValue val = varItem.EvaluateExpression(varItem.evaluableExpression + ".key.key.items");
		if(val.IsError() || !val.IsString())
			return 0;
		varItem.items = atoi(val.ToString());
		
		// update value
		varItem.value = Format("Upp::ArrayMap with %d elements", varItem.items, "");
		
		// if no elements, just quit
		if(!varItem.items)
			return 0;
		return 2;
	}
	
	int count = min(EVALDEEP_VECTORMAP, varItem.items);
	
	// start from item 0
	step -= 2;
	
	if(!step)
		varItem.value << " = { }";
	
	// fetch elements, check on first if they're SIMPLE, so displayable
	VarItem kItem(&varItem.Debugger(), varItem.evaluableExpression + Format(".key.key.vector[%d]", step));
	if(!kItem)
	{
		varItem.value = " <can't evaluate contents>";
		return 0;
	}
	// for complex types, just return placeholder
	if(kItem.kind != VarItem::SIMPLE)
	{
		varItem.value = placeHolder;
		return 0;
	}
	kItem.Simplify();

	VarItem vItem(&varItem.Debugger(), varItem.evaluableExpression + Format(".value.vector.vector[%d][0]", step));
	if(!vItem)
	{
		varItem.value = " <can't evaluate contents>";
		return 0;
	}
	// for complex types, just return placeholder
	if(vItem.kind != VarItem::SIMPLE)
	{
		varItem.value = placeHolder;
		return true;
	}
	vItem.Simplify();
	
	const char *sep = step ? " , " : "";
	varItem.value = varItem.value.Left(varItem.value.GetCount() - 2) + sep + "(" + kItem.value + " , " + vItem.value + ") }";
	if(++step >= count)
		return 0;
	else
		return step + 2;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
static int UppIndexSimplify(VarItem &varItem, int step)
{
	const char *placeHolder = " = [...]";
	
	// setup item type
	varItem.kind = VarItem::ARRAY;
	
	// if we're just doing first scan phase, signal that we need further evaluation later
#ifdef EVALDEEP
	if(!step)
		// next step is 1
		return 1;
#else
	varItem.value = placeHolder;
	return 0;
#endif
	
	// just getting items count...
	if(step == 1)
	{
		// initialize default value
		varItem.value = "<can't evaluate>";
		
		// get items count
		MIValue val = varItem.EvaluateExpression(varItem.evaluableExpression + ".key.items");
		if(val.IsError() || !val.IsString())
			return 0;
		varItem.items = atoi(val.ToString());
		
		// update value
		varItem.value = Format("Upp::Index with %d elements", varItem.items, "");
		
		// if no elements, just quit
		if(!varItem.items)
			return 0;
		return 2;
	}
	
	int count = min(EVALDEEP_VECTOR, varItem.items);
	
	// start from item 0
	step -= 2;
	
	if(!step)
		varItem.value << " = [ ]";
	
	// fetch elements, check on first if they're SIMPLE, so displayable
	VarItem vItem(&varItem.Debugger(), varItem.evaluableExpression + Format(".key.vector[%d]", step));
	if(!vItem)
	{
		varItem.value = " <can't evaluate contents>";
		return 0;
	}
	if(vItem.kind != VarItem::SIMPLE)
	{
		varItem.value = placeHolder;
		return 0;
	}
	vItem.Simplify();
	const char *sep = step ? " , " : "";
	varItem.value = varItem.value.Left(varItem.value.GetCount() - 2) + sep + vItem.value + " ]";
	if(++step >= count)
		return 0;
	else
		return step + 2;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
static int UppOneSimplify(VarItem &varItem, int step)
{
	// setup item type
	varItem.kind = VarItem::COMPLEX;
	
	// if we're just doing first scan phase, signal that we need further evaluation later
#ifdef EVALDEEP
	if(!step)
		// next step is 1
		return 1;
#else
	varItem.value = placeHolder;
	return 0;
#endif

	// de-reference and forward simplify
	MIValue val = varItem.EvaluateExpression(varItem.evaluableExpression + "." + "ptr");
	if(val.IsError() || !val.IsString())
	{
		varItem.value = "Upp::One<> = <can't evaluate contents>";
		return 0;
	}
	String ptr = val.ToString();
	if(ptr == "0x0")
	{
		varItem.value = "Upp::One<> = <EMPTY>";
		return 0;
	}
	
	// replace variable with de-referenced one
	VarItem vItem(&varItem.Debugger(), "*" + varItem.evaluableExpression + "." + "ptr");
	varItem = vItem;
	return varItem.GetSimplifyStep();
}

// Register the simplifiers
REGISTERSIMPLIFIER("Upp::String"				, UppStringSimplify);
REGISTERSIMPLIFIER("Upp::Vector<"				, UppVectorSimplify);
REGISTERSIMPLIFIER("Upp::VectorMap<"			, UppVectorMapSimplify);
REGISTERSIMPLIFIER("Upp::Array<"				, UppArraySimplify);
REGISTERSIMPLIFIER("Upp::ArrayMap<"				, UppArrayMapSimplify);
REGISTERSIMPLIFIER("Upp::Index<"				, UppIndexSimplify);
REGISTERSIMPLIFIER("Upp::One<"					, UppOneSimplify);
