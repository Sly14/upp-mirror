TITLE("HeaderCtrl")
REF("::HeaderCtrl::class")
REF("::HeaderCtrl::Tab(int)const")
REF("::HeaderCtrl::Tab(int)")
REF("::HeaderCtrl::Add(const char*,double)")
REF("::HeaderCtrl::Add()")
REF("::HeaderCtrl::operator[](int)const")
REF("::HeaderCtrl::GetCount()const")
REF("::HeaderCtrl::Reset()")
REF("::HeaderCtrl::ShowTab(int,bool)")
REF("::HeaderCtrl::HideTab(int)")
REF("::HeaderCtrl::IsTabVisible(int)")
REF("::HeaderCtrl::SetTabRatio(int,double)")
REF("::HeaderCtrl::GetTabRatio(int)const")
REF("::HeaderCtrl::SetTabWidth(int,int)")
REF("::HeaderCtrl::GetTabWidth(int)")
REF("::HeaderCtrl::StartSplitDrag(int)")
REF("::HeaderCtrl::GetSplit(int)")
REF("::HeaderCtrl::GetScroll()const")
REF("::HeaderCtrl::IsScroll()const")
REF("::HeaderCtrl::GetHeight()const")
REF("::HeaderCtrl::Invisible(bool)")
REF("::HeaderCtrl::Track(bool)")
REF("::HeaderCtrl::NoTrack()")
REF("::HeaderCtrl::Proportional()")
REF("::HeaderCtrl::ReduceNext()")
REF("::HeaderCtrl::ReduceLast()")
REF("::HeaderCtrl::Absolute()")
REF("::HeaderCtrl::GetStdHeight()")
REF("::HeaderCtrl::WhenLayout")
REF("::HeaderCtrl::WhenScroll")
REF("::HeaderCtrl::WhenScrollVisibility")
REF("::HeaderCtrl::Column::Min(int)")
REF("::HeaderCtrl::Column::Max(int)")
REF("::HeaderCtrl::Column::MinMax(int,int)")
REF("::HeaderCtrl::Column::Fixed(int)")
REF("::HeaderCtrl::Column::SetRatio(double)")
REF("::HeaderCtrl::Column::SetMargin(int)")
REF("::HeaderCtrl::Column::GetMargin()const")
REF("::HeaderCtrl::Column::WhenAction")
TOPIC_TEXT(
"[2 $$0,0#00000000000000000000000000000000:Default][l288;i1120;a17;O9;~~~.1408;2 "
"$$1,0#10431211400427159095818037425705:param][a83;*R6 $$2,5#31310162474203024125188417583966:caption][b83;*4 "
"$$3,5#07864147445237544204411237157677:title][i288;O9;C2 $$4,6#40027414424643823182269349404212:item][b42;a42;2 "
"$$5,5#45413000475342174754091244180557:text][l288;b17;a17;2 $$6,6#27521748481378242620020725143825:")
TOPIC_TEXT(
"desc][l321;t246;C@5;1 $$7,7#20902679421464641399138805415013:code][b2503; $$8,0#65142375456100023862071332075487:separator][*@(0.0.255)2 "
"$$9,0#83433469410354161042741608181528:base][t4167;C $$10,0#37138531426314131251341829483380:class][l288;a17;*1 "
"$$11,11#70004532496200323422659154056402:requirement][i417;b42;a42;O9;~~~.416;2 $$12,12#10566046415157235020018451313112:tparam][b167;C2 "
"$$13,13#924304")
TOPIC_TEXT(
"59443460461911108080531343:item1][i288;a42;O9;C2 $$14,14#77422149456609303542238260500223:item2][*@2$(0.128.128) "
"$$15,15#34511555403152284025741354420178:NewsDate][l321;*C$7;2 $$16,16#03451589433145915344929335295360:result][l321;b83;a83;*C$7;2 "
"$$17,17#07531550463529505371228428965313:result`-line][l160;t4167;*C+117 $$18,5#88603949442205825958800053222425:package`-title][ "
"$$19,0#535800234423355290")
TOPIC_TEXT(
"39900623488521:gap][t4167;C2 $$20,20#70211524482531209251820423858195:class`-nested][b50;2 "
"$$21,21#03324558446220344731010354752573:Par][{_}%EN-US [s2;:`:`:HeaderCtrl`:`:class: "
"HeaderCtrl&][s0; &][s10;* [* class_]HeaderCtrl&][s6; &][s6; @@PNG:1350&150\201\211\320\316\307\215\212\232\200\212\200\200\200\215\311\310\240\304\322\200\200\200\330\200\200\200\200\230\210\202\200\200\214\200\227\252\244\216\200\200\202\201\275\311\304\301\324\370\257\234\355\230\275\322\303\260\252\214\307\205\327\307\350\335\204\307\272\366\370\216\206\326\203\216\241\253\223\253\233\243\220\203\243\233\357\300\233\260\300\263\201\243\203\253\207\217\360\200\207\327\236\201\301\234\212\317\221\310\354\206\307\322\266\342\375\206\266\376\212\245\375\373\357\331\361\316\347\373\264\253\270\216\266\273\332\206\250\270\216\200\300\254\374\335\337\336\274\350\332")
TOPIC_TEXT(
"\341\324\313\303\305\311\276\304\241\202\300\317\365\371\221\236\261\316\245\235\234\335\335\206\207\231\251\303\370\372\370\223\267\306\231\277\207\373\307\343\365\251\273\323\256\322\373\314\372\231\321\312\261\201\213\321\261\201\335\315\232\271\363\305\212\247\333\355\256\373\346\213\325\301\233\356\240\362\266\262\257\317\267\374\201\247\353\271\347\342\216\237\207\361\307\277\305\273\315\304\213\261\364\252\254\205\322\203\251\212\210\324\234\267\202\200\361\331\340\204\374\353\366\256\314\220\216\210\355\304\200\352\236\227\213\317\241\371\335\211\225\303\216\211\303\344\273\222\240\255\342\251\357\364\240\331\270\341\271\256\215\235\201\366\355\241\277\220\361\270\223\226\215\224\333\315\212\360\205\374\256\265\334\266\355\244\310\355\353\353\355\241\311\327\344\252\315\372\277\362\353\251\300\230\304\254\302\234\302\355\275\204\267\270\323\345\307\306\205\345\371\321\355\251\304\262\356\253\213\230\262\334\227\231\260\200\223\360\301\236\253\237\253\223\361\234\347\274\234\204\213\304\263\227\214\361\337\314\321\374\263\242\376\251\230\216\203\214\205\251\302\315\311\216\271\272\240\342\251\347\255\264\240\264\247\327\234\351\307\310\361\221\221\253\304\276\246\333\335\224\265\245\233\203\223\240\376\306\240\311\356\246\345\311\276\366\266\307\265\361\321\346\321\215\240\367\272\375\277\326\252\316\304\362\236\250\266\244\204\356\270\231\231\233\336\360\263\214\303\303\210\317\317\367\332\364\366\250\262\334\356\271\343\346\252\275\343\344\303\210\233\267\315\267\254\261\216\363\313\212\303\210\207\207\353\255\273\267\234\312\261\362\217\350\324\225\216\213\321\261")
TOPIC_TEXT(
"\301\217\315\215\315\321\317\223\325\262\337\200\200\200\200\200\311\305\316\222\304\256\302\340\202&][s6; "
"&][s9; [/ Derived from] Ctrl[@0 , ]CtrlFrame&][s0; &][s0; HeaderCtrl is used mainly "
"for table headers. It can be set up to a certain column structure (in the code terminology, "
"the individual header columns are called [/ tabs]) including the tabs`' visual characteristics "
"(tab title names, icons etc.) and behavioral constraints (tab width limits, the ability "
"to show /")
TOPIC_TEXT(
" hide individual tabs).&][s0; &][s0; The individual tab widths are defined by three "
"basic properties: the [/ logical tab width], its [/ minimum] and [/ maximum pixel "
"width]. The minimum and maximum tab width are final pixel values defining constraints "
"for physical (final) column widths. On the other hand, the logical tab widths are "
"given in arbitrary units, which are multiplied by a certain scalin")
TOPIC_TEXT(
"g factor whenever the header control is laid out to fit the view size. Therefore "
"normally their absolute magnitudes don`'t matter, just their ratios.&][s0; &][s0; "
"The header control can operate in four different visual modes. Each mode effectively "
"defines how the logical relative tab widths are fitted to the current view size:&][s0; "
"&][s0;i150;O0; [* Proportional]: the tab widths are proportionall")
TOPIC_TEXT(
"y adjusted with respect to preset width constraints to fill the current view width;&][s0;i150;O0; "
"[* ReduceLast]: every time a tab width is set and the total tab width exceeds the "
"view size, the following tab widths (tabs to the right) are reduced in right`-to`-left "
"order (beginning with the rightmost tab) to fit the view size.&][s0;i150;O0; [* ReduceNext]: "
"every time a tab width is set and the to")
TOPIC_TEXT(
"tal tab width exceeds the view size, the following tab widths (tabs to the right) "
"are reduced in left`-to`-right order (beginning with the tab just after the tab being "
"adjusted) to fit the view size.&][s0;i150;O0; [* Absolute]: the tab widths are never "
"modified automatically, the logical header width can be smaller or greater than the "
"actual view size. Whenever the total tab width exceeds the view")
TOPIC_TEXT(
" size, the header can be scrolled to the left or right to pan its visible portion "
"within the parent view.&][s0; &][s0; From the programmer`'s point of view, the HeaderCtrl "
"takes complete control over the distribution of tabs and the user interface needed "
"to adjust them. The host control can use the header control (typically during [/ "
"Layout] or [/ Paint]) to obtain horizontal pixel positions of th")
TOPIC_TEXT(
"e individual tab breaks and use them to position and paint the column data.&][s0; "
"&][s0; The HeaderCtrl implements the [/ frame interface]; when attached to a parent "
"control using the [/ AddFrame] method, it positions itself automatically at the top "
"of the control rectangle (above its view).&][s0; &][s0; In addition to the standard "
"tab title functionality, the rectangular areas corresponding to th")
TOPIC_TEXT(
"e individual tabs can act as pseudo`-buttons invoking a certain functionality when "
"clicked. Each header tab has a [/ WhenAction] callback; when set to a non`-null value, "
"the header control starts to check for mouse clicks and executes the callback whenever "
"the corresponding tab is clicked. When used to invoke popups, you can use the [/ "
"GetTabRect] method to determine the actual location of a certa")
TOPIC_TEXT(
"in header tab and align the dropdown control with respect to the tab rectangle location.&][s4; "
"Rect_[* GetTabRect](int_[*@3 i])&][s6; Returns the bounding box of a certain tab "
"(in coordinates relative to the HeaderCtrl view). This can be used by controls using "
"the header (like ArrayCtrl) to determine column break locations or by host applications "
"for positioning dropdown controls (activated upon c")
TOPIC_TEXT(
"licking a tab) relative to the tab box within the header.&][s1; [*C@3 i]-|Tab index "
"(zero based).&][s1; [*/ Return value]-|rectangular tab bounding box within the HeaderCtrl.&][s0;* "
"&][s0; [* Hint:] to locate drop`-down controls (e.g. popup menus) relative to the "
"tab rectangle, you have to transform the returned rectangle to screen coordinates. "
"This can be done for example using the following code")
TOPIC_TEXT(
" snippet:&][s0; &][s0;C -|Rect tab2`_scr`_rect `= tab.GetTabRect(2) `+ tab.GetScreenView().TopLeft();&][s0;3 "
"&][s4;:`:`:HeaderCtrl`:`:Tab`(int`)const: const_Column`&_[* Tab](int_[*@3 i])_const&][s6; "
"Returns the descriptive [* HeaderCtrl`::Column] structure of a given header tab. "
"This constant version can be used to retrieve individual tab properties. For a thorough "
"description of the [* Column] st")
TOPIC_TEXT(
"ructure, see below.&][s1; [*C@3 i]-|Tab index within the header (zero based).&][s1; "
"[*/ Return value]-|a (constant) reference to the [* Column] structure describing "
"the tab.&][s0;3 &][s4;:`:`:HeaderCtrl`:`:Tab`(int`): Column`&_[* Tab](int_[*@3 i])&][s6; "
"Returns a (non`-constant) reference to the descriptive [* HeaderCtrl`::Column] structure "
"of a given header tab. This can be used to set and retrie")
TOPIC_TEXT(
"ve individual tab properties (see below for a full description of the [* Column] "
"structure).&][s1; [*C@3 i]-|Tab index (zero based).&][s1; [*/ Return value]-|a non`-constant "
"reference to the [* Column] structure for the given tab.&][s0;3 &][s4;:`:`:HeaderCtrl`:`:Add`(const "
"char`*`,double`): Column`&_[* Add](const_char_`*[*@3 text], double_[*@3 ratio]_`=_[@3 "
"0])&][s6; Adds a new tab after (to the r")
TOPIC_TEXT(
"ight of) all existing header tabs. The function returns a (non`-constant) reference "
"to the [* HeaderCtrl`::Column] structure which can be further used to set up additional "
"tab properties.&][s1; [*C@3 text]-|Tab (title) name.&][s1; [*C@3 ratio]-|Logical "
"tab width.&][s1; [*/ Return value]-|a non`-constant reference to the [* Column] structure "
"describing the newly added tab.&][s0;3 &][s4;:`:`:HeaderC")
TOPIC_TEXT(
"trl`:`:Add`(`): Column`&_[* Add]()&][s6; Adds a new tab after (to the right of) "
"all existing header tabs. This is identical to the above version with the [/ text] "
"argument set to an empty string and [/ ratio] set to 0.&][s1; [*/ Return value]-|a "
"non`-constant reference to the [* Column] structure describing the newly added tab.&][s0;3 "
"&][s4;:`:`:HeaderCtrl`:`:operator`[`]`(int`)const: const_Column")
TOPIC_TEXT(
"`&_[* operator`[`]](int_[*@3 i])_const&][s6; Returns a (constant) reference to a "
"given header tab. This is identical to the [/ const] version of the [* Tab] method.&][s1; "
"[*C@3 i]-|Tab index (zero based).&][s1; [*/ Return value]-|a constant reference to "
"the given header tab.&][s0;3 &][s4;:`:`:HeaderCtrl`:`:GetCount`(`)const: int_[* GetCount]()_const&][s6; "
"Returns the current number of header tabs.")
TOPIC_TEXT(
" Each [* Add] increases this value by one and [* Reset] sets it to 0 (the initial "
"value).&][s1; [*/ Return value]-|Number of tabs.&][s0;3 &][s4;:`:`:HeaderCtrl`:`:Reset`(`): "
"void_[* Reset]()&][s6; Resets the header tab to its initial state (removes all tabs).&][s0;3 "
"&][s4;:`:`:HeaderCtrl`:`:ShowTab`(int`,bool`): void_[* ShowTab](int_[*@3 i], bool_[*@3 "
"show]_`=_true)&][s6; Shows or hides a certain ")
TOPIC_TEXT(
"header tab.&][s1; [*C@3 i]-|tab index (zero based)&][s1; [*C@3 show]-|flag indicating "
"whether the tab should be shown ([* true]) or hidden ([* false]).&][s0;3 &][s4;:`:`:HeaderCtrl`:`:HideTab`(int`): "
"void_[* HideTab](int_[*@3 i])&][s6; Hides a certain header tab. This is identical "
"to [* ShowTab(i, false)].&][s1; [*C@3 i]-|tab index (zero based)&][s0;3 &][s4;:`:`:HeaderCtrl`:`:IsTabVisible`(int`): ")
TOPIC_TEXT(
"bool_[* IsTabVisible](int_[*@3 i])&][s6; Checks for visibility of a certain tab.&][s1; "
"[*C@3 i]-|tab index (zero based).&][s1; [*/ Return value]-|[* false] `= hidden, [* "
"true] `= shown.&][s0;3 &][s4;:`:`:HeaderCtrl`:`:SetTabRatio`(int`,double`): void_[* "
"SetTabRatio](int_[*@3 i], double_[*@3 ratio])&][s6; Sets the logical tab width (ratio) "
"of a given tab.&][s1; [*C@3 i]-|tab index&][s1; [*C@3 ratio")
TOPIC_TEXT(
"]-|logical tab width.&][s0;3 &][s4;:`:`:HeaderCtrl`:`:GetTabRatio`(int`)const: double_[* "
"GetTabRatio](int_[*@3 i])_const&][s6; Retrieves the current logical width of a certain "
"tab. The logical tab width can be set using the [* SetTabRatio] method (or using "
"the [* SetRatio] method for an individual [* HeaderCtrl`::Column] object) or by dragging "
"the tab breaks using the mouse.&][s1; [*C@3 i]-|tab in")
TOPIC_TEXT(
"dex (zero based)&][s1; [*/ Return value]-|current logical tab width&][s0;3 &][s4;:`:`:HeaderCtrl`:`:SetTabWidth`(int`,int`): "
"void_[* SetTabWidth](int_[*@3 i], int_[*@3 cx])&][s6; Sets the given header tab to "
"a physical (pixel) size. This also modifies the logical (relative) tab width accordingly.&][s1; "
"[*C@3 i]-|tab index (zero based)&][s1; [*C@3 cx]-|tab pixel size&][s0;3 &][s4;:`:`:HeaderCtrl`:`")
TOPIC_TEXT(
":GetTabWidth`(int`): int_[* GetTabWidth](int_[*@3 i])&][s6; Returns the physical "
"(pixel) width of a given header tab. Remember that (unless the HeaderCtrl is in the "
"[* Scroll] mode) the physical tab widths can change with the parent view size. Algorithms "
"for long`-term manipulation of tab sizes (typically serialization) should always "
"count on the logical tab widths.&][s1; [*C@3 i]-|tab index (zero")
TOPIC_TEXT(
" based)&][s1; [*/ Return value]-|physical (pixel) tab width. Note that this function "
"isn`'t [/ const], because the header control uses a lazy algorithm to lay out the "
"header control, and during the call to [* GetTabWidth] it may show that the tabs "
"need to be newly laid out.&][s0;3 &][s4;:`:`:HeaderCtrl`:`:StartSplitDrag`(int`): "
"void_[* StartSplitDrag](int_[*@3 s])&][s6; Starts the header tab drag ")
TOPIC_TEXT(
"`& drop for a given tab break.&][s1; [*C@3 s]-|break index (zero `= left side of "
"tab 0).&][s0;3 &][s4;:`:`:HeaderCtrl`:`:GetSplit`(int`): int_[* GetSplit](int_[*@3 "
"x])&][s6; Locates the header tab break corresponding to a given [/ x] coordinate "
"(relative to the header control). This can be used by the parent controls to check "
"whether the mouse cursor hovers above a tab break (e.g. [* ArrayCtrl] us")
TOPIC_TEXT(
"es this function to check whether to display the horizontal resizing cursor).&][s1; "
"[*C@3 x]-|horizontal pixel coordinate (relative to the header control bounding box).&][s1; "
"[*/ Return value]-|Index of tab break (in the range `[0..GetCount()`]) or `-1 when "
"there is no tab break in the vicinity of a given point.&][s0;3 &][s4;:`:`:HeaderCtrl`:`:GetScroll`(`)const: "
"int_[* GetScroll]()_const&][s6; [*")
TOPIC_TEXT(
" Absolute] mode only: returns pixel offset defining the current origin of the (potentially "
"scrolled) header. For non`-scrolling visual modes, this function always returns 0 "
"(in non`-scrolling modes the left side of first tab always aligns with the left side "
"of parent view).&][s1; [*/ Return value]-|Number of pixels by which the header control "
"is currently scrolled in the horizontal direction. The ")
TOPIC_TEXT(
"physical [/ x] coordinate of a tab edge (relative to parent view) can be calculated "
"by subtracting this value from its logical coordinate (relative to leftmost header "
"edge).&][s0;3 &][s4;:`:`:HeaderCtrl`:`:IsScroll`(`)const: bool_[* IsScroll]()_const&][s6; "
"Checks whether the header control is currently in scrolling mode (i.e., whether it "
"is in the [* Absolute] visual mode and its total tab width e")
TOPIC_TEXT(
"xceeds current view size). When [* IsScroll] returns [* true], the [* GetScroll] "
"method can be used to retrieve the current horizontal scrollbar position.&][s1; [*/ "
"Return value]-|[* true] `= scrolling header, [* false ]`= non`-scrolling header.&][s0;3 "
"&][s4;:`:`:HeaderCtrl`:`:GetHeight`(`)const: int_[* GetHeight]()_const&][s6; Determines "
"the pixel height of the header control. This is equal to th")
TOPIC_TEXT(
"e maximum of all the individual tab heights (depending on the tab title font and "
"icon sizes).&][s1; [*/ Return value]-|HeaderCtrl pixel height.&][s0;3 &][s4;:`:`:HeaderCtrl`:`:Invisible`(bool`): "
"HeaderCtrl`&_[* Invisible](bool_[*@3 inv])&][s6; When called with a [* true] argument, "
"makes the header zero height in frame mode (the tab placement routines still work "
"but the header itself remains hidden")
TOPIC_TEXT(
").&][s1; [*C@3 inv]-|[* true] `= hide the header, [* false] `= show it.&][s1;* [/ "
"Return value][* -|]`*this&][s0;3 &][s4;:`:`:HeaderCtrl`:`:Track`(bool`): HeaderCtrl`&_[* "
"Track](bool_[*@3 `_track]_`=_true)&][s6; Sets whether the HeaderCtrl and its parent "
"view contents should be `'animated`' during repositioning the tab breaks using mouse "
"drag `& drop. When [* `_track] is set to [* true], the heade")
TOPIC_TEXT(
"r and its parents repaint is requested every time the mouse moves during the drag "
"`& drop. When set to [* false], the header and the parent control get repainted only "
"after the drag `& drop is finished. It is wise to set this value depending on the "
"complexity of the data shown `'beneath`' the header (usually in an ArrayCtrl) and "
"on the expected target hardware because the track mode is much more d")
TOPIC_TEXT(
"emanding with respect to computational time spent during the necessary multiple "
"repaints.&][s1; [*C@3 `_track]-|[* true] `= regenerate header and its parent dynamically "
"during drag `& drop, [* false] `= only after it`'s finished.&][s1;* [/ Return value][* "
"-|]`*this&][s0;3 &][s4;:`:`:HeaderCtrl`:`:NoTrack`(`): HeaderCtrl`&_[* NoTrack]()&][s6; "
"Turns off track mode. This is identical to [* Track(fals")
TOPIC_TEXT(
"e)].&][s1;* [/ Return value][* -|]`*this&][s0;3 &][s4;:`:`:HeaderCtrl`:`:Proportional`(`): "
"HeaderCtrl`&_[* Proportional]()&][s6; Switches the HeaderCtrl to the [/ proportional] "
"mode. In proportional mode, the individual logical tab widths are always recalculated "
"to physical (pixel) widths by scaling them using a common multiplication factor in "
"order to fit the whole header into the view width.&][s")
TOPIC_TEXT(
"1;* [/ Return value][* -|]`*this&][s0;3 &][s4;:`:`:HeaderCtrl`:`:ReduceNext`(`): "
"HeaderCtrl`&_[* ReduceNext]()&][s6; Switches the HeaderCtrl to the [/ reduce next] "
"mode. Every time a tab width is set in this mode and the total tab width exceeds "
"the view size, the following tab widths (tabs to the right) are reduced in left`-to`-right "
"order (beginning with the tab just after the tab being adjusted)")
TOPIC_TEXT(
" to fit the view size.&][s1;* [/ Return value][* -|]`*this&][s0;3 &][s4;:`:`:HeaderCtrl`:`:ReduceLast`(`): "
"HeaderCtrl`&_[* ReduceLast]()&][s6; Switches the HeaderCtrl to the [/ reduce last] "
"mode. Every time a tab width is set in this mode and the total tab width exceeds "
"the view size, the following tab widths (tabs to the right) are reduced in right`-to`-left "
"order (beginning with the rightmost ta")
TOPIC_TEXT(
"b) to fit the view size.&][s1;* [/ Return value][* -|]`*this&][s0;3 &][s4;:`:`:HeaderCtrl`:`:Absolute`(`): "
"HeaderCtrl`&_[* Absolute]()&][s6; Switches the HeaderCtrl to the [/ absolute] (scroll) "
"mode. In this mode the tab widths are never modified automatically, the logical header "
"width can be smaller or greater than the actual view size. Whenever the total tab "
"width exceeds the view size, the head")
TOPIC_TEXT(
"er can be scrolled to the left or right to pan its visible portion within the parent "
"view.&][s1;* [/ Return value][* -|]`*this&][s0;3 &][s4;:`:`:HeaderCtrl`:`:GetStdHeight`(`): "
"static int_[* GetStdHeight]()&][s6; Returns the standard header control height (when "
"there are no icons and the standard font is used in all tabs).&][s1; [*/ Return value]-|&][s0;3 "
"&][s4;:`:`:HeaderCtrl`:`:WhenLayout:* [* C")
TOPIC_TEXT(
"allback_]WhenLayout&][s6; This callback is executed whenever the header control "
"gets laid out (whenever the tab positions and/or widths change).&][s0;3 &][s4;:`:`:HeaderCtrl`:`:WhenScroll:* "
"[* Callback_]WhenScroll&][s6; This callback is executed whenever the header control "
"gets scrolled ([/ absolute] mode only).&][s0;3 &][s4;:`:`:HeaderCtrl`:`:WhenScrollVisibility:* "
"[* Callback_]WhenScrollVisibili")
TOPIC_TEXT(
"ty&][s6; This callback is executes whenever its scrollbar appears or disappears "
"(whenever the return value of the [* IsScroll] method changes).&][s0; &][s0; &][s0;*+117 "
"HeaderCtrl`::Column (nested class)&][s6; &][s9; [/ Derived from] [%00-00 LabelBase]&][s0; "
"&][s0; The [* HeaderCtrl`::Column] structure represents an individual header tab. "
"HeaderCtrl methods for tab insertion and editation typicall")
TOPIC_TEXT(
"y return a reference to this [/ Column] class which can be used afterwards to program "
"the various tab properties.&][s0; &][s0; The set methods return a reference to [* "
"`*this] ; this allows multiple tab properties to be set using a single C`+`+ statement "
"with repeated use of the dot operator, e.g.:&][s0; &][s0;C -|headerctrl.Add().Min(10).Max(20).Margin(3);&][s0;3 "
"&][s4;:`:`:HeaderCtrl`:`:Column`:")
TOPIC_TEXT(
"`:Min`(int`): [%00-00 Column`&_][%00-00* Min][%00-00 (int_][%00-00*@3 `_min][%00-00 "
")]&][s6; Sets minimum tab pixel size. The default value is 0 (the tab can be shrunk "
"arbitrarily and can disappear altogether at a certain moment).&][s1; [%00-00*C@3 "
"`_min]-|Minimum tab width in pixels.&][s1;* [/ Return value][* -|]`*this&][s0;3 &][s4;:`:`:HeaderCtrl`:`:Column`:`:Max`(int`): "
"[%00-00 Column`&_][%00-0")
TOPIC_TEXT(
"0* Max][%00-00 (int_][%00-00*@3 `_max][%00-00 )]&][s6; Sets maximum tab pixel size. "
"The default value is [/ INT`_MAX] (unlimited).&][s1; [%00-00*C@3 `_max]-|Maximum "
"tab width in pixels.&][s1;* [/ Return value][* -|]`*this&][s0;3 &][s4;:`:`:HeaderCtrl`:`:Column`:`:MinMax`(int`,int`): "
"[%00-00 Column`&_][%00-00* MinMax][%00-00 (int_][%00-00*@3 m][%00-00 , int_][%00-00*@3 "
"n][%00-00 )]&][s6; Sets both ")
TOPIC_TEXT(
"minimum and maximum tab pixel size at the same time. This has the same effect as "
"[* .Min(m).Max(n)].&][s1; [%00-00*C@3 m]-|Minimum tab width in pixels.&][s1; [%00-00*C@3 "
"n]-|Maximum tab width in pixels.&][s1;* [/ Return value][* -|]`*this&][s0;3 &][s4;:`:`:HeaderCtrl`:`:Column`:`:Fixed`(int`): "
"[%00-00 Column`&_][%00-00* Fixed][%00-00 (int_][%00-00*@3 f][%00-00 )]&][s6; Sets "
"both minimum and maximu")
TOPIC_TEXT(
"m tab pixel size to the same value, effectively making the tab width constant. Equal "
"to [* .MinMax(f, f)].&][s1; [%00-00*C@3 f]-|Fixed tab width in pixels.&][s1;* [/ "
"Return value][* -|]`*this&][s0;3 &][s4;:`:`:HeaderCtrl`:`:Column`:`:SetRatio`(double`): "
"[%00-00 Column`&_][%00-00* SetRatio][%00-00 (double_][%00-00*@3 ratio][%00-00 )]&][s6; "
"Sets logical (relative) tab width. The logical tab width (t")
TOPIC_TEXT(
"ogether with logical widths of other tabs and the minimum / maximum width constraints) "
"is used to calculate the final pixel size of each tab according to the current header "
"visual mode.&][s1; [%00-00*C@3 ratio]-|relative tab width (a generic floating`-point "
"value)&][s1;* [/ Return value][* -|]`*this&][s0;3 &][s4;:`:`:HeaderCtrl`:`:Column`:`:SetMargin`(int`): "
"[%00-00 Column`&_][%00-00* SetMargin][%")
TOPIC_TEXT(
"00-00 (int_][%00-00*@3 m][%00-00 )]&][s6; Sets horizontal tab margin size, the number "
"of pixels to deflate the tab rectangle horizontally to obtain the final `\"column "
"data`\" rectangle. In [/ ArrayCtrl], the tab margin areas are used to paint the grid "
"lines and the inverted selection rectangle outside of the table cells.&][s1; [%00-00*C@3 "
"m]-|Horizontal tab margin size in pixels.&][s1;* [/ Return v")
TOPIC_TEXT(
"alue][* -|]`*this&][s0;3 &][s4;:`:`:HeaderCtrl`:`:Column`:`:GetMargin`(`)const: "
"[%00-00 int_][%00-00* GetMargin][%00-00 ()_const]&][s6; Returns current tab margin "
"width in pixels.&][s1;* [/ Return value][* -|]`*this&][s0;3 &][s4;:`:`:HeaderCtrl`:`:Column`:`:WhenAction:* "
"[%00-00* Callback_][%00-00 WhenAction]&][s6; The tab action callback. When set to "
"a non`-null value, the header control starts to")
TOPIC_TEXT(
" check for mouse clicks within this tab and calls this callback whenever the corresponding "
"tab is clicked.&][s0; &][s0; &][s0;3 ]")
