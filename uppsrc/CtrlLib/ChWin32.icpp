#include "CtrlLib.h"

#define LLOG(x) // LOG(x)

#define IMAGECLASS CtrlsImg
#define IMAGEFILE <CtrlLib/Ctrls.iml>
#include <Draw/iml_source.h>

#ifdef PLATFORM_WIN32

#include <uxtheme.h>
#include <tmschema.h>

#define DLLFILENAME "uxtheme.dll"
#define DLIMODULE   XpTheme
#define DLIHEADER   <CtrlLib/XpTheme.dli>
#define DLLCALL     STDAPICALLTYPE
#define WIDGET(x)
#include <Core/dli.h>

#define FN(a, b, c)
#define WIDGET(x)    XP_##x,
enum {
#include "XPTheme.dli"
	XP_COUNT
};

#undef  WIDGET
#define WIDGET(x)   #x,

static const char *xp_widget_name[] = {
#include "XPTheme.dli"
	NULL
};

#undef  WIDGET
#undef  FN

struct XpElement {
	int   widget;
	int   part;
	int   state;
};

static HANDLE xp_widget_handle[XP_COUNT];

HANDLE XpWidget(int widget)
{
	if(xp_widget_handle[widget] == NULL && XpTheme())
		xp_widget_handle[widget] = XpTheme().OpenThemeData(NULL,
		                            (WCHAR *)(const wchar *)WString(xp_widget_name[widget]));
	return xp_widget_handle[widget];
}

Image XpImage(int widget, int part, int state, Color color = Null, Size sz = Null)
{
	HANDLE theme = XpWidget(widget);
	if(!theme)
		return Null;
	if(IsNull(sz))
		XpTheme().GetThemePartSize(theme, ScreenInfo().GetHandle(), part, state, NULL,
		                           1 /*TS_TRUE*/, sz);
	Color c = White;
	Image m[2];
	for(int q = 0; q < 2; q++) {
		ImageDraw iw(sz);
		iw.DrawRect(sz, Nvl(color, c));
		HDC hdc = iw.BeginGdi();
		Rect r(sz);
		XpTheme().DrawThemeBackground(theme, hdc, part, state, r, NULL);
		iw.EndGdi();
		m[q] = iw;
		c = Black;
	}
	ImageBuffer r(sz);
	const RGBA *ws = m[0];
	const RGBA *bs = m[1];
	RGBA *t = r;
	RGBA *e = t + r.GetLength();
	while(t < e) {
		t->a = bs->r - ws->r + 255;
		if(t->a) {
			t->r = bs->r * 255 / t->a;
			t->g = bs->g * 255 / t->a;
			t->b = bs->b * 255 / t->a;
		}
		else
			t->r = t->g = t->b = 0;
		t++;
		bs++;
		ws++;
	}
	return r;
}

int Diff(RGBA a, RGBA b)
{
	return max(abs(a.r - b.r), max(abs(a.b - b.b), abs(a.g - b.g)));
}

struct InterPoint {
	ImageBuffer &b;
	Rect         rc;
	int          sr, sg, sb;
	int          sn, in;

	InterPoint(ImageBuffer& b) : b(b) {
		sr = sg = sb = sn = in = 0;
	}
	void Add(int x, int y);
};

void InterPoint::Add(int y, int x) {
	if(rc.Contains(x, y)) {
		RGBA ba = b[y][x];
		if(ba.a == 0)
			return;
		in++;
		sn++;
		sr += ba.r;
		sg += ba.g;
		sb += ba.b;
	}
	else
		in++;
}

void Interpolate(ImageBuffer& b, const Rect& rc)
{
	int todo;
	do {
		todo = 0;
		for(int x = rc.left; x < rc.right; x++)
			for(int y = rc.top; y < rc.bottom; y++) {
				RGBA& p = b[y][x];
				if(p.a == 0) {
					InterPoint ip(b);
					ip.rc = rc;
					ip.Add(y - 1, x - 1);
					ip.Add(y - 1, x);
					ip.Add(y - 1, x + 1);
					ip.Add(y, x - 1);
					ip.Add(y, x + 1);
					ip.Add(y + 1, x - 1);
					ip.Add(y + 1, x);
					ip.Add(y + 1, x + 1);
					if(ip.in >= 2) {
						if(ip.sn) {
							p.r = ip.sr / ip.sn;
							p.g = ip.sg / ip.sn;
							p.b = ip.sb / ip.sn;
						}
						else
							p = SColorFace();
						p.a = 255;
					}
					else
						todo++;
				}
			}
	}
	while(todo);
}

struct ButtonDecomposer {
	Image src;
	Image dst;
	int   aa[8];

	RGBA GetC(int p) {
		Size sz = src.GetSize();
		int xx[3];
		int yy[3];
		yy[0] = xx[0] = aa[p];
		xx[1] = sz.cx - aa[p] - 1;
		xx[2] = sz.cx / 2;
		yy[1] = sz.cy - aa[p] - 1;
		yy[2] = sz.cy / 2;
		return src[xx[p / 3]][xx[p % 3]];
	}

	void Do() {
		Size sz = src.GetSize();
		int qa = min(4, min(sz.cy / 5, sz.cx / 5));
		if(qa == 0) {
			dst = src;
			return;
		}
		int a = 0;
		for(int p = 0; p < 8; p++) {
			aa[p] = qa;
			Color c = GetC(p);
			while(aa[p] > 0) {
				Color c1 = GetC(p);
				if(Diff(c, c1) > 30)
					break;
				c = c1;
				aa[p]--;
			}
			if(aa[p] > a)
				a = aa[p];
		}
		if(a < min(sz.cy / 3, sz.cy / 3))
			a++;
		dst = src;
		ImageBuffer b(dst);
		for(int y = a; y < sz.cy - a; y++) {
			RGBA *p = b[y];
			int x = a;
			Color c = p[x];
			while(x < sz.cx - a) {
				if(Diff(p[x], c) > 30)
					break;
				c = p[x++];
			}
			int xx = sz.cx - a;
			while(xx > x) {
				if(Diff(p[xx - 1], c) > 30)
					break;
				c = p[--xx];
			}
			Fill(p + x, RGBAZero(), xx - x);
		}
		Interpolate(b, Rect(a, a, sz.cx - a, sz.cy - a));
		b.SetHotSpot(Point(a, a));
		dst = b;
	}
};

Image Unglyph(const Image& m)
{
	ButtonDecomposer b;
	b.src = m;
	b.Do();
	return b.dst;
}

Image VertBlend(Image img1, Image img2, int y0, int y1)
{
	Size sz = img1.GetSize();
	Size sz2 = img2.GetSize();
	sz.cx = min(sz.cx, sz2.cx);
	sz.cy = min(sz.cy, sz2.cy);
	ImageBuffer b(sz);
	for(int y = 0; y < sz.cy; y++)
		if(y >= y1)
			memcpy(b[y], img2[y], sz.cx * sizeof(RGBA));
		else {
			memcpy(b[y], img1[y], sz.cx * sizeof(RGBA));
			if(y >= y0 && y1 > y0)
				AlphaBlend(b[y], img2[y], sz.cx, 255 * (y - y0) / (y1 - y0));
		}
	return b;
}

Image HorzSymm(Image src) {
	ImageBuffer b(src);
	Size sz = b.GetSize();
	for(int y = 0; y < sz.cy; y++) {
		RGBA *l = b[y];
		for(int x = 0; x < sz.cx / 2; x++)
			l[sz.cx - x - 1] = l[x];
	}
	return b;
}

Color XpColor(int widget, int part, int state, int type)
{
	COLORREF cref = 0;
	HANDLE theme = XpWidget(widget);
	if(!theme)
		return Null;
	int r = XpTheme().GetThemeColor(theme, part, state, type, &cref);
	return r == S_OK ? Color::FromCR(cref) : Null;
}

int XpInt(int widget, int part, int state, int type)
{
	HANDLE theme = XpWidget(widget);
	if(!theme)
		return Null;
	int n = Null;
	int x = 0;
	int r = XpTheme().GetThemeInt(theme, part, state, type, &n);
	return r == S_OK ? n : Null;
}

Rect XpMargins(int widget, int part, int state)
{
	HANDLE theme = XpWidget(widget);
	if(!theme)
		return Rect(0, 0, 0, 0);
	MARGINS m;
	int r = XpTheme().GetThemeMargins(theme, NULL, part, state, 3601, NULL, &m);
	return r == S_OK ? Rect(m.cxLeftWidth, m.cyTopHeight, m.cxRightWidth, m.cyBottomHeight)
	                 : Rect(0, 0, 0, 0);
}

void SetXpImages(int uii, int n, int widget, int part, int state)
{
	for(int i = 0; i < n; i++) {
		Image m = XpImage(widget, part, state++);
		if(!IsNull(m))
			CtrlsImg::Set(uii++, m);
	}
}

void SetXpColors(const char *chcolor, int n, int widget, int part, int state, int type)
{
	int ii = 0;
	for(int i = 0; i < n; i++) {
		Color c = XpColor(widget, part, state++, type);
		if(!IsNull(c))
			ChSet(chcolor, ii++, c);
	}
}

Value XpLookFn(Draw& w, const Rect& r, const Value& v, int op)
{
	if(IsTypeRaw<XpElement>(v)) {
		const XpElement& e = ValueTo<XpElement>(v);
		switch(op) {
		case LOOK_MARGINS:
			return XpMargins(e.widget, e.part, e.state);
		case LOOK_ISOPAQUE:
			return 1; //TODO - improve by adding the real transparency support
		}
		if(op == LOOK_PAINT || op == LOOK_PAINTEDGE) {
			if(op == LOOK_PAINTEDGE) {
				Rect m = XpMargins(e.widget, e.part, e.state);
				w.Begin();
				w.ExcludeClip(m.left, m.top,
				              r.Width() - m.left - m.right, r.Height() - m.top - m.bottom);
			}
			w.DrawRect(r, SColorFace); //TODO - improve by adding the real transparency support
			HANDLE htheme = XpWidget(e.widget);
			if(htheme) {
				HDC hdc = w.BeginGdi();
				XpTheme().DrawThemeBackground(htheme, hdc, e.part, e.state, r, NULL);
				w.EndGdi();
			}
			if(op == LOOK_PAINTEDGE)
				w.End();
			return 1;
		}
	}
	return Null;
}

void ChInitWin()
{
	LLOG("ChInitWin");
	CtrlImg::Set(CtrlImg::I_information, Win32Icon(IDI_INFORMATION));
	CtrlImg::Set(CtrlImg::I_question, Win32Icon(IDI_QUESTION));
	CtrlImg::Set(CtrlImg::I_exclamation, Win32Icon(IDI_EXCLAMATION));

	ChSet("FrameButtonWidth", GetSystemMetrics(SM_CYHSCROLL));
	ChSet("ScrollBarArrowSize", GetSystemMetrics(SM_CXHSCROLL));
}

struct sOverrideImg {
	int target;
	int source;
	int count;
};

static sOverrideImg oimgs[] = {
	{ CtrlsImg::I_SBVT, CtrlsImg::I_Wcb_SB, 4 },
	{ CtrlsImg::I_SBHT, CtrlsImg::I_Wcb_SB, 4 },
};

void ChInitWinClassic()
{
	LLOG("ChInitWinClassic");
	ChInitWin();
	Ctrl::SetXPStyle(false);
	Override(CtrlsImg::Iml(), "Wcsw_;Wco_;Wc_;Wcb_;Wca_;Wce_", CtrlsImg::Iml());
//	for(sOverrideImg *m = oimgs; m < oimgs + __countof(oimgs); m++)
//		for(int q = 0; q < m->count; q++)
//			CtrlsImg::Set(m->target + q, CtrlsImg::Get(m->source + q));
	ChSet("ScrollBarVertThumbImg", Null);
	ChSet("ScrollBarHorzThumbImg", Null);
	Color wc = Blend(SColorFace(), SColorPaper(), 170);
	ChSet("ScrollBarHorzUpper", wc);
	ChSet("ScrollBarHorzUpper", CTRL_PRESSED, SColorText());
	ChSetf("ScrollBarHorzThumb", ScrollButtonLook);
	ChSet("ScrollBarHorzLower", wc);
	ChSet("ScrollBarHorzLower", CTRL_PRESSED, SColorText());
	ChSet("ScrollBarVertUpper", wc);
	ChSet("ScrollBarVertUpper", CTRL_PRESSED, SColorText());
	ChSetf("ScrollBarVertThumb", ScrollButtonLook);
	ChSet("ScrollBarVertLower", wc);
	ChSet("ScrollBarVertLower", CTRL_PRESSED, SColorText());

	ChSet("ButtonPressOffsetFlag", 1);
	ChSet("ButtonMonoColor", SColorText());
	ChSet("LabelBoxTextColor", SColorText());
}

struct chCtrlsImg {
	int id;
	int count;
	int widget;
	int part;
	int state;
};

static chCtrlsImg sImgs[] = {
	{ CtrlsImg::I_S0, 4, XP_BUTTON, BP_RADIOBUTTON, RBS_UNCHECKEDNORMAL },
	{ CtrlsImg::I_S1, 4, XP_BUTTON, BP_RADIOBUTTON, RBS_CHECKEDNORMAL },
	{ CtrlsImg::I_O0, 4, XP_BUTTON, BP_CHECKBOX, CBS_UNCHECKEDNORMAL },
	{ CtrlsImg::I_O1, 4, XP_BUTTON, BP_CHECKBOX, CBS_CHECKEDNORMAL },
	{ CtrlsImg::I_O2, 4, XP_BUTTON, BP_CHECKBOX, CBS_MIXEDNORMAL },
};

struct chLooks {
	const char *id;
	int   count;
	int   widget;
	int   part;
	int   state;
};

static chLooks sLooks[] = {
	{ "ButtonLook", 4, XP_BUTTON, BP_PUSHBUTTON, 1 },
	{ "OkButtonLook", 4, XP_BUTTON, BP_PUSHBUTTON, 1 },
	{ "ScrollBarHorzUpper", 4, XP_SCROLLBAR, SBP_LOWERTRACKHORZ, 1 },
	{ "ScrollBarHorzThumb", 4, XP_SCROLLBAR, SBP_THUMBBTNHORZ, 1 },
	{ "ScrollBarHorzLower", 4, XP_SCROLLBAR, SBP_UPPERTRACKHORZ, 1 },
	{ "ScrollBarVertUpper", 4, XP_SCROLLBAR, SBP_LOWERTRACKVERT, 1 },
	{ "ScrollBarVertThumb", 4, XP_SCROLLBAR, SBP_THUMBBTNVERT, 1 },
	{ "ScrollBarVertLower", 4, XP_SCROLLBAR, SBP_UPPERTRACKVERT, 1 },
	{ "ScrollBarUp", 4, XP_SCROLLBAR, SBP_ARROWBTN, ABS_UPNORMAL },
	{ "ScrollBarDown", 4, XP_SCROLLBAR, SBP_ARROWBTN, ABS_DOWNNORMAL },
	{ "ScrollBarLeft", 4, XP_SCROLLBAR, SBP_ARROWBTN, ABS_LEFTNORMAL },
	{ "ScrollBarRight", 4, XP_SCROLLBAR, SBP_ARROWBTN, ABS_RIGHTNORMAL },
	{ "SpinUpLook", 4, XP_SPIN, SPNP_UP, 1 },
	{ "SpinDownLook", 4, XP_SPIN, SPNP_DOWN, 1 },
	{ "DropBoxBtn", 4, XP_COMBOBOX, CP_DROPDOWNBUTTON, 1 },
	{ "DropBoxEdge", 1, XP_COMBOBOX, 0, 0 },
};

Color SimpleColor(const Image& m)
{
	const RGBA *s = m;
	const RGBA *e = m + m.GetLength();
	if(s >= e)
		return Null;
	RGBA c = *s++;
	while(s < e)
		if(c != *s++)
			return Null;
	return c;
}

void ChInitWin32Detect()
{
	ChInitWin();
	if(XpWidget(XP_BUTTON)) {
		LLOG("XP theme !");
		TIMING("XPTheme");
		Ctrl::SetXPStyle(true);
		Override(CtrlsImg::Iml(), "", CtrlsImg::Iml());
		ChSet("EditFieldIsThin", 1);
		for(chCtrlsImg *m = sImgs; m < sImgs + __countof(sImgs); m++)
			SetXpImages(m->id, m->count, m->widget, m->part, m->state);
		XpElement e;
		for(chLooks *l = sLooks; l < sLooks + __countof(sLooks); l++)
			for(int i = 0; i < l->count; i++) {
				e.widget = l->widget;
				e.part = l->part;
				e.state = l->state + i;
				ChSet(l->id, i, RawToValue(e));
			}
/*		Image m = XpImage(XP_WINDOW, WP_DIALOG, 0, SColorPaper());
		if(!IsNull(SimpleColor(m))) {
			e.widget = XP_WINDOW;
			e.part = WP_DIALOG;
			e.state = 0;
			ChSet("DialogFaceLook", RawToValue(e));
		}*/
		ChSet("ScrollBarUpImg", Null);
		ChSet("ScrollBarDownImg", Null);
		ChSet("ScrollBarLeftImg", Null);
		ChSet("ScrollBarRightImg", Null);
		ChSet("SpinUpImg", Null);
		ChSet("SpinDownImg", Null);
		ChSet("ScrollBarVertThumbImg", XpImage(XP_SCROLLBAR, SBP_GRIPPERVERT, 1));
		ChSet("ScrollBarHorzThumbImg", XpImage(XP_SCROLLBAR, SBP_GRIPPERHORZ, 1));
		e.widget = XP_BUTTON;
		e.part = BP_PUSHBUTTON;
		e.state = PBS_DEFAULTED;
		ChSet("OkButtonLook", 0, RawToValue(e));
		ChSet("DropBoxInsideEdge", XpInt(XP_COMBOBOX, CP_DROPDOWNBUTTON, CBXS_NORMAL,
		                                 TMT_BORDERSIZE));
		ChSet("DropImg", Null);
		for(int i = 0; i < 4; i++) {
			Color paper = i == 3 ? SColorFace : SColorPaper;
			Image m = Unglyph(XpImage(XP_COMBOBOX, CP_DROPDOWNBUTTON, CBXS_NORMAL + i, paper));
			if(XpInt(XP_COMBOBOX, CP_DROPDOWNBUTTON, CBXS_NORMAL + i, TMT_BORDERSIZE) == 0) {
				Image h = CreateImage(m.GetSize() + 2, paper);
				Copy(h, Point(1, 1), HorzSymm(m), m.GetSize());
				m = h;
			}
			ChSet("EdgeButtonLook", i, m);
			m = Unglyph(XpImage(XP_SCROLLBAR, SBP_ARROWBTN, i + ABS_UPNORMAL, paper));
			Size msz = m.GetSize();
			ChSet("ScrollButtonLook", i,
			      VertBlend(m, Unglyph(XpImage(XP_SCROLLBAR, SBP_ARROWBTN, i + ABS_DOWNNORMAL,
			                                   paper)),
			                msz.cy / 3, msz.cy * 2 / 3));
		}
		int ebs = max(1, XpInt(XP_EDIT, EP_EDITTEXT, 1, TMT_BORDERSIZE));
		Image ee = XpImage(XP_EDIT, EP_EDITTEXT, 1, SColorFace(), Size(3 * ebs, 3 * ebs));
		ImageBuffer eb(ee);
		eb.SetHotSpot(Point(ebs, ebs));
		ee = eb;
		ChSet("EditFieldEdge", ee);

		ebs = max(1, XpInt(XP_LISTVIEW, 0, 1, TMT_BORDERSIZE));
		ee = XpImage(XP_LISTVIEW, 0, 1, SColorFace(), Size(3 * ebs, 3 * ebs));
		eb = ee;
		eb.SetHotSpot(Point(ebs + 1, ebs + 1));
		ee = eb;
		ChSet("ViewEdge", ee);

		ChSet("SpinWidth", FrameButtonWidth());
		ChSet("LabelBoxTextColor", XpColor(XP_BUTTON, BP_GROUPBOX, GBS_NORMAL, TMT_TEXTCOLOR));
		ChSet("LabelBoxColor", XpColor(XP_BUTTON, BP_GROUPBOX, GBS_NORMAL, TMT_BORDERCOLORHINT));

//		SetXpColors("ButtonTextColor", 4, BP_PUSHBUTTON, PBS_NORMAL, TMT_TEXTCOLOR); //TODO?!

		ChLookFn(XpLookFn);
	}
	else
		ChInitWinClassic();
}

void ChInitUpp()
{
	Ctrl::SetXPStyle(true);
}

void ChWin32Reset()
{
	LLOG("ChWin32Reset");
	CtrlImg::Reset();
	CtrlsImg::Reset();
	memset(xp_widget_handle, 0, sizeof(xp_widget_handle));
}

INITBLOCK {
	ChRegister("", ChWin32Reset);
	ChRegister("detect", ChInitWin32Detect);
	ChRegister("WinClassic", ChInitWinClassic);
	ChRegister("U++", ChInitUpp);
}

#endif

#ifdef PLATFORM_X11

void ChInitUpp()
{
	CtrlImg::Reset();
	CtrlsImg::Reset();
	Ctrl::SetXPStyle(true);
}

INITBLOCK {
	ChRegister("", ChInitUpp);
}

#endif
