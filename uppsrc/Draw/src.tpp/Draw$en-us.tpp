TITLE("Draw")
REF("::Draw::class::Draw")
REF("::Draw::Draw()")
REF("::Draw::Draw(::Draw able,GC,XftDraw*,const::Vector<::Rect>&)")
REF("::Draw::Draw(::Draw able,GC,const::Vector<::Rect>&)")
REF("::Draw::Draw(Drawable,GC,XftDraw*,const::Vector<::Rect>&)")
REF("::Draw::Init(const::Vector<::Rect>&,::Point")
REF("::Draw::PaletteMode()const")
REF("::Draw::IsMono()const")
REF("::Draw::GetPagePixels()const")
REF("::Draw::GetPageMMs()const")
REF("::Draw::GetPixelsPerInch()const")
REF("::Draw::GetSheetPixels()const")
REF("::Draw::GetPageOffset()const")
REF("::Draw::Pixels()const")
REF("::Draw::Dots()const")
REF("::Draw::IsPrinter()const")
REF("::Draw::IsAborted()const")
REF("::Draw::IsBack()const")
REF("::Draw::IsDrawing()const")
REF("::Draw::IsMetaFile()const")
REF("::Draw::AutoPalette()")
REF("::Draw::SetAutoPalette(bool)")
REF("::Draw::Win32UpdateSColors()")
REF("::Draw::AddFace(const LOGFONT*,const TEXTMETRIC*,::dword,LPARAM)")
REF("::Draw::SetStdFont(::Font)")
REF("::Draw::GetStdFont()")
REF("::Draw::GetStdFontSize()")
REF("::Draw::GetStdFontCy()")
REF("::Draw::GetFontInfo(::byte,::Font")
REF("::Draw::GetFontInfo(::Font")
REF("::Draw::GetFontInfoW(::Font")
REF("::Draw::Begin()")
REF("::Draw::End()")
REF("::Draw::Offset(::Point)")
REF("::Draw::Offset(int,int)")
REF("::Draw::Clip(const::Rect&)")
REF("::Draw::Clip(int,int,int,int)")
REF("::Draw::Clipoff(const::Rect&)")
REF("::Draw::Clipoff(int,int,int,int)")
REF("::Draw::ExcludeClip(const::Rect&)")
REF("::Draw::ExcludeClip(int,int,int,int)")
REF("::Draw::IntersectClip(const::Rect&)")
REF("::Draw::IntersectClip(int,int,int,int)")
REF("::Draw::GetClip()const")
REF("::Draw::GetOffset()const")
REF("::Draw::GetCloffLevel()const")
REF("::Draw::LPtoDP(::Point)const")
REF("::Draw::DPtoLP(::Point)const")
REF("::Draw::LPtoDP(const::Rect&)const")
REF("::Draw::DPtoLP(const::Rect&)const")
REF("::Draw::DrawRect(int,int,int,int,::Color)")
REF("::Draw::DrawRect(const::Rect&,::Color)")
REF("::Draw::DrawLine(int,int,int,int,int,::Color)")
REF("::Draw::enum{ BEGIN, OFFSET, CLIP, CLIPOFF, EXCLUDECLIP, INTERSECTCLIP, END, DRAWRECT, DRAWIMAGE, DRAWMONOIMAGE, DRAWDRAWING, DRAWLINE, DRAWELLIPSE, DRAWTEXT, DRAWARC, DRAWPOLYPOLYLINE}")
REF("::Draw::DrawLine(::Point,::Point,int,::Color)")
REF("::Draw::DrawEllipse(const::Rect&,::Color,int,::Color)")
REF("::Draw::DrawEllipse(int,int,int,int,::Color,int,::Color)")
REF("::Draw::DrawArc(const::Rect&,::Point,::Point,int,::Color)")
REF("::Draw::DrawPolyPolyline(const::Point*,int,const int*,int,int,::Color,::Color)")
REF("::Draw::DrawPolyPolyline(const::Vector<::Point>&,const::Vector<int>&,int,::Color,::Color)")
REF("::Draw::DrawPolyline(const::Point*,int,int,::Color,::Color)")
REF("::Draw::DrawPolyline(const::Vector<::Point>&,int,::Color,::Color)")
REF("::Draw::DrawPolyPolyPolygon(const::Point*,int,const int*,int,const int*,int,::Color,int,::Color,::Image,::Color)")
REF("::Draw::DrawImage(const::Rect&,const::Image&,const::Rect&,int)")
REF("::Image::enum{ EFFECT_MASK, STANDARD, GRAYED, ETCHED, XOR}")
REF("::Draw::DrawImage(const::Rect&,const::Image&,int)")
REF("::Draw::DrawImage(int,int,int,int,const::Image&,int)")
REF("::Draw::DrawImage(int,int,const::Image&,int)")
REF("::Draw::DrawImage(const::Rect&,const::Image&,const::Rect&,::Color,::Color,::Color)")
REF("::Draw::DrawImage(const::Rect&,const::Image&,::Color,::Color,::Color)")
REF("::Draw::DrawImage(int,int,int,int,const::Image&,::Color,::Color,::Color)")
REF("::Draw::DrawImage(int,int,const::Image&,::Color,::Color,::Color)")
REF("::Draw::GetTextSize(const::wchar*,::Font")
REF("::Draw::DrawText(int,int,int,const::wchar*,::Font")
REF("::Draw::DrawText(int,int,const::wchar*,::Font")
REF("::Draw::GetTextSize(const::WString&,::Font")
REF("::Draw::DrawText(int,int,const::WString&,::Font")
REF("::Draw::DrawText(int,int,int,const::WString&,::Font")
REF("::Draw::GetTextSize(const char*,::byte,::Font")
REF("::Draw::DrawText(int,int,int,const char*,::byte,::Font")
REF("::Draw::DrawText(int,int,const char*,::byte,::Font")
REF("::Draw::GetTextSize(const char*,::Font")
REF("::Draw::DrawText(int,int,int,const char*,::Font")
REF("::Draw::DrawText(int,int,const char*,::Font")
REF("::Draw::GetTextSize(const::String&,::Font")
REF("::Draw::DrawText(int,int,const::String&,::Font")
REF("::Draw::DrawText(int,int,int,const::String&,::Font")
REF("::Draw::SinCos(int,double&,double&)")
REF("::Draw::DrawDrawing(const::Rect&,const::Drawing&)")
REF("::Draw::DrawDrawing(int,int,int,int,const::Drawing&)")
REF("::Draw::DrawingOp(int)")
REF("::Draw::PutRect(const::Rect&)")
REF("::Draw::BeginOp()")
REF("::Draw::EndOp()")
REF("::Draw::OffsetOp(::Point)")
REF("::Draw::ClipOp(const::Rect&)")
REF("::Draw::ClipoffOp(const::Rect&)")
REF("::Draw::ExcludeClipOp(const::Rect&)")
REF("::Draw::IntersectClipOp(const::Rect&)")
REF("::Draw::GetClipOp()const")
REF("::Draw::DrawRectOp(int,int,int,int,::Color)")
REF("::Draw::DrawImageOp(const::Rect&,const::Image&,const::Rect&,int)")
REF("::Draw::DrawImageOp(const::Rect&,const::Image&,const::Rect&,::Color,::Color,::Color)")
REF("::Draw::DrawLineOp(int,int,int,int,int,::Color)")
REF("::Draw::DrawPolyPolylineOp(const::Point*,int,const int*,int,int,::Color,::Color)")
REF("::Draw::DrawEllipseOp(const::Rect&,::Color,int,::Color)")
REF("::Draw::DrawArcOp(const::Rect&,::Point,::Point,int,::Color)")
REF("::Draw::DrawTextOp(int,int,int,const::wchar*,::Font,::Color,int,const int*)")
REF("::Draw::DrawDrawingOp(const::Rect&,const::Drawing&)")
REF("::Draw::GetColor(::Color)const")
REF("::Draw::SetColor(::Color)")
REF("::Draw::SetDrawPen(int,::Color)")
REF("::Draw::BeginGdi()")
REF("::Draw::EndGdi()")
REF("::Draw::GetHandle()")
REF("::Draw::operator HDC()const")
REF("::Draw::Unselect()")
REF("::Draw::Attach(HDC)")
REF("::Draw::Detach()")
REF("::Draw::GetSizeCaps(int,int)const")
REF("::Draw::Flush()")
REF("::Draw::MakeXLFD(::byte,::Font,int,int)")
REF("::Draw::CreateXftFont(::Font,int)")
REF("::Draw::GetXftDraw()const")
REF("::Draw::SetForeground(::Color)")
REF("::Draw::SetLineStyle(int)")
REF("::Draw::SetFont(::Font,int)")
REF("::Draw::SetClip()")
REF("::Draw::GetDrawable()const")
REF("::Draw::GetGC()const")
REF("::Draw::GetClipList()const")
REF("::Draw::GetFontInfo(::byte,::Font)")
REF("::Draw::StartPage()")
REF("::Draw::EndPage()")
REF("::Draw::Register(int,::Draw::Drawer)")
REF("::ScreenDraw::class::ScreenDraw")
REF("::ScreenInfo()")
REF("::ViewDraw::class::ViewDraw")
REF("::ViewDraw::ViewDraw(::Ctrl*)")
REF("::ImageDraw::class::ImageDraw")
REF("::ImageDraw::ImageDraw()")
REF("::ImageDraw::ImageDraw(::Draw&,::Image&)")
REF("::ImageDraw::ImageDraw(::Image&)")
REF("::ImageDraw::Open(::Image&)")
REF("::ImageDraw::Open(::Draw&,::Image&)")
REF("::ImageDraw::Close()")
REF("::ImageMaskDraw::class::ImageMaskDraw")
REF("::ImageMaskDraw::ImageMaskDraw()")
REF("::ImageMaskDraw::ImageMaskDraw(::Image&)")
REF("::ImageMaskDraw::Open(::Image&)")
REF("::ImageMaskDraw::Close()")
REF("::DrawingDraw::class::DrawingDraw")
REF("::DrawingDraw::DrawingDraw()")
REF("::DrawingDraw::DrawingDraw(int,int)")
REF("::DrawingDraw::DrawingDraw(::Size)")
REF("::DrawingDraw::SetPixels(bool)")
REF("::DrawingDraw::Create(int,int)")
REF("::DrawingDraw::Create(::Size)")
REF("::DrawingDraw::GetResult()const")
REF("::DrawingDraw::operator::Drawing()const")
REF("::WinMetaFileDraw::WinMetaFileDraw(HDC,int,int,const char*,const char*,const char*)")
REF("::WinMetaFileDraw::WinMetaFileDraw(int,int,const char*,const char*,const char*)")
REF("::WinMetaFileDraw::Create(HDC,int,int,const char*,const char*,const char*)")
REF("::WinMetaFileDraw::Create(int,int,const char*,const char*,const char*)")
REF("::WinMetaFileDraw::Close()")
REF("::PrintDraw::class::PrintDraw")
REF("::PrintDraw::PrintDraw(HDC,const char*)")
REF("::PrintDraw::StartPage()")
REF("::PrintDraw::EndPage()")
REF("::PrintDraw::InitPrinter()")
REF("::PrintDraw::Abort()")
REF("::PageDraw::struct::PageDraw")
TOPIC_TEXT(
"[2 $$0,0#00000000000000000000000000000000:Default][l288;i1120;a17;O9;~~~.1408;2 "
"$$1,0#10431211400427159095818037425705:param][a83;*R6 $$2,5#31310162474203024125188417583966:caption][b83;*4 "
"$$3,5#07864147445237544204411237157677:title][i288;O9;C2 $$4,6#40027414424643823182269349404212:item][b42;a42;2 "
"$$5,5#45413000475342174754091244180557:text][l288;b17;a17;2 $$6,6#27521748481378242620020725143825:")
TOPIC_TEXT(
"desc][l321;t246;C@5;1 $$7,7#20902679421464641399138805415013:code][b2503; $$8,0#65142375456100023862071332075487:separator][*@(0.0.255)2 "
"$$9,0#83433469410354161042741608181528:base][t4167;C $$10,0#37138531426314131251341829483380:class][l288;a17;*1 "
"$$11,11#70004532496200323422659154056402:requirement][i417;b42;a42;O9;~~~.416;2 $$12,12#10566046415157235020018451313112:tparam][b167;C2 "
"$$13,13#924304")
TOPIC_TEXT(
"59443460461911108080531343:item1][i288;a42;O9;C2 $$14,14#77422149456609303542238260500223:item2][*@2$(0.128.128) "
"$$15,15#34511555403152284025741354420178:NewsDate][l321;*C$7;2 $$16,16#03451589433145915344929335295360:result][l321;b83;a83;*C$7;2 "
"$$17,17#07531550463529505371228428965313:result`-line][l160;t4167;*C+117 $$18,5#88603949442205825958800053222425:package`-title][ "
"$$19,0#535800234423355290")
TOPIC_TEXT(
"39900623488521:gap][t4167;C2 $$20,20#70211524482531209251820423858195:class`-nested][b50;2 "
"$$21,21#03324558446220344731010354752573:Par][{_}%EN-US [s2;:`:`:Draw`:`:class`:`:Draw: "
"Draw&][s10;* [* class_]Draw&][s6; &][s0; @@VectorImage:1668&2304\236\202\377\377\377\377\326\311\240\315\341\356\300\363\277\226\203\277\200\357\333\334\362\300\346\300\276\240\324\343\376\363\203\363\363\365\302\346\205\314\200\300\200\364\304\304\362\341\240\367\350\301\355\304\276\302\230\362\374\332\276\352\360\343\217\376\363\363\363\365\302\346\200\205\314\300\200\364\312\323\200\343\362\345\345\356\304\362\200\341\367\350\301\355\304\372\200\336\272\272\323\343\362\345\200\345\356\304\362\341\367\272\200\272\343\354\341\363\363\240\200\323\343\362\345\345\356\304\200\362\341\367\310\354\303\324\200\322\324\344\374\344\316\354\272\303\276\322\276\270\276\322\267\276\312\276\372")
TOPIC_TEXT(
"\276\312\365\272\362\276\372\276\300\277\212\373\276\326\343\376\363\363\363\200\365\302\346\205\314\300\200\200\364\332\322\345\360\357\362\200\364\240\250\363\354\351\347\200\350\364\354\371\240\357\342\200\363\357\354\345\364\345\251\300\350\301\355\304\351\362\276\252\372\277\256\277\212\277\304\236\343\376\363\363\363\365\302\200\346\205\314\300\200\364\316\200\323\351\355\360\354\345\320\200\341\347\345\304\362\341\367\200\350\301\355\304\316\354\303\325\276\322\277\250\276\322\277\212\270\276\372\277\270\350\362\325\276\372\277\310\277\212\277\274\336\343\376\363\363\363\365\200\302\346\205\314\300\200\364\200\315\320\362\351\356\364\320\200\341\347\345\304\362\341\367\200\350\301\355\304\316\354\303\325\276\322\277\266\276\322\277\212\322\276\372\277\322\312\354\220\303\324\342\324\276\300\374\201\276\300\312\354\303\324\376\222\324\276\334\374\276\334\313\310\354\303\324\276\332\324\276\204\370\374\276\370\313\354\303\262\324\276\366\324\276\224\374\303\276\224\313\354\303\324\276\355\222\324\276\260\374\276\260\260\313\354\303\324\276\260\324\233\276\346\374\276\346\343\362\234\374\366\276\352\276\314\343\217\376\363\363\363\365\302\346\200\205\314\300\200\364\312\323\200\343\362\345\345\356\311\356\200\346\357\350\301\355\304\342\364\362\374\276\322\276\352\276\274\350\343\376\363\363\363\365\200\302\346\205\314\300\200\364\200\310\326\351\345\367\304\362\200\341\367\350\301\355\304\343\364\362\374\276\356\276\352\276\275\204\343\376\363\363\363\365\200\302\346\205\314\300\200\364\200\311\311\355\341\347\345\304\200\362\341\367\350\301\355\304\370\347\362\374\276")
TOPIC_TEXT(
"\212\276\352\373\276\240\343\376\363\363\363\200\365\302\346\205\314\300\200\200\364\315\311\355\341\347\345\200\315\341\363\353\304\362\341\200\367\350\301\355\304\345\362\376\374\276\246\276\352\276\274\236\343\376\363\363\363\365\302\200\346\205\314\300\200\364\313\200\304\362\341\367\351\356\347\200\304\362\341\367\350\301\355\340\304\313\354\303\324\276\344\222\324\277\202\374\277\202\343\374\362\374\276\370\276\352\277\274\216\343\376\363\363\363\365\200\302\346\205\314\300\200\364\200\311\320\362\351\356\364\304\200\362\341\367\350\301\355\304\220\313\354\303\324\277\200\324\211\277\236\374\277\236\360\362\272\374\277\224\276\352\277\252\236\343\376\363\363\363\365\302\200\346\205\314\300\200\364\326\200\320\341\347\345\304\362\341\200\367\240\250\351\356\240\322\200\351\343\350\324\345\370\364\200\251\350\301\355\304\313\354\244\303\324\277\236\324\277\356\302\374\277\356\366\362\374\277\316\344\276\352\277\372\343\376\207\363\363\363\365\302\346\205\200\314\300\200\364\334\320\344\200\346\304\362\341\367\240\250\200\351\356\240\320\344\346\254\200\240\327\351\356\263\262\240\200\357\356\354\371\251\350\301\340\355\304\366\362\374\276\334\357\276\352\276\362\343\376\363\203\363\363\365\302\346\205\314\200\300\200\364\334\327\351\356\200\315\345\364\341\306\351\354\200\345\304\362\341\367\240\250\200\327\351\356\263\262\240\357\200\356\354\371\251\350\301\355\200\304\256&][s0; "
"&][s0; The class encapsulates system`-depen")
TOPIC_TEXT(
"dent internals of graphical output. Whenever you need to paint something in a window, "
"you need a Draw object for it. The standard Paint method of the Ctrl class takes "
"a Draw`& parameter as well. In that case the underlying mechanism passes a Draw which "
"is already initialized for output into the respective control, knows about the current "
"clipping, resolution etc. In a similar manner you can create")
TOPIC_TEXT(
" your own Draw objects to draw onto Images, Drawings (vector metafiles used for "
"serialization of graphical operations) or to perform printer output. You can also "
"use a Draw to query graphics`-related properties of various output devices, like "
"pixel size, resolution, supported color model, available fonts etc.&][s0; &][s0; "
"Although the internals of graphical output are very system`-dependent, the D")
TOPIC_TEXT(
"raw class is designed so as to hide most of the OS`-specific details and present "
"a unified portable interface regardless of the actual target device or object. The "
"downside of this approach is that Draw capabilities are somewhat limited to cover "
"most frequently used graphical objects and attributes. It is quite possible (and "
"in certain situations rather common) that its interface lacks some advanc")
TOPIC_TEXT(
"ed capabilities, although they are supported in the target operating system. For "
"these situations the Draw object supports also methods which allow you to extend "
"its capabilities by utilizing low`-level, system specific code, and accessing the "
"output device at the native system level. Of course, heavy use of such capabilities "
"makes writing portable code very difficult.&][s0;= &][s0; The operations")
TOPIC_TEXT(
" supported by the Draw class can be divided into several categories:&][s0; &][s0;i150;O0; "
"initialization and configuration of the output device&][s0;i150;O0; querying output "
"device properties&][s0;i150;O0; managing colors&][s0;i150;O0; managing text styles&][s0;i150;O0; "
"controlling current clipping region and drawing offset&][s0;i150;O0; drawing basic "
"vector primitives (lines, polygons)&][s0;i150;")
TOPIC_TEXT(
"O0; drawing raster primitives&][s0;i150;O0; drawing text&][s0;i150;O0; accessing "
"[*/ Drawing]`-specific functions&][s0;i150;O0; accessing unified virtual output interface&][s0;i150;O0; "
"accessing the underlying physical output device interface&][s0;i150;O0; accessing "
"device`-secific functions&][s0; &][s0; Initialization and configuration of the output "
"device&][s0;3 &][s4;:`:`:Draw`:`:Draw`(`): [* D")
TOPIC_TEXT(
"raw](HDC_[*@3 hdc])&][s6; Win32`-specific: initializes the Draw object to output "
"on a Window device context (HDC). This is the usual Windows method to paint into "
"windows, on memory`-mapped bitmaps and on the printer.&][s6; [* Note:] it is seldom "
"necessary to construct the Draw object in this way. System`-independent U`+`+ layer "
"hides such system`-specific internals within upper`-level abstract obj")
TOPIC_TEXT(
"ects (PrintDraw, ImageDraw, ViewDraw). Remember that, by directly handling device "
"contexts, you are depraved of a multitude of U`+`+ internal housekeeping chores and "
"checks which ensure that the device context and potentially its attributes are properly "
"allocated and destroyed as necessary. For a complete set of rules for working with "
"device contexts, see Microsoft Windows documentation.&][s1; [*C")
TOPIC_TEXT(
"@3 hdc]-|handle to output device context&][s0;3 &][s4;:`:`:Draw`:`:Draw`(`:`:Draw "
"able`,GC`,XftDraw`*`,const`:`:Vector`<`:`:Rect`>`&`): [* Draw](Drawable_[*@3 dw], "
"GC_[*@3 gc], XftDraw_`*[*@3 xftdraw], const_Vector<Rect>`&_[*@3 clip])&][s6; X11`-specific: "
"initializes the draw object to output on a X`-Windows drawable using a given graphics "
"context (GC). This is the usual X`-Windows method to paint")
TOPIC_TEXT(
" into windows and on memory`-mapped bitmaps.&][s6; [* Note:] it is seldom necessary "
"to construct the Draw object in this way. System`-independent U`+`+ layer hides such "
"system`-specific internals within upper`-level abstract objects (ImageDraw, ViewDraw). "
"Remember that, by directly handling device contexts, you are depraved of a multitude "
"of U`+`+ internal housekeeping chores and checks which ensu")
TOPIC_TEXT(
"re that the device context and potentially its attributes are properly allocated "
"and destroyed as necessary. For a complete set of rules for working with device contexts, "
"see X Windows documentation.&][s1; [*C@3 dw]-|output drawable&][s1; [*C@3 gc]-|output "
"graphic context&][s1; [*C@3 xftdraw]-|XFT interface object&][s1; [*C@3 clip]-|clipping "
"region&][s0;3 &][s4;:`:`:Draw`:`:Draw`(`:`:Draw able`,GC")
TOPIC_TEXT(
"`,const`:`:Vector`<`:`:Rect`>`&`): [* Draw](Drawable_[*@3 dw], GC_[*@3 gc], const_Vector<Rect>`&_[*@3 "
"clip])&][s6; X11`-specific: initializes the draw object to output on a X`-Windows "
"drawable using a given graphics context (GC). This is the usual X`-Windows method "
"to paint into windows and on memory`-mapped bitmaps.&][s6; [* Note:] it is seldom "
"necessary to construct the Draw object in this way. ")
TOPIC_TEXT(
"System`-independent U`+`+ layer hides such system`-specific internals within upper`-level "
"abstract objects (ImageDraw, ViewDraw). Remember that, by directly handling device "
"contexts, you are depraved of a multitude of U`+`+ internal housekeeping chores and "
"checks which ensure that the device context and potentially its attributes are properly "
"allocated and destroyed as necessary. For a complete se")
TOPIC_TEXT(
"t of rules for working with device contexts, see X Windows documentation.&][s1; "
"[*C@3 dw]-|output drawable&][s1; [*C@3 gc]-|output graphic context&][s1; [*C@3 clip]-|clipping "
"region&][s0;3 &][s4;:`:`:Draw`:`:Draw`(Drawable`,GC`,XftDraw`*`,const`:`:Vector`<`:`:Rect`>`&`): "
"void_[* Init]()&][s6; Initializes internal variables for output on a previously set "
"output device.&][s6; [* Note:] this is norma")
TOPIC_TEXT(
"lly not necessary. This function is called only from derived classes which need "
"to set the output device handle (HDC under Win32, GC under X Windows) manually.&][s0;3 "
"&][s4;:`:`:Draw`:`:Init`(const`:`:Vector`<`:`:Rect`>`&`,`:`:Point: void_[* Init](const_Vector<Rect>`&_[*@3 "
"clip], Point_[*@3 offset]_`=_Point([@3 0], [@3 0]))&][s6; X Windows`-specific: initializes "
"Draw internals for output on a prev")
TOPIC_TEXT(
"iously set output device. The parameters give clipping region and output offset "
"to initialize the clipping stack with.&][s1; [*C@3 clip]-|clipping region of the "
"output device (in device coordinates)&][s1; [*C@3 offset]-|initial output offset "
"(device coordinates)&][s0; &][s0; Querying output device properties&][s0;3 &][s4;:`:`:Draw`:`:PaletteMode`(`)const: "
"bool_[* PaletteMode]()_const&][s6; Checks ")
TOPIC_TEXT(
"whether the current output device is palette`-based or RGB`-based. Monochrome devices "
"are treated as RGB`-based.&][s1; [*/ Return value]-|[/ true] `= device uses palette`-based "
"color management, [/ false] `= device pixels contain direct RGB color values.&][s0;3 "
"&][s4;:`:`:Draw`:`:IsMono`(`)const: bool_[* IsMono]()_const&][s6; Check whether the "
"current output device is monochrome.&][s1; [*/ Return ")
TOPIC_TEXT(
"value]-|[/ true] `= monochrome, [/ false] `= grayscale or color device.&][s0;3 &][s4;:`:`:Draw`:`:GetPagePixels`(`)const: "
"Size_[* GetPagePixels]()_const&][s6; Returns pixel page size. For virtual output "
"devices (like Drawings), this is the same as dot page size.&][s1; [*/ Return value]-|Pixel "
"width and height of the output page.&][s0;3 &][s4;:`:`:Draw`:`:GetPageMMs`(`)const: "
"Size_[* GetPageMMs]()_")
TOPIC_TEXT(
"const&][s6; Returns physical output page size in millimeters.&][s1; [*/ Return value]-|Output "
"page width and height in millimeters.&][s0;3 &][s4;:`:`:Draw`:`:GetPixelsPerInch`(`)const: "
"Size_[* GetPixelsPerInch]()_const&][s6; Returns the resolution of the output device.&][s1; "
"[*/ Return value]-|Number of pixels horizontally and vertically across a squared "
"inch.&][s0;3 &][s4;:`:`:Draw`:`:GetSheetPix")
TOPIC_TEXT(
"els`(`)const: Size_[* GetSheetPixels]()_const&][s6; Returns pixel size of the output "
"page including physical margins. This is meaningful only for printers for which the "
"printable area is sometimes smaller than the actual paper size. For such devices "
"[* GetSheetPixels] returns pixel size of the original (full) paper including the "
"margins unsuitable for printing, whereas [* GetPagePixels] returns th")
TOPIC_TEXT(
"e printable area size (paper size minus physically enforced margins).&][s1; [*/ "
"Return value]-|Pixel width and height of the physical output medium (paper in printer)&][s0;3 "
"&][s4;:`:`:Draw`:`:GetPageOffset`(`)const: Point_[* GetPageOffset]()_const&][s6; "
"Returns pixel offset of the topleft corner of the printable output area from the "
"topleft corner of the physical output medium (printer paper). Th")
TOPIC_TEXT(
"is is meaningful only for printers where the printable area is sometimes smaller "
"than the actual paper size (see also [* GetSheetPixels]). By subtracting [* GetPageOffset()] "
"from a pair of coordinates it is possible to position objects absolutely with respect "
"to the paper edges.&][s1; [*/ Return value]-|Horizontal and vertical displacement "
"from the topleft corner of the physical output medium to t")
TOPIC_TEXT(
"he topleft corner of the printable area. &][s0;3 &][s4;:`:`:Draw`:`:Pixels`(`)const: "
"bool_[* Pixels]()_const&][s6; Checks whether the output device coordinates are pixel`-based "
"or dot`-based. This is the negation of the [* Dots()] function. Window and image "
"draws are pixel`-based, whereas printer and Drawing draws are normally dot`-based.&][s1; "
"[*/ Return value]-|[/ true] `= device is pixel`-based")
TOPIC_TEXT(
", [/ false] `= device is dot`-based.&][s0;3 &][s4;:`:`:Draw`:`:Dots`(`)const: bool_[* "
"Dots]()_const&][s6; Checks whether the output device coordinates are pixel`-based "
"or dot`-based. This is the negation of the [* Pixels()] function. Window and image "
"draws are pixel`-based, whereas printer and Drawing draws are normally dot`-based.&][s1; "
"[*/ Return value]-|[/ true] `= device is dot`-based, [/ fals")
TOPIC_TEXT(
"e] `= device is pixel`-based.&][s0;3 &][s4;:`:`:Draw`:`:IsPrinter`(`)const: bool_[* "
"IsPrinter]()_const&][s6; Checks whether the output device is a printer.&][s1; [*/ "
"Return value]-|[/ true] `= device is a printer.&][s0;3 &][s4;:`:`:Draw`:`:IsAborted`(`)const: "
"bool_[* IsAborted]()_const&][s6; Checks whether the output job has been aborted. "
"This is meaningful mainly for printers.&][s1; [*/ Return va")
TOPIC_TEXT(
"lue]-|[/ true] `= job has been aborted.&][s0;3 &][s4;:`:`:Draw`:`:IsBack`(`)const: "
"bool_[* IsBack]()_const&][s6; Checks whether output device supports double`-buffering. "
"For devices with double`-buffering it is not necessary (and is usually counterproductive) "
"to take measures to prevent flickering as the whole output is composed offscreen. "
"Output devices without direct video output (like Drawings ")
TOPIC_TEXT(
"or Images) are return [/ true] (as there is no direct video output, it is not necessary "
"to prevent flickering).&][s1; [*/ Return value]-|[/ true] `= device is double`-buffered, "
"[/ false] `= output goes directly to video&][s0;3 &][s4;:`:`:Draw`:`:IsDrawing`(`)const: "
"bool_[* IsDrawing]()_const&][s6; Checks whether the output device is a Drawing.&][s1; "
"[*/ Return value]-|[/ true] `= device is a Drawi")
TOPIC_TEXT(
"ng.&][s0;3 &][s4;:`:`:Draw`:`:IsMetaFile`(`)const: bool_[* IsMetaFile]()_const&][s6; "
"Win32`-specific: Checks whether the output device is a Windows Metafile.&][s1; [*/ "
"Return value]-|[/ true `= ]device is a Windows Enhanced Metafile.&][s0; &][s0; Managing "
"colors&][s0; &][s0; Different output devices and their technologies pose natural "
"limitations on producing color output. The basic classes of dev")
TOPIC_TEXT(
"ices with respect to their color management are:&][s0; &][s0;i150;O0; Monochrome "
"devices (like monochrome laser printers or certains specialized displays) support "
"no color at all. Every pixel of the output device can be black or white.&][s0;i150;O0; "
"Palette`-based devices (like old 16`- or 256`-color displays) support a fixed set "
"of distinct color slots, called a [/ palette]. Colors of the individ")
TOPIC_TEXT(
"ual slots can be either user`-settable or fixed (system`-set). Every pixel of the "
"output device is an index into the palette.&][s0;i150;O0; RGB`-based devices (HiColor "
"or TrueColor displays), in which every pixel of the output device can be set to any "
"of the colors displayable by the device. Typically each pixel has at least 16 bits "
"comprising of 5`- or 8`-bit subfields for the red, green, and blu")
TOPIC_TEXT(
"e color component.&][s0; &][s0; Logical color model used by the Draw class communicates "
"colors using device`-independent color values (as represented by the [* Color] class). "
"Graphical output functions convert these colors on`-the`-fly to physical colors supported "
"by the system. Pixel`- and line`-oriented output objects (lines, polylines, ellipses) "
"paint the requested objects with the nearest avai")
TOPIC_TEXT(
"lable physical color to the requested logical color, whereas area`- and raster`-oriented "
"output objects (rectangles, polygons, and images) use dithering to approximate logical "
"colors not directly produceable by the device.&][s0; &][s0; Draw supports two ways "
"of using palette`-based output devices:&][s0; &][s0;i150;O0; [* Automatic palette]: "
"upon initialization Draw sets up the system palette to co")
TOPIC_TEXT(
"ntain a matrix of 6x6x6 RGB triplets for all combinations of 6 equidistant intensities "
"of the color components, a 16`-level gray scale plus 16 basic system colors. This "
"fixed color palette enables the system to closely mimic the behaviour of RGB`-based "
"color systems.&][s0;i150;O0; [* User palette]: Draw works with the current palette "
"as set by the system / user. Nearest match is used for logical c")
TOPIC_TEXT(
"olor mapping.&][s0;3 &][s4;:`:`:Draw`:`:AutoPalette`(`): bool_[* AutoPalette]()&][s6; "
"Checks palette mode of the active output device.&][s1; [*/ Return value]-|[* true] "
"`= automatic palette mode, [* false] `= user palette mode&][s0;3 &][s4;:`:`:Draw`:`:SetAutoPalette`(bool`): "
"void_[* SetAutoPalette](bool_[*@3 ap])&][s6; Turns automatic palette mode on or off.&][s1; "
"[*C@3 ap]-|[* true] `= activate ")
TOPIC_TEXT(
"automatic palette, [* false] `= activate user palette mode&][s0;3 &][s4;:`:`:Draw`:`:Win32UpdateSColors`(`): "
"void_[* Win32UpdateSColors]()&][s6; Updates logical palette of basic system`-dependent "
"colors ([* SLtGray], [* SWhite], [* SBlack] etc.).&][s0; &][s0; Managing text styles&][s0;3 "
"&][s4;:`:`:Draw`:`:AddFace`(const LOGFONT`*`,const TEXTMETRIC`*`,`:`:dword`,LPARAM`): "
"FontInfo_[* Acquire](Font_")
TOPIC_TEXT(
"[*@3 font], int_[*@3 angle], int_[*@3 device])&][s6; &][s1; [*C@3 font]-|&][s1; "
"[*C@3 angle]-|&][s1; [*C@3 device]-|&][s1; [*/ Return value]-|&][s0;3 &][s4;:`:`:Draw`:`:SetStdFont`(`:`:Font`): "
"void_[* SetStdFont](Font_[*@3 font])&][s6; Sets the font to be used as the standard "
"font (StdFont, Font`::STDFONT).&][s1; [*C@3 font]-|new standard font&][s0;3 &][s4;:`:`:Draw`:`:GetStdFont`(`): "
"Font_[* GetS")
TOPIC_TEXT(
"tdFont]()&][s6; Returns the current standard font.&][s1; [*/ Return value]-|previously "
"set or system`-default standard font&][s0;3 &][s4;:`:`:Draw`:`:GetStdFontSize`(`): "
"Size_[* GetStdFontSize]()&][s6; Returns the letter box width and height of the current "
"standard font.&][s1; [*/ Return value]-|[/ cx `= GetWidth(), cy `= GetHeight()] of "
"the current standard font. When [/ cx `=`= 0], standard font")
TOPIC_TEXT(
" has default width.&][s0;3 &][s4;:`:`:Draw`:`:GetStdFontCy`(`): int_[* GetStdFontCy]()&][s6; "
"Returns letter box width and height of the current standard font&][s1; [*/ Return "
"value]-|[/ cx `= GetWidth(), cy `= GetHeight()] of the current standard font. When "
"[/ cx `=`= 0], standard font has default width.&][s0;3 &][s4;:`:`:Draw`:`:GetFontInfo`(`:`:byte`,`:`:Font: "
"FontInfo_[* GetFontInfo](byte_[*@3 ")
TOPIC_TEXT(
"charset], Font_[*@3 font]_`=_StdFont())&][s6; Returns font information object describing "
"given font and charset.&][s1; [*C@3 charset]-|character set to use (from the CHARSET`_xxx "
"enumeration)&][s1; [*C@3 font]-|font to retrieve information for.&][s1; [*/ Return "
"value]-|FontInfo structure describing metrics of system`-allocated font for the given "
"font object.&][s0;3 &][s4;:`:`:Draw`:`:GetFontInfo`(")
TOPIC_TEXT(
"`:`:Font: FontInfo_[* GetFontInfo](Font_[*@3 font]_`=_StdFont())&][s6; Returns font "
"information object describing given font.&][s1; [*C@3 font]-|font to retrieve information "
"for.&][s1; [*/ Return value]-|FontInfo structure describing metrics of system`-allocated "
"font for the given Font object.&][s0;3 &][s4;:`:`:Draw`:`:GetFontInfoW`(`:`:Font: "
"FontInfo_[* GetFontInfoW](Font_[*@3 font]_`=_StdFont())")
TOPIC_TEXT(
"&][s6; Returns Unicode font information for a given font.&][s1; [*C@3 font]-|font "
"to retrieve information for.&][s1; [*/ Return value]-|FontInfo structure describing "
"Unicode metrics of system`-allocated font for the given Font object.&][s0; &][s0; "
"Controlling current clipping region and drawing offset&][s0; Sometimes it is necessary "
"or at least handy to move the logical coordinate origin and limit")
TOPIC_TEXT(
" output clipping for a part of the drawing process. For this reason, coordinate "
"origin displacement together with current clipping region is kept as a stack in the "
"Draw object. Certain function push a new offset / clipping entry to the stack, other "
"functions manipulate the current top of stack. Actual coordinate origin and clipping "
"in effect while drawing corresponds to the entry on top of the sta")
TOPIC_TEXT(
"ck. At the beginning the coordinate origin is usually set to topleft corner of the "
"output medium and the clipping box encapsulates all available output area (or, like "
"in case of [* Ctrl`::Paint], the current `\"dirty`\" area that needs to be repainted "
"in a window).&][s0;3 &][s4;:`:`:Draw`:`:Begin`(`): void_[* Begin]()&][s6; Duplicates "
"the current entry on the top of the coordinate / clipping stack. ")
TOPIC_TEXT(
"This effectively doesn`'t change the current coordinate / clipping setting but creates "
"a new entry which can be further manipulated by other methods like [* IntersectClip] "
"or [* ExcludeClip].&][s0;3 &][s4;:`:`:Draw`:`:End`(`): void_[* End]()&][s6; Discards "
"one coordinate / clipping entry from top of the stack.&][s0;3 &][s4;:`:`:Draw`:`:Offset`(`:`:Point`): "
"void_[* Offset](Point_[*@3 p])&][s6; Crea")
TOPIC_TEXT(
"tes a new coordinate / clipping entry on top of the stack equal to the previous "
"entry with coordinate origin shifted by [* p] pixels.&][s1; [*C@3 p]-|number of pixels "
"to add to coordinate origin ([/ p.x_>_0] `= right, [/ p.x_<_0] `= left, [/ p.y_>_0] "
"`= down, [/ p.y_<_0] `= up).&][s0;3 &][s4;:`:`:Draw`:`:Offset`(int`,int`): void_[* "
"Offset](int_[*@3 x], int_[*@3 y])&][s6; Creates a new coordinate /")
TOPIC_TEXT(
" clipping entry on top of the stack equal to the previous entry with coordinate "
"origin shifted by [/ (x, y)] pixels.&][s1; [*C@3 x]-|number of pixels to add to horizontal "
"coordinate origin ([/ x_>_0] `= right, [/ x_<_0] `= left).&][s1; [*C@3 y]-|number "
"of pixels to add to vertical coordinate origin ([/ y_>_0] `= down, [/ y_<_0] `= up).&][s0;3 "
"&][s4;:`:`:Draw`:`:Clip`(const`:`:Rect`&`): bool_[* Cli")
TOPIC_TEXT(
"p](const_Rect`&_[*@3 r])&][s6; Creates a new coordinate / clipping entry on top "
"of the stack with coordinate origin equal to the previous value and clipping equal "
"to the intersection of the previous clipping region with the rectangle [/ r].&][s1; "
"[*C@3 r]-|rectangle to intersect with current clipping region (relative to the current "
"coordinate origin)&][s1; [*/ Return value]-|[/ true] `= the new cl")
TOPIC_TEXT(
"ipping region is non`-empty, [/ false] `= the new clipping is empty (it is not necessary "
"to draw anything as nothing is visible)&][s0;3 &][s4;:`:`:Draw`:`:Clip`(int`,int`,int`,int`): "
"bool_[* Clip](int_[*@3 x], int_[*@3 y], int_[*@3 cx], int_[*@3 cy])&][s6; Creates "
"a new coordinate / clipping entry on top of the stack with coordinate origin equal "
"to the previous value and clipping equal to the inte")
TOPIC_TEXT(
"rsection of the previous clipping region with the rectangle given by its topleft "
"origin (relative to the current coordinate origin) [/ (x, y)], width [/ cx] and height "
"[/ cy].&][s6; &][s1; [*C@3 x]-|left side of rectangle to intersect with current clipping "
"region (relative to current coordinate origin)&][s1; [*C@3 y]-|top side of rectangle "
"to intersect with current clipping region (relative to cur")
TOPIC_TEXT(
"rent coordinate origin)&][s1; [*C@3 cx]-|rectangle width&][s1; [*C@3 cy]-|rectangle "
"height&][s1; [*/ Return value]-|[/ true] `= the new clipping region is non`-empty, "
"[/ false] `= the new clipping is empty (it is not necessary to draw anything as nothing "
"is visible)&][s0;3 &][s4;:`:`:Draw`:`:Clipoff`(const`:`:Rect`&`): bool_[* Clipoff](const_Rect`&_[*@3 "
"r])&][s6; Creates a new coordinate / clippin")
TOPIC_TEXT(
"g entry on top of the stack with clipping equal to the intersection of the previous "
"clipping region with the rectangle [/ r] and with the coordinate origin shifted by "
"[/ r.TopLeft()] pixels. For further drawing operations the current pixel [/ r.TopLeft()] "
"will correspond to [/ (0,_0) ]and [/ r.BottomRight()] to [/ (r.Width(),_r.Height())].&][s1; "
"[*C@3 r]-|rectangle to intersect with current clippi")
TOPIC_TEXT(
"ng region (relative to current coordinate origin); [/ r.left] is added to the horizontal "
"coordinate origin and [/ r.top] to the vertical coordinate origin.&][s1; [*/ Return "
"value]-|[/ true] `= the new clipping region is non`-empty, [/ false] `= the new clipping "
"is empty (it is not necessary to draw anything as nothing is visible)&][s0;3 &][s4;:`:`:Draw`:`:Clipoff`(int`,int`,int`,int`): "
"bool_[* Cli")
TOPIC_TEXT(
"poff](int_[*@3 x], int_[*@3 y], int_[*@3 cx], int_[*@3 cy])&][s6; Creates a new "
"coordinate / clipping entry on top of the stack with clipping equal to the intersection "
"of the previous clipping region with the rectangle [/ r] and with the coordinate "
"origin shifted by [/ (x,_y)] pixels. For further drawing operations the current pixel "
"[/ (x, y)] will correspond to [/ (0,_0)].&][s6; &][s1; [*C@3 x]-|")
TOPIC_TEXT(
"left side of rectangle to intersect with current clipping region (relative to current "
"coordinate origin) and the amount to add to horizontal coordinate origin&][s1; [*C@3 "
"y]-|top side of rectangle to intersect with current clipping region (relative to "
"current coordinate origin) and the amount to add to vertical coordinate origin&][s1; "
"[*C@3 cx]-|rectangle width&][s1; [*C@3 cy]-|rectangle height&][")
TOPIC_TEXT(
"s1; [*/ Return value]-|[/ true] `= the new clipping region is non`-empty, [/ false] "
"`= the new clipping is empty (it is not necessary to draw anything as nothing is "
"visible)&][s0;3 &][s4;:`:`:Draw`:`:ExcludeClip`(const`:`:Rect`&`): bool_[* ExcludeClip](const_Rect`&_[*@3 "
"r])&][s6; Updates the current clipping region on top of the coordinate / clipping "
"stack by subtracting the rectangle [/ r] from t")
TOPIC_TEXT(
"he current clipping region.&][s1; [*C@3 r]-|rectangle to subtract from current clipping "
"region (relative to current coordinate origin)&][s1; [*/ Return value]-|[/ true] "
"`= the new clipping region is non`-empty, [/ false] `= the new clipping is empty "
"(it is not necessary to draw anything as nothing is visible)&][s0;3 &][s4;:`:`:Draw`:`:ExcludeClip`(int`,int`,int`,int`): "
"bool_[* ExcludeClip](int_[*@")
TOPIC_TEXT(
"3 x], int_[*@3 y], int_[*@3 cx], int_[*@3 cy])&][s6; Updates the current clipping "
"region on top of the coordinate / clipping stack by subtracting the rectangle [/ "
"RectC(x,_y,_cx,_cy)] from the current clipping region.&][s1; [*C@3 x]-|left side "
"of rectangle to subtract from current clipping region (relative to current coordinate "
"origin)&][s1; [*C@3 y]-|top side of rectangle to subtract from current")
TOPIC_TEXT(
" clipping region (relative to current coordinate origin)&][s1; [*C@3 cx]-|rectangle "
"width&][s1; [*C@3 cy]-|rectangle height&][s1; [*/ Return value]-|[/ true] `= the "
"new clipping region is non`-empty, [/ false] `= the new clipping is empty (it is "
"not necessary to draw anything as nothing is visible)&][s0;3 &][s4;:`:`:Draw`:`:IntersectClip`(const`:`:Rect`&`): "
"bool_[* IntersectClip](const_Rect`&_[*@3")
TOPIC_TEXT(
" r])&][s6; Updates the current clipping region on top of the coordinate / clipping "
"stack by intersecting the rectangle [/ r] with the current clipping region.&][s1; "
"[*C@3 r]-|rectangle to intersect with current clipping region (relative to current "
"coordinate origin)&][s1; [*/ Return value]-|[/ true] `= the new clipping region is "
"non`-empty, [/ false] `= the new clipping is empty (it is not necessa")
TOPIC_TEXT(
"ry to draw anything as nothing is visible)&][s0;3 &][s4;:`:`:Draw`:`:IntersectClip`(int`,int`,int`,int`): "
"bool_[* IntersectClip](int_[*@3 x], int_[*@3 y], int_[*@3 cx], int_[*@3 cy])&][s6; "
"Updates the current clipping region on top of the coordinate / clipping stack by "
"intersecting the rectangle [/ RectC(x,_y,_cx,_cy)] with the current clipping region.&][s1; "
"[*C@3 x]-|left side of rectangle to int")
TOPIC_TEXT(
"ersect with current clipping region (relative to current coordinate origin)&][s1; "
"[*C@3 y]-|top side of rectangle to intersect with current clipping region (relative "
"to current coordinate origin)&][s1; [*C@3 cx]-|rectangle width&][s1; [*C@3 cy]-|rectangle "
"height&][s1; [*/ Return value]-|[/ true] `= the new clipping region is non`-empty, "
"[/ false] `= the new clipping is empty (it is not necessary t")
TOPIC_TEXT(
"o draw anything as nothing is visible)&][s0;3 &][s4;:`:`:Draw`:`:GetClip`(`)const: "
"Rect_[* GetClip]()_const&][s6; Returns the smallest rectangle fully covering the "
"current clipping region. The value can be used to limit output to the visible area. "
"Take care not to mix the current clipping region with the output rectangle as the "
"clipping region can be just a subset of this output rectangle (like in")
TOPIC_TEXT(
" case of [* Ctrl`::Paint] when a part of the window is obscured).&][s1; [*/ Return "
"value]-|Smallest rectangle fully covering the current clipping region (relative to "
"current coordinate origin)&][s0;3 &][s4;:`:`:Draw`:`:GetOffset`(`)const: Point_[* "
"GetOffset]()_const&][s6; Returns the current coordinate origin. This is naturally "
"in absolute coordinates relative to the topleft corner of the output m")
TOPIC_TEXT(
"edium.&][s1; [*/ Return value]-|Current coordinate origin (relative to topleft corner "
"of the output medium)&][s0;3 &][s4;:`:`:Draw`:`:GetCloffLevel`(`)const: int_[* GetCloffLevel]()_const&][s6; "
"Returns the number of entries on the coordinate / clipping stack. This is normally "
"used for self`-consistency check where the drawing routine ASSERTs that after drawing "
"something the stack depth is the same")
TOPIC_TEXT(
" as it was before (to check whether there is not a stack `'leak`' when the drawing "
"routine forgets to [* End] some coordinate / clipping entries it has previously pushed "
"on the stack).&][s1; [*/ Return value]-|number of entries on the coordinate / clipping "
"stack&][s0;3 &][s4;:`:`:Draw`:`:LPtoDP`(`:`:Point`)const: Point_[* LPtoDP](Point_[*@3 "
"p])_const&][s6; Converts a point from coordinates relativ")
TOPIC_TEXT(
"e to current coordinate origin to absolute coordinates from the topleft corner of "
"the output medium. This effectively adds the current coordinate origin to the given "
"point [/ p].&][s1; [*C@3 p]-|Point to convert (relative to current coordinate origin)&][s1; "
"[*/ Return value]-|Absolute coordinates of point [/ p] from the topleft corner of "
"the output medium&][s0;3 &][s4;:`:`:Draw`:`:DPtoLP`(`:`:Poin")
TOPIC_TEXT(
"t`)const: Point_[* DPtoLP](Point_[*@3 p])_const&][s6; Converts a point from the "
"absolute coordinates (from the topleft corner of the output medium) to coordinates "
"relative to current coordinate origin. This effectively subtracts the current coordinate "
"origin from the point [/ p].&][s1; [*C@3 p]-|Point to convert (absolute coordinates)&][s1; "
"[*/ Return value]-|Relative coordinates of [/ p] with res")
TOPIC_TEXT(
"pect to the current coordinate origin&][s0;3 &][s4;:`:`:Draw`:`:LPtoDP`(const`:`:Rect`&`)const: "
"Rect_[* LPtoDP](const_Rect`&_[*@3 r])_const&][s6; Converts a rectangle from coordinates "
"relative to current coordinate origin to absolute coordinates from the topleft corner "
"of the output medium. This effectively offsets the rectangle [/ r] by the amount "
"given by the current coordinate origin.&][s1; [*C")
TOPIC_TEXT(
"@3 r]-|Rectangle to convert (relative to current coordinate origin)&][s1; [*/ Return "
"value]-|Rectangle [/ r] in absolute coordinates with respect to the topleft corner "
"of the output medium&][s0;3 &][s4;:`:`:Draw`:`:DPtoLP`(const`:`:Rect`&`)const: Rect_[* "
"DPtoLP](const_Rect`&_[*@3 r])_const&][s6; Converts a rectangle from the absolute "
"coordinates (with respect to the topleft corner of the output me")
TOPIC_TEXT(
"dium) to coordinates relative to current coordinate origin. This effectively offsets "
"the rectangle [/ r] by the negative value of the current coordinate origin.&][s1; "
"[*C@3 r]-|Rectangle to convert (absolute coordinates)&][s1; [*/ Return value]-|Rectangle "
"[/ r] in coordinates relative to current coordinate origin&][s0; &][s0; Drawing basic "
"vector primitives (lines, polygons)&][s0;3 &][s4;:`:`:Draw")
TOPIC_TEXT(
"`:`:DrawRect`(int`,int`,int`,int`,`:`:Color`): void_[* DrawRect](int_[*@3 x], int_[*@3 "
"y], int_[*@3 cx], int_[*@3 cy], Color_[*@3 color])&][s6; Fills rectangle [/ RectC(x,_y,_cx,_cy)] "
"with the color [/ color]. On palette`-based devices dithering is sometimes used for "
"approximation when the given color doesn`'t closely correnspond to one of the available "
"colors (see [* Managing colors]).&][s1; [*C@")
TOPIC_TEXT(
"3 x]-|left side to rectangle to fill (relative to coordinate origin)&][s1; [*C@3 "
"y]-|top side of rectangle to fill&][s1; [*C@3 cx]-|rectangle width&][s1; [*C@3 cy]-|rectangle "
"height&][s1; [*C@3 color]-|color used for filling. When [/ color `=`= Null], nothing "
"is done. The special color [* InvertColor()] can be used to logically invert all "
"pixel bits within the given area. This has the effect of ch")
TOPIC_TEXT(
"anging white to black and vice versa and changing color hues to their complements. "
"Note, however, that due to [/ gamma]`-correction, the output image is not a photometrical "
"complement of the original image. &][s0;3 &][s4;:`:`:Draw`:`:DrawRect`(const`:`:Rect`&`,`:`:Color`): "
"void_[* DrawRect](const_Rect`&_[*@3 rect], Color_[*@3 color])&][s6; Fills rectangle "
"[/ rect] with the color [/ color]. On pale")
TOPIC_TEXT(
"tte`-based devices dithering is sometimes used for approximation when the given "
"color doesn`'t closely correnspond to one of the available colors (see [* Managing "
"colors]).&][s1; [*C@3 rect]-|area to fill (relative to coordinate origin)&][s1; [*C@3 "
"color]-|color used for filling. When [/ color `=`= Null], nothing is done. The special "
"color [* InvertColor()] can be used to logically invert all pixe")
TOPIC_TEXT(
"l bits within the given area.&][s0;3 &][s4;:`:`:Draw`:`:DrawLine`(int`,int`,int`,int`,int`,`:`:Color`): "
"void_[* DrawLine](int_[*@3 x1], int_[*@3 y1], int_[*@3 x2], int_[*@3 y2], int_[*@3 "
"width]_`=_[@3 0], Color_[*@3 color]_`=_SBlack)&][s6; Draws a line from the point "
"[/ (x1,_y1)] to [/ (x2,_y2)] with color [/ color]. When [/ width] is positive, solid "
"line [/ width] pixels wide is drawn. When [/ wi")
TOPIC_TEXT(
"dth] is negative, function draws a dashed line 1 pixel wide. [/ width] is then one "
"of the [/ PEN`_...] enumeration constants defining the desired line pattern. The "
"fact that the function doesn`'t support wide dashed lines is a sad limitation of "
"the older Win32 GDI which under Windows 95, 98 and ME doesn`'t support this. When "
"wide dashed lines are needed, it is necessary to generate the segments ma")
TOPIC_TEXT(
"nually and split the line patterns into individual line segments or into polygonal "
"patches (depending on the precision requirements and time issues in given context). "
"Under Win32 GDI the point [/ (x1,_y1)] is not drawn.&][s1; [*C@3 x1, y1]-|line beginning "
"(relative to current coordinate origin)&][s1; [*C@3 x2, y2]-|line end&][s1; [*C@3 "
"width]-|line width or one of the [/ PEN`_] constants for dashe")
TOPIC_TEXT(
"d lines&][s1; [*C@3 color]-|line color. When [/ color `=`= Null], nothing is drawn. "
"On palette`-based devices the nearest palette color is used (no dithering is made).&][s0; "
"&][s0;3 &][s4;:`:`:Draw`:`:enum`{ BEGIN`, OFFSET`, CLIP`, CLIPOFF`, EXCLUDECLIP`, "
"INTERSECTCLIP`, END`, DRAWRECT`, DRAWIMAGE`, DRAWMONOIMAGE`, DRAWDRAWING`, DRAWLINE`, "
"DRAWELLIPSE`, DRAWTEXT`, DRAWARC`, DRAWPOLYPOLYLINE`}:* en")
TOPIC_TEXT(
"um `{ PEN`_NULL, PEN`_SOLID, PEN`_DASH, PEN`_DOT, PEN`_DASHDOT, PEN`_DASHDOTDOT "
"`}&][s6; &][s1; [%00-00*C@3 PEN`_NULL]-|empty pen (nothing is drawn)&][s1; [%00-00*C@3 "
"PEN`_SOLID]-|solid pen&][s1; [%00-00*C@3 PEN`_DASH]-|dashed pen `- `- `-&][s1; [%00-00*C@3 "
"PEN`_DOT]-|dotted pen (dashes are shorter) . . .&][s1; [%00-00*C@3 PEN`_DASHDOT]-|dash "
"`- dot `- dash `- dot pattern&][s1; [%00-00*C@3 PEN`_DA")
TOPIC_TEXT(
"SHDOTDOT]-|dash `- dot `- dot `- dash `- dot `- dot pattern&][s0; &][s0;3 &][s4;:`:`:Draw`:`:DrawLine`(`:`:Point`,`:`:Point`,int`,`:`:Color`): "
"void_[* DrawLine](Point_[*@3 p1], Point_[*@3 p2], int_[*@3 width]_`=_[@3 0], Color_[*@3 "
"color]_`=_SBlack)&][s6; Draws a line from the point [/ p1] to [/ p2] with color [/ "
"color]. [/ width] gives line width (positive) or dash pattern (negative). Under Win32 ")
TOPIC_TEXT(
"GDI the point [/ (x1,_y1)] is not drawn.&][s6; &][s1; [*C@3 p1]-|line beginning "
"(relative to coordinate origin)&][s1; [*C@3 p2]-|line end&][s1; [*C@3 width]-|line "
"width or dash pattern&][s1; [*C@3 color]-|line color&][s0;3 &][s4;:`:`:Draw`:`:DrawEllipse`(const`:`:Rect`&`,`:`:Color`,int`,`:`:Color`): "
"void_[* DrawEllipse](const_Rect`&_[*@3 r], Color_[*@3 color]_`=_SBlack, int_[*@3 "
"pen]_`=_Null, Colo")
TOPIC_TEXT(
"r_[*@3 pencolor]_`=_SBlack)&][s6; Draws the largest ellipse with both axes parallel "
"to coordinate axes fully within rectangle [/ r], i.e. with center point at [/ r.CenterPoint()], "
"semi major axis and semi minor axis equal to [/ r.Width() / 2] and [/ r.Height() "
"/ 2].&][s1; [*C@3 r]-|ellipse`'s bounding rectangle&][s1; [*C@3 color]-|color to "
"fill the ellipse inside with ([/ Null] `= no filling)&][s1")
TOPIC_TEXT(
"; [*C@3 pen]-|pen width / dash style to used for drawing the ellipse circumference&][s1; "
"[*C@3 pencolor]-|pen color for drawing the ellipse circumference ([/ Null] `= circumference "
"is not drawn)&][s0;3 &][s4;:`:`:Draw`:`:DrawEllipse`(int`,int`,int`,int`,`:`:Color`,int`,`:`:Color`): "
"void_[* DrawEllipse](int_[*@3 x], int_[*@3 y], int_[*@3 cx], int_[*@3 cy], Color_[*@3 "
"color]_`=_SBlack, int_[*@3 pen]")
TOPIC_TEXT(
"_`=_Null, Color_[*@3 pencolor]_`=_SBlack)&][s6; Draws the largest ellipse with both "
"axes parallel to coordinate axes fully within rectangle [/ RectC(x, y, cx, cy)], "
"i.e. with center point at [/ x_`+_cx_/_2] and [/ y_`+_cy_/_2], semi major axis and "
"semi minor axis equal to [/ cx / 2] and [/ cy / 2].&][s6; &][s1; [*C@3 x]-|left side "
"of ellipse`'s bounding rectangle&][s1; [*C@3 y]-|top side of ellips")
TOPIC_TEXT(
"e`'s bounding rectangle&][s1; [*C@3 cx]-|rectangle width&][s1; [*C@3 cy]-|rectangle "
"height&][s1; [*C@3 color]-|color to fill ellipse inside with ([/ Null] `= interior "
"is not filled)&][s1; [*C@3 pen]-|pen width / dash style for drawing ellipse circumference&][s1; "
"[*C@3 pencolor]-|pen color for drawing ellipse circumference ([/ Null] `= not drawn)&][s0;3 "
"&][s4;:`:`:Draw`:`:DrawArc`(const`:`:Rect`&`,")
TOPIC_TEXT(
"`:`:Point`,`:`:Point`,int`,`:`:Color`): void_[* DrawArc](const_Rect`&_[*@3 rc], "
"Point_[*@3 start], Point_[*@3 end], int_[*@3 width]_`=_[@3 0], Color_[*@3 color]_`=_SBlack)&][s6; "
"Draws elliptic arc corresponding to the largest ellipse fully within the rectangle "
"[/ rc] and running counterclockwise from the direction corresponding to the line "
"connecting the centre of the ellipse ([/ rc.CenterPoint()]")
TOPIC_TEXT(
") with the point [/ start] and ending at direction of the point [/ end] from the "
"ellipse centre. When [/ start `=`= end], the full ellipse is drawn.&][s1; [*C@3 rc]-|ellipse`'s "
"bounding rectangle&][s1; [*C@3 start]-|direction at which to start the arc&][s1; "
"[*C@3 end]-|direction of arc end (from the ellipsec centre)&][s1; [*C@3 width]-|pen "
"width or dash style&][s1; [*C@3 color]-|color to used for ")
TOPIC_TEXT(
"drawing. On palette`-based devices the nearest palette color is used (no dithering).&][s0;3 "
"&][s4;:`:`:Draw`:`:DrawPolyPolyline`(const`:`:Point`*`,int`,const int`*`,int`,int`,`:`:Color`,`:`:Color`): "
"void_[* DrawPolyPolyline](const_Point_`*[*@3 vertices], int_[*@3 vertex`_count], "
"const_int_`*[*@3 counts], int_[*@3 count`_count], int_[*@3 width]_`=_[@3 0], Color_[*@3 "
"color]_`=_SBlack, Color_[*@3 dox")
TOPIC_TEXT(
"or]_`=_Null)&][s6; Draws a series of polylines. Polyline vertices are kept in the "
"array [/ vertices]. The parameter [/ vertext`_count] gives the total number of vertices "
"of all polylines in the array. The array [/ counts] gives numbers of points defining "
"the individual polylines and [/ count`_count] gives number of entries in this array "
"(i.e. the number of connected polylines). The first polyline ")
TOPIC_TEXT(
"comprises vertices [/ vertices`[0`], vertices`[1`]] ... [/ vertices`[counts`[0`] "
"`- 1`]], the second polyline [/ vertices`[counts`[0`]`], vertices`[counts`[0`] `+ "
"1`] ... vertices`[counts`[0`] `+ counts`[1`] `- 1`]], etc.&][s1; [*C@3 vertices]-|array "
"of polyline vertices (relative to coordinate origin)&][s1; [*C@3 vertex`_count]-|total "
"number of vertices of all polylines&][s1; [*C@3 counts]-|array")
TOPIC_TEXT(
" of polyline vertex counts&][s1; [*C@3 count`_count]-|number of entries in the [/ "
"counts] array, i.e. the number of polylines&][s1; [*C@3 width]-|pen width or dash "
"style.&][s1; [*C@3 color]-|polyline color.&][s1; [*C@3 doxor]-|used to draw a xor`'ed "
"polyline set. Useful for drag `& drop animations where it is needed to draw and undraw "
"the rubber rectangle or line repeatedly without having to repai")
TOPIC_TEXT(
"nt the whole display image. When set to non`-[/ Null] value, it gives the `'background`' "
"color on which polyline pixels will have color [/ color] after xoring.&][s0;3 &][s4;:`:`:Draw`:`:DrawPolyPolyline`(const`:`:Vector`<`:`:Point`>`&`,const`:`:Vector`<int`>`&`,int`,`:`:Color`,`:`:Color`): "
"void_[* DrawPolyPolyline](const_Vector<Point>`&_[*@3 vertices], const_Vector<int>`&_[*@3 "
"counts], int_[*@3 wi")
TOPIC_TEXT(
"dth]_`=_[@3 0], Color_[*@3 color]_`=_SBlack, Color_[*@3 doxor]_`=_Null)&][s6; Draws "
"a series of polylines. Polyline vertices are kept in the array [/ vertices]. The "
"array [/ counts] gives numbers of points defining the individual polylines (i.e. "
"the number of connected polylines is equal to [/ counts.GetCount()]). The first polyline "
"comprises vertices [/ vertices`[0`], vertices`[1`]] ... [/ vertic")
TOPIC_TEXT(
"es`[counts`[0`] `- 1`]], the second polyline [/ vertices`[counts`[0`]`], vertices`[counts`[0`] "
"`+ 1`] ... vertices`[counts`[0`] `+ counts`[1`] `- 1`]], etc.&][s6; &][s1; [*C@3 "
"vertices]-|vertices of all polylines to draw&][s1; [*C@3 counts]-|vertex counts in "
"individual polyline segments&][s1; [*C@3 width]-|pen width / dash style&][s1; [*C@3 "
"color]-|polyline color&][s1; [*C@3 doxor]-|background val")
TOPIC_TEXT(
"ue for xor`'ed drawing ([/ Null] `= draw normally)&][s0;3 &][s4;:`:`:Draw`:`:DrawPolyline`(const`:`:Point`*`,int`,int`,`:`:Color`,`:`:Color`): "
"void_[* DrawPolyline](const_Point_`*[*@3 vertices], int_[*@3 count], int_[*@3 width]_`=_[@3 "
"0], Color_[*@3 color]_`=_SBlack, Color_[*@3 doxor]_`=_Null)&][s6; Draws a single "
"polyline connecting all [/ count] [/ vertices].&][s1; [*C@3 vertices]-|Polyline vert")
TOPIC_TEXT(
"ices&][s1; [*C@3 count]-|number of vertices&][s1; [*C@3 width]-|pen width / dash "
"style&][s1; [*C@3 color]-|polyline color&][s1; [*C@3 doxor]-|background value for "
"xor`'ed drawing ([/ Null] `= draw normally)&][s0;3 &][s4;:`:`:Draw`:`:DrawPolyline`(const`:`:Vector`<`:`:Point`>`&`,int`,`:`:Color`,`:`:Color`): "
"void_[* DrawPolyline](const_Vector<Point>`&_[*@3 vertices], int_[*@3 width]_`=_[@3 "
"0], Color")
TOPIC_TEXT(
"_[*@3 color]_`=_SBlack, Color_[*@3 doxor]_`=_Null)&][s6; Draws a single polyline "
"connecting all [/ vertices].&][s1; [*C@3 vertices]-|polyline vertices&][s1; [*C@3 "
"width]-|pen width / dash style&][s1; [*C@3 color]-|polyline color&][s1; [*C@3 doxor]-|background "
"value for xor`'ed drawing ([/ Null] `= draw normally)&][s0;3 &][s4;:`:`:Draw`:`:DrawPolyPolyPolygon`(const`:`:Point`*`,int`,const "
"int`*`,int")
TOPIC_TEXT(
"`,const int`*`,int`,`:`:Color`,int`,`:`:Color`,`:`:Image`,`:`:Color`): void_[* DrawPolyPolyPolygon](const_Point_`*[*@3 "
"vertices], int_[*@3 vertex`_count], const_int_`*[*@3 subpolygon`_counts], int_[*@3 "
"subpolygon`_count`_count], const_int_`*[*@3 disjunct`_polygon`_counts], int_[*@3 "
"disjunct`_polygon`_count`_count], Color_[*@3 color]_`=_Black, int_[*@3 width]_`=_[@3 "
"0], Color_[*@3 outline]_`=_Null,")
TOPIC_TEXT(
" Image_[*@3 image]_`=_Null, Color_[*@3 doxor]_`=_Null)&][s6; Draws a series of complex "
"polygons (i.e. polygons which may contain holes). The [/ vertices] array holds all "
"polygon defining vertices. The array is divided into sections corresponding to the "
"whole complex polygons (parameters [/ disjunct`_polygon`_counts] and [/ disjunct`_polygon`_count`_count]) "
"and these sections are further divided in")
TOPIC_TEXT(
"to the individual polygons defining one complex polygon (i.e. outer boundary and "
"holes). Numbers of vertices in the individual polygons are held in the array [/ subpolygon`_counts] "
"(total number of simple polygons `= [/ subpolygon`_count`_count]).&][s1; [*C@3 vertices]-|all "
"polygon vertices&][s1; [*C@3 vertex`_count]-|number of polygon vertices&][s1; [*C@3 "
"subpolygon`_counts]-|vertex counts in ind")
TOPIC_TEXT(
"ividual simple polygons&][s1;/ [*/C@3 subpolygon`_count`_count][/ -|number of entries "
"in ]subpolygon`_counts&][s1; [*C@3 disjunct`_polygon`_counts]-|vertex counts of the "
"whole complex polygons&][s1;/ [*/C@3 disjunct`_polygon`_count`_count][/ -|number "
"of ]disjunct`_polygon`_counts&][s1; [*C@3 color]-|polygon fill color ([/ Null] `= "
"no fill)&][s1; [*C@3 width]-|pen width / dash style to draw polygon")
TOPIC_TEXT(
" boundary with&][s1; [*C@3 outline]-|pen color for drawing polygon boundary ([/ "
"Null] `= no boundary)&][s1; [*C@3 image]-|pattern for filling polygon interior. Due "
"to Win32 GDI limitations [/ image] must be 8 pixels wide and high.&][s1; [*C@3 doxor]-|Background "
"color for xor`'ed drawing.&][s0; &][s0; Drawing raster primitives&][s0; &][s0; Ultimate`+`+ "
"supports two different kinds of bitmaps: clien")
TOPIC_TEXT(
"t (physical) and server (logical) bitmaps. Client, or physical bitmaps are actual "
"bit arrays defining color contents of a rectangular area with a defined pixel and "
"color resolution. Their bits can be programmatically manipulated, which is handy "
"to execute customized transforms or drawing operations. On the other hand, server "
"bitmaps are allocated using system API and then manipulated using standar")
TOPIC_TEXT(
"d GDI operations. This allows the programmer to utilize a rich set of GDI drawing "
"operations, but with the drawback of being unable to manipulate the bitmap pixels "
"directly.&][s0; &][s0; In the [* Draw] package, the client (physical) bitmaps are "
"represented by the objects [* PixelArray] and [* AlphaArray] (for images without "
"and with a mask channel, respectively). Server bitmaps are represented by")
TOPIC_TEXT(
" the class [* Image]. Images and Pixel/AlphaArrays can be converted to one another "
"(and indeed they are even within the Image implementation itself), but this conversion "
"process can be time consuming and sometimes lossy (depending on the color resolution "
"of the bitmaps being converted). Remember also, that whereas under Microsoft Windows "
"series the client and server usually resides on the same mac")
TOPIC_TEXT(
"hine and transport times are negligible, X servers under Linux natively support "
"running the server on a different machine than the client, which imposes serious "
"limitations on the bandwidth of the client`-server channel.&][s0; &][s0; To sum it "
"all up, Pixel/AlphaArrays are more low`-level image objects, ideal for situations "
"when you intend to do most of the drawing, image conversion or filtering y")
TOPIC_TEXT(
"ourself (perhaps using specialized graphical output routines, as is usual e.g. in "
"certain types of computer games). On the other hand, Images are less well suited "
"to direct pixel`-wise manipulation, but support a plentiful supply of standard graphical "
"operations (ranging from clipping, linear and polygonal objects to drawing text or "
"playing back Windows Metafiles). The standard Draw interface supp")
TOPIC_TEXT(
"orts only Images (which in U`+`+ applications are often used for icons).&][s0;3 "
"&][s4;:`:`:Draw`:`:DrawImage`(const`:`:Rect`&`,const`:`:Image`&`,const`:`:Rect`&`,int`): "
"void_[* DrawImage](const_Rect`&_[*@3 rect], const_Image`&_[*@3 img], const_Rect`&_[*@3 "
"src], int_[*@3 fx]_`=_[@3 0])&][s6; Draws a portion of the image [/ img] (as defined "
"by the source rectangle [/ src], given in image coordinates")
TOPIC_TEXT(
") into the rectangle [/ rect ](relative to current coordinate origin).&][s1; [*C@3 "
"rect]-|Destination (output) rectangle (relative to current origin)&][s1; [*C@3 img]-|Image "
"to draw at the specified location.&][s1; [*C@3 src]-|Source rectangle (part of the "
"image to paint).&][s1; [*C@3 fx]-|Special drawing effects.&][s0; &][s0; Currently, "
"the following drawing effects are defined:&][s0;3 &][s4;:`:`")
TOPIC_TEXT(
":Image`:`:enum`{ EFFECT`_MASK`, STANDARD`, GRAYED`, ETCHED`, XOR`}: [%00-00 enum_`{_][%00-00*@3 "
"EFFECT`_MASK][%00-00 , ][%00-00*@3 STANDARD][%00-00 , ][%00-00*@3 GRAYED][%00-00 "
", ][%00-00*@3 ETCHED][%00-00 , ][%00-00*@3 XOR][%00-00 _`}]&][s6; &][s1; [%00-00*C@3 "
"EFFECT`_MASK]-|bit mask covering all values of supported drawing effects&][s1; [%00-00*C@3 "
"STANDARD]-|Displays the image with its usual co")
TOPIC_TEXT(
"lors.&][s1; [%00-00*C@3 GRAYED]-|Draws a grayed image, i.e. discards color information.&][s1; "
"[%00-00*C@3 ETCHED]-|Draws an `'etched`' image outline (used e.g. in toolbars to "
"mark `'disabled`' buttons).&][s1; [%00-00*C@3 XOR]-|Draws the image using the XOR "
"bitwise operator. This is sometimes used for drag `& drop where, during dragging, "
"the desired image is being repeatedly displayed and removed u")
TOPIC_TEXT(
"sing the same logical operation.&][s0; &][s0;3 &][s4;:`:`:Draw`:`:DrawImage`(const`:`:Rect`&`,const`:`:Image`&`,int`): "
"void_[* DrawImage](const_Rect`&_[*@3 rect], const_Image`&_[*@3 img], int_[*@3 fx]_`=_[@3 "
"0])&][s6; Draws the whole image [/ img] into the rectangle [/ rect] relative to current "
"coordinate origin.&][s1; [*C@3 rect]-|Destination (output) rectangle (relative to "
"current origin)&][s1; ")
TOPIC_TEXT(
"[*C@3 img]-|Image to draw at the specified location.&][s1; [*C@3 fx]-|Special drawing "
"effects (see above).&][s0;3 &][s4;:`:`:Draw`:`:DrawImage`(int`,int`,int`,int`,const`:`:Image`&`,int`): "
"void_[* DrawImage](int_[*@3 x], int_[*@3 y], int_[*@3 cx], int_[*@3 cy], const_Image`&_[*@3 "
"img], int_[*@3 fx]_`=_[@3 0])&][s6; Draws the whole image [/ img] into the rectangle "
"RectC(x, y, cx, cy) relative to cu")
TOPIC_TEXT(
"rrent coordinate origin.&][s1; [*C@3 x]-|left side of output rectangle&][s1; [*C@3 "
"y]-|top side of output rectangle&][s1; [*C@3 cx]-|rectangle width&][s1; [*C@3 cy]-|rectangle "
"height&][s1; [*C@3 img]-|image to draw&][s1; [*C@3 fx]-|drawing effects (see above).&][s0;3 "
"&][s4;:`:`:Draw`:`:DrawImage`(int`,int`,const`:`:Image`&`,int`): void_[* DrawImage](int_[*@3 "
"x], int_[*@3 y], const_Image`&_[*@3 img")
TOPIC_TEXT(
"], int_[*@3 fx]_`=_[@3 0])&][s6; Draws the image [/ img] in its original size at "
"the position `[[/ x], [/ y]`]. &][s1; [*C@3 x]-|left side of output rectangle&][s1; "
"[*C@3 y]-|top side of output rectangle&][s1; [*C@3 img]-|image to draw&][s1; [*C@3 "
"fx]-|drawing effects (see above)&][s0;3 &][s4;:`:`:Draw`:`:DrawImage`(const`:`:Rect`&`,const`:`:Image`&`,const`:`:Rect`&`,`:`:Color`,`:`:Color`,`:`:Colo")
TOPIC_TEXT(
"r`): void_[* DrawImage](const_Rect`&_[*@3 rect], const_Image`&_[*@3 img], const_Rect`&_[*@3 "
"src], Color_[*@3 fore], Color_[*@3 back]_`=_Null, Color_[*@3 doxor]_`=_Null)&][s6; "
"Draws a portion of the image mask [/ img] (as defined by the [/ src] rectangle in "
"image mask coordinate system) into the rectangle [/ rect ](relative to current coordinate "
"origin) using foreground (`'black`') color [/ fore] a")
TOPIC_TEXT(
"nd background color [/ back]. When either [/ fore] or [/ back] is null, the respective "
"mask bit (`'black`' / `'white`') is not painted (the image then acts like an ordinary "
"mask).&][s6; &][s1; [*C@3 rect]-|output rectangle (relative to coordinate origin)&][s1; "
"[*C@3 img]-|image to draw&][s1; [*C@3 src]-|portion of image to draw (image coordinates)&][s1; "
"[*C@3 fore]-|foreground (black) color&][s1; ")
TOPIC_TEXT(
"[*C@3 back]-|background (white) color&][s1; [*C@3 doxor]-|background color for xor`'ed "
"drawing.&][s0; &][s0;l288; When you want to draw the image using the XOR bit operator, "
"set [/ doxor] to a not`-null value. In such case [/ doxor] is assumed to contain "
"the overall background color (the color, on top of which any `'xor`'`-ed color will "
"look unchanged).&][s0;3 &][s4;:`:`:Draw`:`:DrawImage`(const`:")
TOPIC_TEXT(
"`:Rect`&`,const`:`:Image`&`,`:`:Color`,`:`:Color`,`:`:Color`): void_[* DrawImage](const_Rect`&_[*@3 "
"rect], const_Image`&_[*@3 img], Color_[*@3 fore], Color_[*@3 back]_`=_Null, Color_[*@3 "
"doxor]_`=_Null)&][s6; Draws the image mask [/ img ]into the rectangle [/ rect ](relative "
"to current coordinate origin) using foreground (`'black`') color [/ fore] and background "
"color [/ back]. When either [/ fore")
TOPIC_TEXT(
"] or [/ back] is null, the respective mask bit (`'black`' / `'white`') is not painted "
"(the image then acts like an ordinary mask).&][s6; &][s1; [*C@3 rect]-|output rectangle "
"(relative to coordinate origin)&][s1; [*C@3 img]-|image to draw&][s1; [*C@3 fore]-|foreground "
"(black) color, Null `= do not paint foreground&][s1; [*C@3 back]-|background (white) "
"color, Null `= do not paint background&][s1; [*")
TOPIC_TEXT(
"C@3 doxor]-|background color for xor`'ed drawing&][s0; &][s0;l288; When you want "
"to draw the image using the XOR bit operator, set [/ doxor] to a not`-null value. "
"In such case [/ doxor] is assumed to contain the overall background color (the color, "
"on top of which any `'xor`'`-ed color will look unchanged).&][s0;3 &][s4;:`:`:Draw`:`:DrawImage`(int`,int`,int`,int`,const`:`:Image`&`,`:`:Color`,`:`:C")
TOPIC_TEXT(
"olor`,`:`:Color`): void_[* DrawImage](int_[*@3 x], int_[*@3 y], int_[*@3 cx], int_[*@3 "
"cy], const_Image`&_[*@3 img], Color_[*@3 fore], Color_[*@3 back]_`=_Null, Color_[*@3 "
"doxor]_`=_Null)&][s6; Draws the image mask [/ img ]into the rectangle [/ RectC(x, "
"y, cx, cy) ](relative to current coordinate origin) using foreground (`'black`') "
"color [/ fore] and background color [/ back]. When either [/ fore")
TOPIC_TEXT(
"] or [/ back] is null, the respective mask bit (`'black`' / `'white`') is not painted "
"(the image then acts like an ordinary mask).&][s6; &][s1; [*C@3 x]-|left side of "
"output rectangle&][s1; [*C@3 y]-|top side of output rectangle&][s1; [*C@3 cx]-|rectangle "
"width&][s1; [*C@3 cy]-|rectangle height&][s1; [*C@3 img]-|image to draw&][s1; [*C@3 "
"fore]-|foreground (black) color, Null `= do not paint foregr")
TOPIC_TEXT(
"ound&][s1; [*C@3 back]-|background (white) color, Null `= do not paint background&][s1; "
"[*C@3 doxor]-|background color for xor`'ed drawing&][s0;3 &][s4;:`:`:Draw`:`:DrawImage`(int`,int`,const`:`:Image`&`,`:`:Color`,`:`:Color`,`:`:Color`): "
"void_[* DrawImage](int_[*@3 x], int_[*@3 y], const_Image`&_[*@3 img], Color_[*@3 "
"fore], Color_[*@3 back]_`=_Null, Color_[*@3 doxor]_`=_Null)&][s6; Draws the imag")
TOPIC_TEXT(
"e mask [/ img ]at the coordinates [/ `[x, y`]] (relative to current coordinate origin) "
"in its natural pixel size using foreground (`'black`') color [/ fore] and background "
"(`'white`') color [/ back]. When either [/ fore] or [/ back] is null, the respective "
"mask bit (`'black`' / `'white`') is not painted (the image then acts like an ordinary "
"mask).&][s6; &][s1; [*C@3 x]-|left side of image&][s1; [*")
TOPIC_TEXT(
"C@3 y]-|top side of image&][s1; [*C@3 img]-|image to draw&][s1; [*C@3 fore]-|foreground "
"(black) color, Null `= do not paint foreground&][s1; [*C@3 back]-|background (white) "
"color, Null `= do not paint background&][s1; [*C@3 doxor]-|background color for xor`'ed "
"drawing&][s0; &][s0; Drawing text&][s0;3 &][s4;:`:`:Draw`:`:GetTextSize`(const`:`:wchar`*`,`:`:Font: "
"Size_[* GetTextSize](const_wchar_`*[*@")
TOPIC_TEXT(
"3 text], Font_[*@3 font]_`=_StdFont(), int_[*@3 n]_`=_`-[@3 1])&][s6; Measures width "
"and height of a Unicode text (as when painted using given font).&][s1; [*C@3 text]-|Unicode "
"text to measure&][s1; [*C@3 font]-|font to use for the metrics measurements&][s1; "
"[*C@3 n]-|number of letters in the array [/ text]. When [/ n < 0], [/ text] length "
"is counted using [/ wcslen].&][s1; [*/ Return value]-|[/ c")
TOPIC_TEXT(
"x `=] output text pixel width[/ , cy `= ]line height of given font&][s0;3 &][s4;:`:`:Draw`:`:DrawText`(int`,int`,int`,const`:`:wchar`*`,`:`:Font: "
"void_[* DrawText](int_[*@3 x], int_[*@3 y], int_[*@3 angle], const_wchar_`*[*@3 text], "
"Font_[*@3 font]_`=_StdFont(), Color_[*@3 ink]_`=_SBlack, int_[*@3 n]_`=_`-[@3 1], "
"const_int_`*[*@3 dx]_`=_NULL)&][s6; Draws text on the output device.&][s6; [* Note:] ")
TOPIC_TEXT(
"when working with rotated texts, always remember that [/ `[x, y`]] define the topleft "
"corner of the text box. Box size is that returned by the function [/ GetTextSize]. "
"In case of rotated texts, the text box is naturally not aligned with the coordinate "
"axes. Also, some system fonts do not support rotation (bitmap fonts). Unfortunately "
"there is currently no reliable way to detect if a font supports")
TOPIC_TEXT(
" rotation. FontInfo`::IsScaleable should provide a good guess as to whether a given "
"font supports rotation.&][s1; [*C@3 x]-|x coordinate of the topleft corner of the "
"text box&][s1; [*C@3 y]-|y coordinate of the topleft corner of the text box&][s1; "
"[*C@3 angle]-|angle for the text in tenths of degrees (full circle `= 3600). 0 `= "
"to the right (normal text orientation), 900 `= upwards, 1800 `= head d")
TOPIC_TEXT(
"own left, 2700 downwards. &][s1; [*C@3 text]-|Unicode text to draw&][s1; [*C@3 font]-|font "
"to use for drawing text&][s1; [*C@3 ink]-|text color; the text is always drawn as "
"transparent. To set the background under the text to a given color, you must first "
"measure the text size using [/ GetTextSize] and then call [/ DrawRect] to set the "
"text box to a given color. When using rotated text ([/ angle !")
TOPIC_TEXT(
"`= 0]) the situation is naturally much more complicated and a [/ DrawPolygon] would "
"be needed to clear the rotated text box.&][s1; [*C@3 n]-|number of letters in the "
"array [/ text]. When [/ n < 0], [/ text] length is counted using [/ wcslen].&][s1; "
"[*C@3 dx]-|array of letter widths. This can be used to set explicit spacings for "
"the individual letters in the text. When NULL, default letters widths ")
TOPIC_TEXT(
"are used. When not NULL, it must contain (at least) as many entries as are being "
"painted from the given [/ text].&][s0;3 &][s4;:`:`:Draw`:`:DrawText`(int`,int`,const`:`:wchar`*`,`:`:Font: "
"void_[* DrawText](int_[*@3 x], int_[*@3 y], const_wchar_`*[*@3 text], Font_[*@3 font]_`=_StdFont(), "
"Color_[*@3 ink]_`=_SBlack, int_[*@3 n]_`=_`-[@3 1], const_int_`*[*@3 dx]_`=_NULL)&][s6; "
"Draws text on the output")
TOPIC_TEXT(
" device. This is a simplified version of the above function for the most common "
"case when [/ angle `=`= 0] (i.e. the text is being painted in the ordinary direction "
"from left to right).&][s1; [*C@3 x]-|x coordinate of the topleft corner of the text "
"box&][s1; [*C@3 y]-|y coordinate of the topleft corner of the text box&][s1; [*C@3 "
"text]-|Unicode text to draw&][s1; [*C@3 font]-|font to use for drawi")
TOPIC_TEXT(
"ng text&][s1; [*C@3 ink]-|text color; the text is always drawn as transparent. To "
"set the background under the text to a given color, you must first measure the text "
"size using [/ GetTextSize] and then call [/ DrawRect] to set the text box to a given "
"color.&][s1; [*C@3 n]-|number of letters in the array [/ text]. When [/ n < 0], [/ "
"text] length is counted using [/ wcslen].&][s1; [*C@3 dx]-|array o")
TOPIC_TEXT(
"f letter widths. This can be used to set explicit spacings for the individual letters "
"in the text. When NULL, default letters widths are used. When not NULL, it must contain "
"(at least) as many entries as are being painted from the given [/ text].&][s0;3 &][s4;:`:`:Draw`:`:GetTextSize`(const`:`:WString`&`,`:`:Font: "
"Size_[* GetTextSize](const_WString`&_[*@3 text], Font_[*@3 font]_`=_StdFont())&][s6;")
TOPIC_TEXT(
" Measures width and height of a Unicode text (as when painted using given font).&][s1; "
"[*C@3 text]-|text string to measure&][s1; [*C@3 font]-|font to use for metrics measurements&][s1; "
"[*/ Return value]-|[/ cx `= ]text box width, [/ cy `= ] text box height (font ascent "
"`+ descent).&][s0;3 &][s4;:`:`:Draw`:`:DrawText`(int`,int`,const`:`:WString`&`,`:`:Font: "
"void_[* DrawText](int_[*@3 x], int_[*@3 y")
TOPIC_TEXT(
"], const_WString`&_[*@3 text], Font_[*@3 font]_`=_StdFont(), Color_[*@3 ink]_`=_SBlack, "
"const_int_`*[*@3 dx]_`=_NULL)&][s6; Draws text on the output device (from left to "
"right). This is a variation of one of the above function for the case when the input "
"parameter is a WString. In such situation the number of letters is known ([/ text.GetLength()]) "
"and doesn`'t (indeed shoudn`'t) be measured using")
TOPIC_TEXT(
" [/ wcslen].&][s1; [*C@3 x]-|x coordinate of the topleft corner of the text box&][s1; "
"[*C@3 y]-|y coordinate of the topleft corner of the text box&][s1; [*C@3 text]-|Unicode "
"text to draw&][s1; [*C@3 font]-|font to use for drawing text&][s1; [*C@3 ink]-|text "
"color; the text is always drawn as transparent.&][s1; [*C@3 dx]-|array of letter "
"widths. This can be used to set explicit spacings for the ind")
TOPIC_TEXT(
"ividual letters in the text. When NULL, default letters widths are used. When not "
"NULL, it must contain (at least) as many entries as are being painted from the given "
"[/ text].&][s0;3 &][s4;:`:`:Draw`:`:DrawText`(int`,int`,int`,const`:`:WString`&`,`:`:Font: "
"void_[* DrawText](int_[*@3 x], int_[*@3 y], int_[*@3 angle], const_WString`&_[*@3 "
"text], Font_[*@3 font]_`=_StdFont(), Color_[*@3 ink]_`=_SBla")
TOPIC_TEXT(
"ck, const_int_`*[*@3 dx]_`=_NULL)&][s6; Draws text on the output device. A variation "
"of the above function allowing text rotation. See above notes concerning text rotation "
"issues.&][s1; [*C@3 x]-|x coordinate of the topleft corner of the text box&][s1; "
"[*C@3 y]-|y coordinate of the topleft corner of the text box&][s1; [*C@3 angle]-|angle "
"for the text in tenths of degrees (full circle `= 3600). 0 `")
TOPIC_TEXT(
"= to the right (normal text orientation), 900 `= upwards, 1800 `= head down left, "
"2700 downwards. &][s1; [*C@3 text]-|Unicode text to draw&][s1; [*C@3 font]-|font "
"to use for drawing text&][s1; [*C@3 ink]-|text color; the text is always drawn as "
"transparent.&][s1; [*C@3 dx]-|array of letter widths. This can be used to set explicit "
"spacings for the individual letters in the text. When NULL, default ")
TOPIC_TEXT(
"letters widths are used. When not NULL, it must contain (at least) as many entries "
"as are being painted from the given [/ text].&][s0;3 &][s4;:`:`:Draw`:`:GetTextSize`(const "
"char`*`,`:`:byte`,`:`:Font: Size_[* GetTextSize](const_char_`*[*@3 text], byte_[*@3 "
"charset], Font_[*@3 font]_`=_StdFont(), int_[*@3 n]_`=_`-[@3 1])&][s6; Measures text "
"box size for text in given character set.&][s1; [*C@3 tex")
TOPIC_TEXT(
"t]-|text to measure&][s1; [*C@3 charset]-|text character set&][s1; [*C@3 font]-|font "
"to use for the metrics measurements&][s1; [*C@3 n]-|number of letters in [/ text]. "
"When [/ n < 0], [/ text] length is counted using [/ strlen] (or [/ utf8len], when "
"[/ charset `=`= CHARSET`_UTF8]).&][s1; [*/ Return value]-|&][s0;3 &][s4;:`:`:Draw`:`:DrawText`(int`,int`,int`,const "
"char`*`,`:`:byte`,`:`:Font: void_[")
TOPIC_TEXT(
"* DrawText](int_[*@3 x], int_[*@3 y], int_[*@3 angle], const_char_`*[*@3 text], "
"byte_[*@3 charset], Font_[*@3 font]_`=_StdFont(), Color_[*@3 ink]_`=_SBlack, int_[*@3 "
"n]_`=_`-[@3 1], const_int_`*[*@3 dx]_`=_NULL)&][s6; Draw given text in a given character "
"set to the ouput device. This variant allows text rotation.&][s1; [*C@3 x]-|x coordinate "
"of the topleft corner of the text box&][s1; [*C@3 y]-|y ")
TOPIC_TEXT(
"coordinate of the topleft corner of the text box&][s1; [*C@3 angle]-|angle for the "
"text in tenths of degrees (full circle `= 3600). 0 `= to the right (normal text orientation), "
"900 `= upwards, 1800 `= head down left, 2700 downwards. &][s1; [*C@3 text]-|text "
"to draw&][s1; [*C@3 charset]-|output text character set (from the CHARSET`_xxx enumeration)&][s1; "
"[*C@3 font]-|font to use for drawing text&][")
TOPIC_TEXT(
"s1; [*C@3 ink]-|text color; the text is always drawn as transparent.&][s1; [*C@3 "
"n]-|number of letters in [/ text]. When [/ n < 0], [/ text] length is counted using "
"[/ strlen].&][s1; [*C@3 dx]-|array of letter widths. This can be used to set explicit "
"spacings for the individual letters in the text. When NULL, default letters widths "
"are used. When not NULL, it must contain (at least) as many entrie")
TOPIC_TEXT(
"s as are being painted from the given [/ text].&][s0;3 &][s4;:`:`:Draw`:`:DrawText`(int`,int`,const "
"char`*`,`:`:byte`,`:`:Font: void_[* DrawText](int_[*@3 x], int_[*@3 y], const_char_`*[*@3 "
"text], byte_[*@3 charset], Font_[*@3 font]_`=_StdFont(), Color_[*@3 ink]_`=_SBlack, "
"int_[*@3 n]_`=_`-[@3 1], const_int_`*[*@3 dx]_`=_NULL)&][s6; Draws text in given "
"character set to the output device (from left")
TOPIC_TEXT(
" to right).&][s1; [*C@3 x]-|x coordinate of the topleft corner of the text box&][s1; "
"[*C@3 y]-|y coordinate of the topleft corner of the text box&][s1; [*C@3 text]-|text "
"to draw&][s1; [*C@3 charset]-|output text character set (from the CHARSET`_xxx enumeration)&][s1; "
"[*C@3 font]-|font to use for drawing text&][s1; [*C@3 ink]-|text color; the text "
"is always drawn as transparent.&][s1; [*C@3 n]-|num")
TOPIC_TEXT(
"ber of letters in [/ text]. When [/ n < 0], [/ text] length is counted using [/ "
"strlen] (or [/ utf8len], when [/ charset `=`= CHARSET`_UTF8]).&][s1; [*C@3 dx]-|array "
"of letter widths. This can be used to set explicit spacings for the individual letters "
"in the text. When NULL, default letters widths are used. When not NULL, it must contain "
"(at least) as many entries as are being painted from the gi")
TOPIC_TEXT(
"ven [/ text].&][s0;3 &][s4;:`:`:Draw`:`:GetTextSize`(const char`*`,`:`:Font: Size_[* "
"GetTextSize](const_char_`*[*@3 text], Font_[*@3 font]_`=_StdFont(), int_[*@3 n]_`=_`-[@3 "
"1])&][s6; Measures text box size for a text encoded in system`-default character "
"set. &][s1; [*C@3 text]-|text to measure (in default character set, CHARSET`_DEFAULT)&][s1; "
"[*C@3 font]-|font to use for the metrics measurements")
TOPIC_TEXT(
"&][s1; [*C@3 n]-|number of letters in [/ text]. When [/ n < 0], [/ text] length "
"is counted using [/ strlen] (or [/ utf8len], when the default charset is [/ CHARSET`_UTF8]).&][s1; "
"[*/ Return value]-|&][s0;3 &][s4;:`:`:Draw`:`:DrawText`(int`,int`,int`,const char`*`,`:`:Font: "
"void_[* DrawText](int_[*@3 x], int_[*@3 y], int_[*@3 angle], const_char_`*[*@3 text], "
"Font_[*@3 font]_`=_StdFont(), Color_[*@3")
TOPIC_TEXT(
" ink]_`=_SBlack, int_[*@3 n]_`=_`-[@3 1], const_int_`*[*@3 dx]_`=_NULL)&][s6; Draws "
"text encoded in system`-default character set on the output device. This variant "
"allows text rotation.&][s1; [*C@3 x]-|x coordinate of the topleft corner of the text "
"box&][s1; [*C@3 y]-|y coordinate of the topleft corner of the text box&][s1; [*C@3 "
"angle]-|angle for the text in tenths of degrees (full circle `= 360")
TOPIC_TEXT(
"0). 0 `= to the right (normal text orientation), 900 `= upwards, 1800 `= head down "
"left, 2700 downwards. &][s1; [*C@3 text]-|text to draw (in default character set, "
"CHARSET`_DEFAULT)&][s1; [*C@3 font]-|font to use for drawing text&][s1; [*C@3 ink]-|text "
"color; the text is always drawn as transparent.&][s1; [*C@3 n]-|number of letters "
"in [/ text]. When [/ n < 0], [/ text] length is counted using [/")
TOPIC_TEXT(
" strlen] (or [/ utf8len], when the default character set is [/ CHARSET`_UTF8]).&][s1; "
"[*C@3 dx]-|array of letter widths. This can be used to set explicit spacings for "
"the individual letters in the text. When NULL, default letters widths are used. When "
"not NULL, it must contain (at least) as many entries as are being painted from the "
"given [/ text].&][s0;3 &][s4;:`:`:Draw`:`:DrawText`(int`,int`,con")
TOPIC_TEXT(
"st char`*`,`:`:Font: void_[* DrawText](int_[*@3 x], int_[*@3 y], const_char_`*[*@3 "
"text], Font_[*@3 font]_`=_StdFont(), Color_[*@3 ink]_`=_SBlack, int_[*@3 n]_`=_`-[@3 "
"1], const_int_`*[*@3 dx]_`=_NULL)&][s6; Draws text encoded in system`-default character "
"set on the output device (from left to right).&][s1; [*C@3 x]-|x coordinate of the "
"topleft corner of the text box&][s1; [*C@3 y]-|y coordinate o")
TOPIC_TEXT(
"f the topleft corner of the text box&][s1; [*C@3 text]-|text to draw (in default "
"character set, CHARSET`_DEFAULT)&][s1; [*C@3 font]-|font to use for drawing text&][s1; "
"[*C@3 ink]-|text color; the text is always drawn as transparent.&][s1; [*C@3 n]-|number "
"of letters in [/ text]. When [/ n < 0], [/ text] length is counted using [/ strlen] "
"(or [/ utf8len], when the default character set is [/ CHARSE")
TOPIC_TEXT(
"T`_UTF8]).&][s1; [*C@3 dx]-|array of letter widths. This can be used to set explicit "
"spacings for the individual letters in the text. When NULL, default letters widths "
"are used. When not NULL, it must contain (at least) as many entries as are being "
"painted from the given [/ text].&][s0;3 &][s4;:`:`:Draw`:`:GetTextSize`(const`:`:String`&`,`:`:Font: "
"Size_[* GetTextSize](const_String`&_[*@3 text], Fo")
TOPIC_TEXT(
"nt_[*@3 font]_`=_StdFont())&][s6; Measures text size (default character set). This "
"is a variant of the above function for the case when [/ text] i a [/ String] when "
"the text length is known ([/ text.GetLength()]) and it needn`'t and shouldn`'t be "
"measured using [/ strlen]. However, when the current system`-default character set "
"it CHARSET`_UTF8, the text length must still be measured using [/ utf8")
TOPIC_TEXT(
"len] because the number of UTF8 letters can differ from the number of bytes in the "
"string.&][s1; [*C@3 text]-|text to measure (in default character set, CHARSET`_DEFAULT)&][s1; "
"[*C@3 font]-|font to use for the metrics measurements&][s1; [*/ Return value]-|&][s0;3 "
"&][s4;:`:`:Draw`:`:DrawText`(int`,int`,const`:`:String`&`,`:`:Font: void_[* DrawText](int_[*@3 "
"x], int_[*@3 y], const_String`&_[*@3 text")
TOPIC_TEXT(
"], Font_[*@3 font]_`=_StdFont(), Color_[*@3 ink]_`=_SBlack, const_int_`*[*@3 dx]_`=_NULL)&][s6; "
"Draws text encoded in system`-default character set on the output device (from left "
"to right).&][s1; [*C@3 x]-|x coordinate of the topleft corner of the text box&][s1; "
"[*C@3 y]-|y coordinate of the topleft corner of the text box&][s1; [*C@3 text]-|text "
"to draw (in default character set, CHARSET`_DEFAULT")
TOPIC_TEXT(
")&][s1; [*C@3 font]-|font to use for drawing text&][s1; [*C@3 ink]-|text color; "
"the text is always drawn as transparent.&][s1; [*C@3 dx]-|array of letter widths. "
"This can be used to set explicit spacings for the individual letters in the text. "
"When NULL, default letters widths are used. When not NULL, it must contain (at least) "
"as many entries as are being painted from the given [/ text].&][s0;3 &")
TOPIC_TEXT(
"][s4;:`:`:Draw`:`:DrawText`(int`,int`,int`,const`:`:String`&`,`:`:Font: void_[* "
"DrawText](int_[*@3 x], int_[*@3 y], int_[*@3 angle], const_String`&_[*@3 text], Font_[*@3 "
"font]_`=_StdFont(), Color_[*@3 ink]_`=_SBlack, const_int_`*[*@3 dx]_`=_NULL)&][s6; "
"Draws text encoded in system`-default character set on the output device. This variant "
"supports text rotation. See above for notes concerning text ")
TOPIC_TEXT(
"rotation issues.&][s1; [*C@3 x]-|x coordinate of the topleft corner of the text "
"box&][s1; [*C@3 y]-|y coordinate of the topleft corner of the text box&][s1; [*C@3 "
"angle]-|angle for the text in tenths of degrees (full circle `= 3600). 0 `= to the "
"right (normal text orientation), 900 `= upwards, 1800 `= head down left, 2700 downwards. "
"&][s1; [*C@3 text]-|text to draw&][s1; [*C@3 font]-|font to use f")
TOPIC_TEXT(
"or drawing text&][s1; [*C@3 ink]-|text color; the text is always drawn as transparent.&][s1; "
"[*C@3 dx]-|array of letter widths. This can be used to set explicit spacings for "
"the individual letters in the text. When NULL, default letters widths are used. When "
"not NULL, it must contain (at least) as many entries as are being painted from the "
"given [/ text].&][s0;3 &][s4;:`:`:Draw`:`:SinCos`(int`,dou")
TOPIC_TEXT(
"ble`&`,double`&`): void_[* SinCos](int_[*@3 angle], double`&_[*@3 sina], double`&_[*@3 "
"cosa])&][s6; A simple utility function which calculates the sine and cosine of given "
"angle (in tenths of degrees). This function is used internally to calculate metrics "
"of rotated text. &][s1; [*C@3 angle]-|angle in tenths of degrees. 0 `= right, 900 "
"`= up, 1800 `= left, 2700 `= down.&][s1;/ [*/C@3 sina][/ -|sin")
TOPIC_TEXT(
"e of the angle, or ]sin(angle `* 2 `* M`_PI / 3600)&][s1;/ [*/C@3 cosa][/ -|cosine "
"of the angle, or ]cos(angle `* 2 `* M`_PI / 3600)&][s0; &][s0; Accessing [/ Drawing]`-specific "
"functions&][s0;3 &][s4;:`:`:Draw`:`:DrawDrawing`(const`:`:Rect`&`,const`:`:Drawing`&`): "
"void_[* DrawDrawing](const_Rect`&_[*@3 r], const_Drawing`&_[*@3 iw])&][s6; Draws "
"drawing scaled into given rectangle. The coordinate t")
TOPIC_TEXT(
"ransform equations are&][s6; &][s6; x[, out]`=x[, dwg] `* r.Width() / iw.GetSize().cx "
"`+ r.left&][s6; y[, out]`=y[, dwg] `* r.Height() / iw.GetSize().cy `+ r.top&][s6; "
"&][s1; [*C@3 r]-|destination rectangle in logical device units&][s1; [*C@3 iw]-|drawing "
"object to draw&][s0;3 &][s4;:`:`:Draw`:`:DrawDrawing`(int`,int`,int`,int`,const`:`:Drawing`&`): "
"void_[* DrawDrawing](int_[*@3 x], int_[*@3 y], i")
TOPIC_TEXT(
"nt_[*@3 cx], int_[*@3 cy], const_Drawing`&_[*@3 iw])&][s6; Draws drawing scaled "
"into rectangle [* cx] `* [* cy] pixels starting at `[x, y`]. The equations used to "
"scale the drawing are&][s6; &][s6; x[, out]`=x[, dwg] `* cx / iw.GetSize().cx `+ "
"x&][s6; y[, out]`=y[, dwg] `* cy / iw.GetSize().cy `+ y&][s6; &][s1; [*C@3 x]-|left "
"edge of output rectangle&][s1; [*C@3 y]-|top edge of output rectangle&][")
TOPIC_TEXT(
"s1; [*C@3 cx]-|rectangle width&][s1; [*C@3 cy]-|rectangle height&][s1; [*C@3 iw]-|drawing "
"to draw at the specified location&][s0;3 &][s4;:`:`:Draw`:`:DrawingOp`(int`): Stream`&_[* "
"DrawingOp](int_[*@3 code])&][s6; &][s1; [*C@3 code]-|&][s1; [*/ Return value]-|&][s0;3 "
"&][s4;:`:`:Draw`:`:PutRect`(const`:`:Rect`&`): Stream`&_[* PutRect](const_Rect`&_[*@3 "
"r])&][s6; &][s1; [*C@3 r]-|&][s1; [*/ Return va")
TOPIC_TEXT(
"lue]-|&][s0; &][s0; Accessing unified virtual output interface&][s0;3 &][s4;:`:`:Draw`:`:BeginOp`(`): "
"virtual void_[* BeginOp]()&][s6; &][s0;3 &][s4;:`:`:Draw`:`:EndOp`(`): virtual void_[* "
"EndOp]()&][s6; &][s0;3 &][s4;:`:`:Draw`:`:OffsetOp`(`:`:Point`): virtual void_[* "
"OffsetOp](Point_[*@3 p])&][s6; &][s1; [*C@3 p]-|&][s0;3 &][s4;:`:`:Draw`:`:ClipOp`(const`:`:Rect`&`): "
"virtual bool_[* ClipOp](cons")
TOPIC_TEXT(
"t_Rect`&_[*@3 r])&][s6; &][s1; [*C@3 r]-|&][s1; [*/ Return value]-|&][s0;3 &][s4;:`:`:Draw`:`:ClipoffOp`(const`:`:Rect`&`): "
"virtual bool_[* ClipoffOp](const_Rect`&_[*@3 r])&][s6; &][s1; [*C@3 r]-|&][s1; [*/ "
"Return value]-|&][s0;3 &][s4;:`:`:Draw`:`:ExcludeClipOp`(const`:`:Rect`&`): virtual "
"bool_[* ExcludeClipOp](const_Rect`&_[*@3 r])&][s6; &][s1; [*C@3 r]-|&][s1; [*/ Return "
"value]-|&][s0;3 &][s4;:")
TOPIC_TEXT(
"`:`:Draw`:`:IntersectClipOp`(const`:`:Rect`&`): virtual bool_[* IntersectClipOp](const_Rect`&_[*@3 "
"r])&][s6; &][s1; [*C@3 r]-|&][s1; [*/ Return value]-|&][s0;3 &][s4;:`:`:Draw`:`:GetClipOp`(`)const: "
"virtual Rect_[* GetClipOp]()_const&][s6; &][s1; [*/ Return value]-|&][s0;3 &][s4;:`:`:Draw`:`:DrawRectOp`(int`,int`,int`,int`,`:`:Color`): "
"virtual void_[* DrawRectOp](int_[*@3 x], int_[*@3 y], int_[*@3")
TOPIC_TEXT(
" cx], int_[*@3 cy], Color_[*@3 color])&][s6; &][s1; [*C@3 x]-|&][s1; [*C@3 y]-|&][s1; "
"[*C@3 cx]-|&][s1; [*C@3 cy]-|&][s1; [*C@3 color]-|&][s0;3 &][s4;:`:`:Draw`:`:DrawImageOp`(const`:`:Rect`&`,const`:`:Image`&`,const`:`:Rect`&`,int`): "
"virtual void_[* DrawImageOp](const_Rect`&_[*@3 rect], const_Image`&_[*@3 img], const_Rect`&_[*@3 "
"src], int_[*@3 fx])&][s6; &][s1; [*C@3 rect]-|&][s1; [*C@3 img]-|&][")
TOPIC_TEXT(
"s1; [*C@3 src]-|&][s1; [*C@3 fx]-|&][s0;3 &][s4;:`:`:Draw`:`:DrawImageOp`(const`:`:Rect`&`,const`:`:Image`&`,const`:`:Rect`&`,`:`:Color`,`:`:Color`,`:`:Color`): "
"virtual void_[* DrawImageOp](const_Rect`&_[*@3 rect], const_Image`&_[*@3 img], const_Rect`&_[*@3 "
"src], Color_[*@3 fore], Color_[*@3 back], Color_[*@3 doxor])&][s6; &][s1; [*C@3 rect]-|&][s1; "
"[*C@3 img]-|&][s1; [*C@3 src]-|&][s1; [*C@3 fore")
TOPIC_TEXT(
"]-|&][s1; [*C@3 back]-|&][s1; [*C@3 doxor]-|&][s0;3 &][s4;:`:`:Draw`:`:DrawLineOp`(int`,int`,int`,int`,int`,`:`:Color`): "
"virtual void_[* DrawLineOp](int_[*@3 x1], int_[*@3 y1], int_[*@3 x2], int_[*@3 y2], "
"int_[*@3 width], Color_[*@3 color])&][s6; &][s1; [*C@3 x1]-|&][s1; [*C@3 y1]-|&][s1; "
"[*C@3 x2]-|&][s1; [*C@3 y2]-|&][s1; [*C@3 width]-|&][s1; [*C@3 color]-|&][s0;3 &][s4;:`:`:Draw`:`:DrawPolyPoly")
TOPIC_TEXT(
"lineOp`(const`:`:Point`*`,int`,const int`*`,int`,int`,`:`:Color`,`:`:Color`): virtual "
"void_[* DrawPolyPolylineOp](const_Point_`*[*@3 vertices], int_[*@3 vertex`_count], "
"const_int_`*[*@3 counts], int_[*@3 count`_count], int_[*@3 width], Color_[*@3 color], "
"Color_[*@3 doxor])&][s6; &][s1; [*C@3 vertices]-|&][s1; [*C@3 vertex`_count]-|&][s1; "
"[*C@3 counts]-|&][s1; [*C@3 count`_count]-|&][s1; [*C@3 widt")
TOPIC_TEXT(
"h]-|&][s1; [*C@3 color]-|&][s1; [*C@3 doxor]-|&][s0;3 &][s4;:`:`:Draw`:`:DrawEllipseOp`(const`:`:Rect`&`,`:`:Color`,int`,`:`:Color`): "
"virtual void_[* DrawEllipseOp](const_Rect`&_[*@3 r], Color_[*@3 color], int_[*@3 "
"pen], Color_[*@3 pencolor])&][s6; &][s1; [*C@3 r]-|&][s1; [*C@3 color]-|&][s1; [*C@3 "
"pen]-|&][s1; [*C@3 pencolor]-|&][s0;3 &][s4;:`:`:Draw`:`:DrawArcOp`(const`:`:Rect`&`,`:`:Point`,`:`:")
TOPIC_TEXT(
"Point`,int`,`:`:Color`): virtual void_[* DrawArcOp](const_Rect`&_[*@3 rc], Point_[*@3 "
"start], Point_[*@3 end], int_[*@3 width], Color_[*@3 color])&][s6; &][s1; [*C@3 rc]-|&][s1; "
"[*C@3 start]-|&][s1; [*C@3 end]-|&][s1; [*C@3 width]-|&][s1; [*C@3 color]-|&][s0;3 "
"&][s4;:`:`:Draw`:`:DrawTextOp`(int`,int`,int`,const`:`:wchar`*`,`:`:Font`,`:`:Color`,int`,const "
"int`*`): virtual void_[* DrawTextOp](int_[*")
TOPIC_TEXT(
"@3 x], int_[*@3 y], int_[*@3 angle], const_wchar_`*[*@3 text], Font_[*@3 font], "
"Color_[*@3 ink], int_[*@3 n], const_int_`*[*@3 dx])&][s6; &][s1; [*C@3 x]-|&][s1; "
"[*C@3 y]-|&][s1; [*C@3 angle]-|&][s1; [*C@3 text]-|&][s1; [*C@3 font]-|&][s1; [*C@3 "
"ink]-|text color&][s1; [*C@3 n]-|number of letters in [/ text]. When [/ n < 0], [/ "
"text] length is counted using [/ wcslen].&][s1; [*C@3 dx]-|array of let")
TOPIC_TEXT(
"ter widths. This can be used to set explicit spacings for the individual letters "
"in the text. When NULL, default letters widths are used. When not NULL, it must contain "
"(at least) as many entries as are being painted from the given [/ text].&][s0;3 &][s4;:`:`:Draw`:`:DrawDrawingOp`(const`:`:Rect`&`,const`:`:Drawing`&`): "
"virtual void_[* DrawDrawingOp](const_Rect`&_[*@3 target], const_Drawing`&_[*@3")
TOPIC_TEXT(
" w])&][s6; &][s1; [*C@3 target]-|&][s1; [*C@3 w]-|&][s0; &][s0; Accessing the underlying "
"physical output device interface&][s0;3 &][s4;:`:`:Draw`:`:GetColor`(`:`:Color`)const: "
"COLORREF_[* GetColor](Color_[*@3 color])_const&][s6; &][s1; [*C@3 color]-|&][s1; "
"[*/ Return value]-|&][s0;3 &][s4;:`:`:Draw`:`:SetColor`(`:`:Color`): void_[* SetColor](Color_[*@3 "
"color])&][s6; &][s1; [*C@3 color]-|&][s0;3 &]")
TOPIC_TEXT(
"[s4;:`:`:Draw`:`:SetDrawPen`(int`,`:`:Color`): void_[* SetDrawPen](int_[*@3 width], "
"Color_[*@3 color])&][s6; &][s1; [*C@3 width]-|&][s1; [*C@3 color]-|&][s0;3 &][s4;:`:`:Draw`:`:BeginGdi`(`): "
"HDC_[* BeginGdi]()&][s6; &][s1; [*/ Return value]-|&][s0;3 &][s4;:`:`:Draw`:`:EndGdi`(`): "
"void_[* EndGdi]()&][s6; &][s0;3 &][s4;:`:`:Draw`:`:GetHandle`(`): HDC_[* GetHandle]()&][s6; "
"&][s1; [*/ Return value]-|")
TOPIC_TEXT(
"&][s0;3 &][s4;:`:`:Draw`:`:operator HDC`(`)const: [* operator_HDC]()_const&][s6; "
"[* Win32`-specific:] retrieves the device context handle for the output device (in "
"Win32, device context handles are used to paint into windows, images, printer and "
"Windows metafile). When the device doesn`'t correspond to a Windows context handle "
"(e.g. for DrawingDraw, PdfDraw and the like), the function returns NULL")
TOPIC_TEXT(
".&][s1; [*/ Return value]-|handle of device context (NULL `= not available or applicable)&][s0;3 "
"&][s4;:`:`:Draw`:`:Unselect`(`): void_[* Unselect]()&][s6; [* Win32`-specific:] restores "
"all drawing objects originally selected in the Windows device context. When drawing "
"using different line and filll styles, the Draw object internally modifies the state "
"automaton of the device context to allocate t")
TOPIC_TEXT(
"he necessary brushes and pens. This functions unselects all objects created internally "
"by Draw during painting and restores the objects originally selected into the context. "
"This is sometimes necessary when you need to access and manipulate the device context "
"manually using specific Windows API calls.&][s0;3 &][s4;:`:`:Draw`:`:Attach`(HDC`): "
"void_[* Attach](HDC_[*@3 ahandle])&][s6; [* Win32`-speci")
TOPIC_TEXT(
"fic:] attaches the Draw object to a given Windows device handle. The function stores "
"the given handle and performs certain initializations (like determining the color "
"model and other characteristics of the output device). This is normally used only "
"internally by objects deriving from the Draw object to perform specific drawing tasks "
"(see ImageDraw and PrintDraw).&][s1; [*C@3 ahandle]-|windows devi")
TOPIC_TEXT(
"ce context handle to connect to the Draw object&][s0;3 &][s4;:`:`:Draw`:`:Detach`(`): "
"HDC_[* Detach]()&][s6; [* Win32`-specific:] detaches the Windows device context handle "
"from the Draw object. The function unselects all device objects selected previously "
"by the internal implementation of the drawing operations. After calling this function "
"the device context handle is freed from the Draw and can ")
TOPIC_TEXT(
"be used to perform Win32`-specific drawing tasks.&][s1; [*/ Return value]-|The Windows "
"device context being detached&][s0;3 &][s4;:`:`:Draw`:`:GetSizeCaps`(int`,int`)const: "
"Size_[* GetSizeCaps](int_[*@3 i], int_[*@3 j])_const&][s6; [* Win32`-specific:] returns "
"a pair of Windows device context capabilities forming an `[x, y`] pair. It is quite "
"common for device context characteristics to come in pa")
TOPIC_TEXT(
"irs, like HORZRES / VERTRES, PHYSICALWIDTH / PHYSICALHEIGHT etc. In a few such cases "
"it is handy to have a funcion which reads the given two capabilities (i and j) and "
"returns the result in the form of a Size object.&][s1; [*C@3 i]-|1st capability (its "
"value is returned in Size`::cx)&][s1; [*C@3 j]-|2nd capability (its value is returned "
"in Size`::cy)&][s1; [*/ Return value]-|Size formed from the r")
TOPIC_TEXT(
"esults of call to GetDeviceCaps for the HDC of the Draw object and the capabilities "
"[* i] and [* j].&][s0;3 &][s4;:`:`:Draw`:`:Flush`(`): void_[* Flush]()&][s6; &][s0;3 "
"&][s4;:`:`:Draw`:`:MakeXLFD`(`:`:byte`,`:`:Font`,int`,int`): String_[* MakeXLFD](byte_[*@3 "
"cs], Font_[*@3 f], int_[*@3 height]_`=_Null, int_[*@3 angle]_`=_[@3 0])&][s6; &][s1; "
"[*C@3 cs]-|&][s1; [*C@3 f]-|&][s1; [*C@3 height]-|&][s1")
TOPIC_TEXT(
"; [*C@3 angle]-|&][s1; [*/ Return value]-|&][s0;3 &][s4;:`:`:Draw`:`:CreateXftFont`(`:`:Font`,int`): "
"XftFont_`*[* CreateXftFont](Font_[*@3 f], int_[*@3 angle])&][s6; &][s1; [*C@3 f]-|&][s1; "
"[*C@3 angle]-|&][s1; [*/ Return value]-|&][s0;3 &][s4;:`:`:Draw`:`:GetXftDraw`(`)const: "
"XftDraw_`*[* GetXftDraw]()_const&][s6; &][s1; [*/ Return value]-|&][s0;3 &][s4;:`:`:Draw`:`:SetForeground`(`:`:Color`): "
"vo")
TOPIC_TEXT(
"id_[* SetForeground](Color_[*@3 color])&][s6; &][s1; [*C@3 color]-|&][s0;3 &][s4;:`:`:Draw`:`:SetLineStyle`(int`): "
"void_[* SetLineStyle](int_[*@3 width])&][s6; &][s1; [*C@3 width]-|&][s0;3 &][s4;:`:`:Draw`:`:SetFont`(`:`:Font`,int`): "
"void_[* SetFont](Font_[*@3 font], int_[*@3 angle])&][s6; &][s1; [*C@3 font]-|&][s1; "
"[*C@3 angle]-|&][s0;3 &][s4;:`:`:Draw`:`:SetClip`(`): void_[* SetClip]()&][s6; &][")
TOPIC_TEXT(
"s0;3 &][s4;:`:`:Draw`:`:GetDrawable`(`)const: Drawable_[* GetDrawable]()_const&][s6; "
"&][s1; [*/ Return value]-|&][s0;3 &][s4;:`:`:Draw`:`:GetGC`(`)const: GC_[* GetGC]()_const&][s6; "
"&][s1; [*/ Return value]-|&][s0;3 &][s4;:`:`:Draw`:`:GetClipList`(`)const: const_Vector<Rect>`&_[* "
"GetClipList]()_const&][s6; &][s1; [*/ Return value]-|&][s0;3 &][s4;:`:`:Draw`:`:GetFontInfo`(`:`:byte`,`:`:Font`): "
"void_")
TOPIC_TEXT(
"[* Init](const_Vector<Rect>`&_[*@3 `_clip], Point_[*@3 `_offset])&][s6; &][s1; [*C@3 "
"`_clip]-|&][s1; [*C@3 `_offset]-|&][s0; &][s0; Accessing device`-secific functions&][s0;3 "
"&][s4;:`:`:Draw`:`:StartPage`(`): virtual void_[* StartPage]()&][s6; &][s0;3 &][s4;:`:`:Draw`:`:EndPage`(`): "
"virtual void_[* EndPage]()&][s6; &][s0;3 &][s4;:`:`:Draw`:`:Register`(int`,`:`:Draw`:`:Drawer`): "
"void_[* Register](i")
TOPIC_TEXT(
"nt_[*@3 code], Drawer_[*@3 drawer])&][s6; &][s1; [*C@3 code]-|&][s1; [*C@3 drawer]-|&][s0;3 "
"&][s2;3 Important derived classes&][s0;3 &][s10;:`:`:ScreenDraw`:`:class`:`:ScreenDraw:* "
"[* class_]ScreenDraw[*  : public ]Draw&][s0;3 &][s0; Used for determining screen "
"characteristics like pixel `& physical resolution, supported color model, and for "
"retrieving physical screen data. This is needed in situa")
TOPIC_TEXT(
"tion when you must access the whole screen not depending on the logical window system "
"(e.g. when writing an utility showing in its window a magnified part of the screen).&][s0; "
"&][s0;3 &][s10;:`:`:ScreenInfo`(`):* [* class_]ScreenInfo[*  : public ]Draw&][s0; "
"&][s0; Used for determining screen characteristics like pixel `& physical resolution, "
"supported color model. Instead of [* ScreenDraw], Scree")
TOPIC_TEXT(
"nInfo cannot be used to read physical display data, only for retrieving device configuration "
"information.&][s0; &][s0;3 &][s10;:`:`:ViewDraw`:`:class`:`:ViewDraw:* [* class_]ViewDraw[* "
" : public ]Draw&][s0; &][s0; Used to paint into a control`'s view area. This is usually "
"needed only in special situations (like for `\"animated`\" display in drag `& drop "
"operations), because usually the controls are ")
TOPIC_TEXT(
"repainted automatically upon Windows request via the event loop (see [^topic`:`/`/CtrlCore`/src`/Ctrl`$en`-us`#`:`:Ctrl`:`:Paint`(Draw`&`)^ "
"Ctrl`::Paint]).&][s0;3 &][s4;:`:`:ViewDraw`:`:ViewDraw`(`:`:Ctrl`*`): [* ViewDraw](Ctrl "
"`*[*@3 ctrl])&][s6; Initializes the ViewDraw object to paint into the window area "
"of a given Ctrl. See [^topic`:`/`/CtrlCore`/src`/Ctrl`$en`-us^ CtrlCore] for greater "
"detai")
TOPIC_TEXT(
"l on controls.&][s0; &][s0;3 &][s10;:`:`:ImageDraw`:`:class`:`:ImageDraw:* [* class_]ImageDraw[* "
" : public ]Draw&][s0; &][s0; Used to paint into images. This is needed when you generate "
"an image (to be later stored as a PNG, for example) using Windows GDI functions like "
"DrawLine, DrawText etc. You create an image object, construct an ImageDraw using "
"this object (and possibly a reference Draw to sp")
TOPIC_TEXT(
"ecify the image color format), then perform a series of GDI operations on the ImageDraw "
"object. After you Close the ImageDraw object, you can further process the Image which "
"now contains the object painted using the GDI output.&][s0; &][s0;3 &][s4;:`:`:ImageDraw`:`:ImageDraw`(`): "
"[%00-00* ImageDraw][%00-00 ()]&][s6; Constructs an empty ImageDraw. You can later "
"Open the ImageDraw with a given Image")
TOPIC_TEXT(
".&][s0;3 &][s4;:`:`:ImageDraw`:`:ImageDraw`(`:`:Draw`&`,`:`:Image`&`): [%00-00* "
"ImageDraw][%00-00 (Draw`&_][%00-00*@3 draw][%00-00 , Image`&_][%00-00*@3 image][%00-00 "
")]&][s6; Constructs an ImageDraw and Opens it for painting into the given [* image].&][s1; "
"[%00-00*C@3 draw]-|reference draw defining the image`'s color format.&][s1; [%00-00*C@3 "
"image]-|image to write into&][s0;3 &][s4;:`:`:ImageDra")
TOPIC_TEXT(
"w`:`:ImageDraw`(`:`:Image`&`): [%00-00* ImageDraw][%00-00 (Image`&_][%00-00*@3 image][%00-00 "
")]&][s6; Constructs and ImageDraw and Opens it for painting into the given [* image]. "
"The image is considered to be in the color format defined by [* ScreenDraw].&][s1; "
"[%00-00*C@3 image]-|image to write into&][s0;3 &][s4;:`:`:ImageDraw`:`:Open`(`:`:Image`&`): "
"[%00-00 void_][%00-00* Open][%00-00 (Image`&_]")
TOPIC_TEXT(
"[%00-00*@3 image][%00-00 )]&][s6; Opens the ImageDraw for painting into given [* "
"image ](assumed to have color format compatible with ScreenDraw). If an image was "
"opened in the ImageDraw before, it is automatically closed.&][s1; [%00-00*C@3 image]-|image "
"to write into&][s0;3 &][s4;:`:`:ImageDraw`:`:Open`(`:`:Draw`&`,`:`:Image`&`): [%00-00 "
"void_][%00-00* Open][%00-00 (Draw`&_][%00-00*@3 draw][%00-0")
TOPIC_TEXT(
"0 , Image`&_][%00-00*@3 image][%00-00 )]&][s6; Opens the ImageDraw for painting "
"into given [* image]. The [* draw] parameter defines the [* image]`'s color model. "
"This is needed because in Win32, standard GDI is not completely generic as concerns "
"image color models. To process a bitmap, you must create a CompatibleDC suitable "
"for processing the image, and this is not generally possible to determin")
TOPIC_TEXT(
"e and create solely using the information in the image. (E.g. when a printer has "
"different color model than the screen, which is quite often the case, an image created "
"using the PrintDraw as its compatible draw will not be processable by another ImageDraw "
"based on ScreenDraw).&][s1; [%00-00*C@3 draw]-|draw compatible with image color model&][s1; "
"[%00-00*C@3 image]-|image to write into&][s0;3 &][s4")
TOPIC_TEXT(
";:`:`:ImageDraw`:`:Close`(`): [%00-00 void_][%00-00* Close][%00-00 ()]&][s6; Shuts "
"down writing into the (previously Open`-ed) image. Between the Open (or the non`-empty "
"contructor) and a Close the image itself must not be manipulated, otherwise the results "
"may be inpredictable. You had best consider the image locked (although in reality, "
"no physical lock is currently done) and leave it alone unti")
TOPIC_TEXT(
"l the Close, after which you can process it further (encoder it using an ImageEncoder "
"and save it to the disk, store it in a VectorMap`-based cache for web server throughput "
"acceleration, assign it to the system cursor using [^topic`:`/`/CtrlCore`/src`/Ctrl`$en`-us`#`:`:Ctrl`:`:CursorImage`(Point`,dword`)^ "
"CursorImage] etc.).&][s0; &][s0;3 &][s10;:`:`:ImageMaskDraw`:`:class`:`:ImageMaskDraw:* "
"[%00")
TOPIC_TEXT(
"-00* class_][%00-00 ImageMaskDraw]&][s6; Used to paint into image masks. Images "
"can be either unmasked (considered to have mask equal to opaque everywhere in the "
"image area), or masked. Full alpha channel is currently not supported, but is planned "
"(hopefully soon, written on June 29, 2005). Mask can be either `\"off`\" for the "
"pixel (then the pixel is transparent and nothing is painted) or `\"on`\" (t")
TOPIC_TEXT(
"hen the pixel is painted and the original pixel is overwritten). This applies to "
"standard functions like the simpler form of DrawImage, other functions manipulate "
"the pixel `& mask data otherwise.&][s9; [/ Derived from] [%00-00 Draw]&][s0;3 &][s4;:`:`:ImageMaskDraw`:`:ImageMaskDraw`(`): "
"[%00-00* ImageMaskDraw][%00-00 ()]&][s6; Constructs an empty ImageMaskDraw. You can "
"later Open the ImageMaskDraw")
TOPIC_TEXT(
" for processing an Image.&][s0;3 &][s4;:`:`:ImageMaskDraw`:`:ImageMaskDraw`(`:`:Image`&`): "
"[%00-00* ImageMaskDraw][%00-00 (Image`&_][%00-00*@3 image][%00-00 )]&][s6; Creates "
"an ImageMaskDraw and opens it for writing into an Image.&][s1; [%00-00*C@3 image]-|image "
"to write to&][s0;3 &][s4;:`:`:ImageMaskDraw`:`:Open`(`:`:Image`&`): [%00-00 void_][%00-00* "
"Open][%00-00 (Image`&_][%00-00*@3 image][%00-0")
TOPIC_TEXT(
"0 )]&][s6; Opens the ImageMaskDraw to write into given Image. When the ImageMaskDraw "
"was previously opened with another image, it is automatically closed. It is an error "
"to open the same Image in two ImageMaskDraws at once. It is, however, legal to open "
"an Image simultaneously in an ImageDraw together with the ImageMaskDraw. It is often "
"handy to be able to paint the data and mask at once, because ")
TOPIC_TEXT(
"they often correlate.&][s1; [%00-00*C@3 image]-|image to write to&][s0;3 &][s4;:`:`:ImageMaskDraw`:`:Close`(`): "
"[%00-00 void_][%00-00* Close][%00-00 ()]&][s6; Finishes writing into the image mask. "
"After this operation you can further process the newly modified image (paint it, "
"encode it or anything else).&][s0;3 &][s10;:`:`:DrawingDraw`:`:class`:`:DrawingDraw: "
"&][s10;* [%00-00* class_][%00-00 Draw")
TOPIC_TEXT(
"ingDraw]&][s6; Used to create an internal linearized representation of the executed "
"drawing operations, called a [* Drawing]. The Drawing can later be painted using "
"DrawDrawing or serialized into a stream (to be later read back). Please consider "
"the DrawingDraw an optimized internal short`-term image storage format (like when "
"preparing the output for printer or for caches), not a completely `\"offi")
TOPIC_TEXT(
"cial`\" or stable format suitable e.g. for documents or distributable images. It "
"tends to change from time to time. We plan to implement a specialized `\"stable`\" "
"Drawing`-like vector format which will be suitable for long`-term data storage.&][s9; "
"[/ Derived from] [%00-00 Draw]&][s0;3 &][s4;:`:`:DrawingDraw`:`:DrawingDraw`(`): "
"[%00-00* DrawingDraw][%00-00 ()]&][s6; Constructs an empty DrawingDraw. ")
TOPIC_TEXT(
"The DrawingDraw can be initialized later using [* Create].&][s0;3 &][s4;:`:`:DrawingDraw`:`:DrawingDraw`(int`,int`): "
"[%00-00* DrawingDraw][%00-00 (int_][%00-00*@3 cx][%00-00 , int_][%00-00*@3 cy][%00-00 "
")]&][s6; Creates a DrawingDraw and initializes it with given dimensions. Pixels are "
"set as default Drawing units, although you can change the units to dots using SetPixels.&][s1; "
"[%00-00*C@3 cx]-|d")
TOPIC_TEXT(
"rawing width&][s1; [%00-00*C@3 cy]-|drawing height&][s0;3 &][s4;:`:`:DrawingDraw`:`:DrawingDraw`(`:`:Size`): "
"[%00-00* DrawingDraw][%00-00 (Size_][%00-00*@3 sz][%00-00 )]&][s6; Creates a DrawingDraw "
"with given size (with pixels as default units).&][s1; [%00-00*C@3 sz]-|desired drawing "
"size&][s0;3 &][s4;:`:`:DrawingDraw`:`:SetPixels`(bool`): [%00-00 void_][%00-00* SetPixels][%00-00 "
"(bool_][%00-00*@3")
TOPIC_TEXT(
" b][%00-00 _`=_true)]&][s6; Switches to pixel units (b `= true) or to dot units "
"(b `= false).&][s1; [%00-00*C@3 b]-|unit mode: true `= pixels, false `= dots&][s0;3 "
"&][s4;:`:`:DrawingDraw`:`:Create`(int`,int`): [%00-00 void_][%00-00* Create][%00-00 "
"(int_][%00-00*@3 cx][%00-00 , int_][%00-00*@3 cy][%00-00 )]&][s6; Initializes the "
"DrawingDraw to record drawing operations into a Drawing of given size.")
TOPIC_TEXT(
" After performing the requested set of operations, you can GetResult to retrieve "
"the Drawing containing the recording of the performed operations. Default drawing "
"units are pixels, use SetPixels(false) to switch them to dots.&][s1; [%00-00*C@3 "
"cx]-|drawing width&][s1; [%00-00*C@3 cy]-|drawing height&][s0;3 &][s4;:`:`:DrawingDraw`:`:Create`(`:`:Size`): "
"[%00-00 void_][%00-00* Create][%00-00 (Size_][")
TOPIC_TEXT(
"%00-00*@3 sz][%00-00 )]&][s6; Initializes the DrawingDraw to create a Drawing of "
"given size.&][s1; [%00-00*C@3 sz]-|drawing size&][s0;3 &][s4;:`:`:DrawingDraw`:`:GetResult`(`)const: "
"[%00-00 Drawing_][%00-00* GetResult][%00-00 ()_const]&][s6; Returns the Drawing containing "
"the recorded operations. (Before you use GetResult, you must first use the constructor "
"with parameters or call Create to initia")
TOPIC_TEXT(
"lize the Drawing and set its size).&][s1; [*/ Return value]-|a Drawing representing "
"the recorded set of drawing operations. You can later replay this set of operations "
"using [^topic`:`/`/Draw`/src`/Draw`$en`-us`#`:`:Draw`:`:DrawDrawing`(const Rect`&`,const "
"Drawing`&`)^ DrawDrawing] or Serialize it for storage.&][s0;3 &][s4;:`:`:DrawingDraw`:`:operator`:`:Drawing`(`)const: "
"[%00-00* operator_Drawing")
TOPIC_TEXT(
"][%00-00 ()_const]&][s6; Returns the recorded Drawing (just like GetResult).&][s1; "
"[*/ Return value]-|the recorded drawing operations&][s0; &][s0; &][s10;* [* class_]Report&][s0; "
"The Report can be used for generating documents for printing. Is is currently considered "
"slightly obsolete as it is based on the old Document object instead on RichText. "
"It is planned to be removed sometimes in the future")
TOPIC_TEXT(
", but is currently needed for not breaking our older projects.&][s10; &][s10;* [* "
"class_]WinMetaFileDraw (Win32 only)&][s0; Used to create Windows metafiles. &][s0;3 "
"&][s4;:`:`:WinMetaFileDraw`:`:WinMetaFileDraw`(HDC`,int`,int`,const char`*`,const "
"char`*`,const char`*`): [%00-00* WinMetaFileDraw][%00-00 (HDC_][%00-00*@3 hdc][%00-00 "
", int_][%00-00*@3 cx][%00-00 , int_][%00-00*@3 cy][%00-00 , const_")
TOPIC_TEXT(
"char_`*][%00-00*@3 app][%00-00 , const_char_`*][%00-00*@3 name][%00-00 , const_char_`*][%00-00*@3 "
"file][%00-00 )]&][s6; Constructs a WinMetaFileDraw to generate a metafile in color "
"format compatible with given device.&][s1; [%00-00*C@3 hdc]-|reference device to "
"use for initializing metafile color model&][s1; [%00-00*C@3 cx]-|metafile width&][s1; "
"[%00-00*C@3 cy]-|metafile height&][s1; [%00-00*C@3 a")
TOPIC_TEXT(
"pp]-|application name (stored in the metafile header)&][s1; [%00-00*C@3 name]-|metafile "
"name (stored in the metafile header)&][s1; [%00-00*C@3 file]-|optional file name "
"(when not given, the metafile is memory`-only)&][s0;3 &][s4;:`:`:WinMetaFileDraw`:`:WinMetaFileDraw`(int`,int`,const "
"char`*`,const char`*`,const char`*`): [%00-00* WinMetaFileDraw][%00-00 (int_][%00-00*@3 "
"cx][%00-00 , int_][%00-00*")
TOPIC_TEXT(
"@3 cy][%00-00 , const_char_`*][%00-00*@3 app][%00-00 , const_char_`*][%00-00*@3 "
"name][%00-00 , const_char_`*][%00-00*@3 file][%00-00 )]&][s6; Constructs a WinMetaFileDraw "
"to generate a metafile in color format compatible with ScreenDraw.&][s1; [%00-00*C@3 "
"cx]-|metafile width&][s1; [%00-00*C@3 cy]-|metafile height&][s1; [%00-00*C@3 app]-|application "
"name&][s1; [%00-00*C@3 name]-|metafile name&][s1;")
TOPIC_TEXT(
" [%00-00*C@3 file]-|optional file name (empty causes a memory`-only metafile to "
"be created)&][s0;3 &][s4;:`:`:WinMetaFileDraw`:`:Create`(HDC`,int`,int`,const char`*`,const "
"char`*`,const char`*`): [%00-00 bool_][%00-00* Create][%00-00 (HDC_][%00-00*@3 hdc][%00-00 "
", int_][%00-00*@3 cx][%00-00 , int_][%00-00*@3 cy][%00-00 , const_char_`*][%00-00*@3 "
"app][%00-00 , const_char_`*][%00-00*@3 name][%00-00 ")
TOPIC_TEXT(
", const_char_`*][%00-00*@3 file][%00-00 )]&][s6; Creates a new metafile compatible "
"with given reference device context.&][s1; [%00-00*C@3 hdc]-|reference device context "
"to copy color format from&][s1; [%00-00*C@3 cx]-|metafile width&][s1; [%00-00*C@3 "
"cy]-|metafile height&][s1; [%00-00*C@3 app]-|application name&][s1; [%00-00*C@3 name]-|metafile "
"name&][s1; [%00-00*C@3 file]-|optional file name (whe")
TOPIC_TEXT(
"n not given, is memory`-only)&][s1; [*/ Return value]-|[* true] on success, [* false] "
"on failure&][s0;3 &][s4;:`:`:WinMetaFileDraw`:`:Create`(int`,int`,const char`*`,const "
"char`*`,const char`*`): [%00-00 bool_][%00-00* Create][%00-00 (int_][%00-00*@3 cx][%00-00 "
", int_][%00-00*@3 cy][%00-00 , const_char_`*][%00-00*@3 app][%00-00 , const_char_`*][%00-00*@3 "
"name][%00-00 , const_char_`*][%00-00*@3 fil")
TOPIC_TEXT(
"e][%00-00 )]&][s6; Creates a new metafile compatible with the screen.&][s1; [%00-00*C@3 "
"cx]-|metafile width&][s1; [%00-00*C@3 cy]-|metafile height&][s1; [%00-00*C@3 app]-|application "
"name&][s1; [%00-00*C@3 name]-|metafile name&][s1; [%00-00*C@3 file]-|optional file "
"name&][s1; [*/ Return value]-|[* true] on success, [* false] on failure&][s0;3 &][s4;:`:`:WinMetaFileDraw`:`:Close`(`): "
"[%00-00 WinMet")
TOPIC_TEXT(
"aFile_][%00-00* Close][%00-00 ()]&][s6; Finishes metafile creation and returns the "
"created [* WinMetaFile] object.&][s1; [*/ Return value]-|the recorded metafile&][s0; "
"&][s0;3 &][s10;:`:`:PrintDraw`:`:class`:`:PrintDraw:* [%00-00* class_][%00-00 PrintDraw "
"(Win32`-only)]&][s6; Used for generating printer output. This is currently Win32`-only, "
"we hope to make a Linux version soon (volunteers needed)")
TOPIC_TEXT(
". Currently we have also a Win32`-compatible PdfDraw which should be ported to Linux. "
"Perhaps then the PrintDraw on Linux will be more or less derived from PdfDraw.&][s9; "
"[/ Derived from] [%00-00 Draw]&][s0;3 &][s4;:`:`:PrintDraw`:`:PrintDraw`(HDC`,const "
"char`*`): [%00-00* PrintDraw][%00-00 (HDC_][%00-00*@3 hdc][%00-00 , const_char_`*][%00-00*@3 "
"jobname][%00-00 )]&][s6; Creates a PrintDraw object.")
TOPIC_TEXT(
" Prior to constructing a PrintDraw, you must create the printer HDC using PrintDlg "
"or CreateDC.&][s1; [%00-00*C@3 hdc]-|printer DC&][s1; [%00-00*C@3 jobname]-|printer "
"job name&][s0;3 &][s4;:`:`:PrintDraw`:`:StartPage`(`): [%00-00 virtual void_][%00-00* "
"StartPage][%00-00 ()]&][s6; Begins a new page.&][s0;3 &][s4;:`:`:PrintDraw`:`:EndPage`(`): "
"[%00-00 virtual void_][%00-00* EndPage][%00-00 ()]&][s6;")
TOPIC_TEXT(
" Ends current page.&][s0;3 &][s4;:`:`:PrintDraw`:`:InitPrinter`(`): [%00-00 void_][%00-00* "
"InitPrinter][%00-00 ()]&][s6; Sends an initialization sequence to the printer.&][s0;3 "
"&][s4;:`:`:PrintDraw`:`:Abort`(`): [%00-00 void_][%00-00* Abort][%00-00 ()]&][s6; "
"Aborts current print job.&][s10; &][s10;* [* struct_]PageDraw&][s0; The PageDraw "
"is an abstract interface used to draw formatted text using t")
TOPIC_TEXT(
"he RichText objects. It is derived from Draw and captures drawing operations on "
"the currently selected output page. After the painting is finished, you can access "
"the generated pages. The user must derive the Page and Info methods and support their "
"routines to manage the output pages.&][s0; &][s0;3 &][s10;:`:`:PageDraw`:`:struct`:`:PageDraw:* "
"[* struct_]PdfDraw (Win32`-only)&][s0; Used to create P")
TOPIC_TEXT(
"DF files. Volunteers are needed to implement a Linux version (some font hackery "
"will perhaps be needed, current version works only with TrueType fonts).&][s0;3 ]")
