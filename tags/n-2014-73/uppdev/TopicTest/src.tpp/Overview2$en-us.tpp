TITLE("Overview")
TOPIC_TEXT(
"[ $$0,0#00000000000000000000000000000000:Default][l288;i704;a17;O9;~~~.992; $$1,"
"0#10431211400427159095818037425705:param][a83;*R6 $$2,5#3131016247420302412518841"
"7583966:caption][b83;* $$3,5#07864147445237544204411237157677:title][b167;a42;C $"
"$4,6#40027414424643823182269349404212:item][b42;a42; $$5,5#4541300047534217475409"
"1244180557:text][l288;a17; $$6,6#27521748481378242620020725143825:desc][l321;t246"
";C@5;1 $$7,7#20902679421464641399138805415013:code][b2503; $$8,0#6514237545610002"
"3862071332075487:separator][*@(0.0.255) $$9,0#83433469410354161042741608181528:ba"
"se][t4167;C+117 $$10,0#37138531426314131251341829483380:class][l288;a17;*1 $$11,1"
"1#70004532496200323422659154056402:requirement][i416;b42;a42;O9;~~~.416; $$12,12#"
"10566046415157235020018451313112:tparam][b167;C $$13,13#9243045944346046191110808"
"0531343:item1][a42;C $$14,14#77422149456609303542238260500223:item2][*@2$(0.128.1"
"28) $$15,15#34511555403152284025741354420178:NewsDate][l321;*C$7 $$16,16#03451589"
"433145915344929335295360:result][l321;b83;a83;*C$7 $$17,17#0753155046352950537122"
"8428965313:result`-line][l160;t4167;*C+117 $$18,5#8860394944220582595880005322242"
"5:package`-title][{_}%EN-US [s2; NTL overview&][s5; NTL is a library of container"
" and algorithm templates. It is designed to solve some problems we see in current"
" C`++ standard library STL.&][s3; Random access&][s5; Each single NTL container t"
"emplate that can store more than one element has random access. This random acces"
"s is as fast as access using iterators so for iterating elements you can use indi"
"ces rather than iterators and we recommend this approach.&][s3; Requirements&][s5"
"; An important feature of NTL are requirements for stored elements. Unlike STL, w"
"hich has single [/ copy-constructible] and [/ assignable] requirement for whole l"
"ibrary, NTL makes requirements on per container and even per method basis. This w"
"ay NTL allows [/ direct] storing of [/ any] type of elements. NTL provides two or"
" even three flavors for each basic ADT kind of container ")
TOPIC_TEXT(
"relative to requirements for elements.&][s3; Flavors&][s5; [*/ Vector] flavor of"
" containers requires types to be [*/^dpp`:`/`/SourceDoc`/Containers`/Moveable^ mo"
"veable] and have either [*/^dpp`:`/`/SourceDoc`/Containers`/pick`_^ deep copy con"
"structor][^dpp`:`/`/SourceDoc`/Containers`/pick`_^  ]and operator, [*/^dpp`:`/`/S"
"ourceDoc`/Containers`/pick`_^ pick constructor] and operator or default construct"
"or. Containers of this flavor have word [* Vector] in their their names, with the"
" exception of [* Index] which is also of this flavor. This flavor has the best ru"
"ntime characteristics.&][s5; [*/ Array] flavor of containers has [*/ no][/  ]comm"
"on requirements for elements, but is less effective. You can use it to store even"
" polymorphic types. Type of stored elements does not even have to be defined at t"
"he point of instantiation, so you can use Array flavor to create recursive data s"
"tructures. Another feature of this flavor is fact that references to elements are"
" never invalidated. Containers of this flavor have [* Array] in their name.&][s5;"
" [*/ Segtor] flavor, with very specific but important usage, requires elements to"
" have either deep copy constructor and operator, pick copy constructor and operat"
"or, or default constructor. It does not invalidate references to elements. A disa"
"dvantage is again performance and also the fact that this flavor is always missin"
"g operations for inserting and removing elements at random positions. Containers "
"of this flavor have [* Segtor] in their name. This flavor has better memory chara"
"cteristics than [* Array] and even than [* Vector] flavor, but its speed is as ba"
"d as that of [* Array].&][s3; Containers as return values&][s5;/ [/ NTL allows co"
"ntainers to be used as return values, in single constant time operation. It is al"
"lowed by defining specific ][*^dpp`:`/`/SourceDoc`/Containers`/pick`_^ transfer s"
"emantics].&][s3; Basic random access containers&][s5; This kind of containers all"
"ows adding/removing elements at the end of the sequence i")
TOPIC_TEXT(
"n amortized constant time. As these containers are basic building blocks for NTL"
", their names are the same as names for all three flavors. [* Vector] flavor allo"
"ws direct access to underlying C vector of elements. [* Vector] and [* Array] fla"
"vors allow removing and inserting of elements at any position (with complexity ba"
"sed on number of elements moved). [* Segtor][/  ]does not allow this.&][s3; Bidir"
"ectional containers&][s5; This kind of containers allows adding/removing elements"
" to/from both beginning and end of sequence in constant amortized time. It is wel"
"l suited for FIFO operations. [* BiVector] and [* BiArray] are two flavors of bid"
"irectional containers.&][s3; Indexes&][s5; Basically, this kind of container prov"
"ides random access sequence that allows adding elements at the end of sequence in"
" constant amortized time (much like basic random access containers) with one uniq"
"ue feature: it allows fast retrieval of position of element with specific value. "
"Hashing is used for this operation. Indexes represent ideal building-blocks for a"
"ny associative operations. [* Index] and [* ArrayIndex ]are two flavors of indexe"
"s.&][s5;* [* As both index flavors are built on top of according basic random acc"
"ess containers, they provide read-only access or even pick operations to this con"
"tainer. That means you can supply elements to ]Index[*  by picking ]Vector [* in "
"]Index[*  constructor or get ]Vector[*  of elements of ]Index[*  in low constant "
"time pick operation. Same is true for ]Array[*  and ]ArrayIndex.&][s5; Also, as m"
"ost of functionality added to basic random access containers is same for both [* "
"Index] and [* ArrayIndex], most of operations are shared in common template class"
" [* AIndex], which represents index container without concrete flavor. [* Index] "
"and [* ArrayIndex] are derived from this [* AIndex], adding few operations specif"
"ic for their flavors.&][s3; Maps&][s5; Basically, maps are just simple compositio"
"ns of Index and basic random access container to store va")
TOPIC_TEXT(
"lues, thus getting classical map design. In find operation, position of key in I"
"ndex is retrieved and value from basic access container at the same position is r"
"eturned. This design also allows accessing both keys and values using indices. &]"
"[s5; In case of maps, keys are always stored in [* Index], that means that flavor"
" is relative only to type of values (and keys must be moveable). [* VectorMap], ["
"* ArrayMap] and [* SegtorMap] are flavors of maps. As with [* Index], most operat"
"ions of these flavors are shared in common template class [* AMap]. Also, picking"
" operations for any part of maps are available too.&][s3; One&][s5; [* One] is th"
"e container that can hold one or none elements of specified type or type derived "
"from it. Its functionally rather close to standard library auto`_ptr but with imp"
"rovements in direction of NTL, like transfer semantics, moveable concept (yes, yo"
"u [/ can] have Vector< One<T> >) and others. Also it is important from conceptual"
" view, because it is it is treatedlike a container  than the pointer.&][s0; ")
