TITLE("NTL algorithms")
REF("::Swap(T&,T&)")
REF("template<class I> void IterSwap(I a, I b)")
REF("template<class T> int sgn(T a)")
REF("template<class C, class T, class L> int FindLowerBound(const C& v, const T& val, const L& less)")
REF("template<class C, class T> int FindLowerBound(const C& v, const T& val)")
REF("template<class C, class T, class L> int FindUpperBound(const C& v, int l, int h, const T& val, const L& less)")
REF("template<class C, class T, class L> int FindUpperBound(const C& v, const T& val, const L& less)")
REF("template<class C, class T> int FindUpperBound(const C& v, const T& val)")
REF("template<class C, class T, class L> int FindBinary(const C& v, const T& val, int l, int h, const L& less)")
REF("template<class C, class T, class L> int FindBinary(const C& v, const T& val, const L& less)")
REF("template<class C, class T> int FindBinary(const C& v, const T& val)")
REF("template<class C> C& AppendSorted(C& dest, const C& src)")
REF("template<class C> C& UnionSorted(C& dest, const C& src)")
REF("template<class C> C& RemoveSorted(C& from, const C& what)")
REF("template<class D, class S, class L> D& IntersectSorted(D& dest, const S& src, const L& less)")
REF("template<class D, class S> D& IntersectSorted(D& dest, const S& src)")
REF("template<class T> void StreamContainer(Stream& s, T& cont)")
REF("template<class T> void Sort(T& c)")
REF("template<class II, class VI, class K, class Less> void __IndexSort(II begin, II end, VI pair, const Less& less, const K *)")
REF("template<class KC, class VC> void IndexSort(KC& keys, VC& values)")
REF("template<class I, class V, class Less> void __SortOrder(int *begin, int *end, I data, const Less& less, const V *)")
REF("template<class C> Vector<int> GetSortOrder(const C& container)")
REF("template<class DC, class I, class F> void GetFieldContainer(DC& dest, I begin, I end, F field)")
REF("template<class O, class T, class R> MethodRelationCls<O (T::*)(), T, R> MethodRelation(O (T::*method)(), const R& relation)")
REF("template<class O, class T, class R> MethodRelationCls<O (T::*)() const, T, R> MethodRelation(O (T::*method)() const, const R& relation)")
TOPIC_TEXT(
"[2 $$0,0#00000000000000000000000000000000:Default][l288;i704;a17;O9;~~~.992;2 $$"
"1,0#10431211400427159095818037425705:param][a83;*R6 $$2,5#31310162474203024125188"
"417583966:caption][b83;* $$3,5#07864147445237544204411237157677:title][b167;a42;C"
"2 $$4,6#40027414424643823182269349404212:item][b42;a42; $$5,5#4541300047534217475"
"4091244180557:text][l288;a17;2 $$6,6#27521748481378242620020725143825:desc][l321;"
"t246;C@5;1 $$7,7#20902679421464641399138805415013:code][b2503; $$8,0#651423754561"
"00023862071332075487:separator][*@(0.0.255) $$9,0#8343346941035416104274160818152"
"8:base][t4167;C $$10,0#37138531426314131251341829483380:class][l288;a17;*1 $$11,1"
"1#70004532496200323422659154056402:requirement][i416;b42;a42;O9;~~~.416; $$12,12#"
"10566046415157235020018451313112:tparam][b167;C2 $$13,13#924304594434604619111080"
"80531343:item1][i288;a42;O9;C2 $$14,14#77422149456609303542238260500223:item2][*@"
"2$(0.128.128) $$15,15#34511555403152284025741354420178:NewsDate][l321;*C$7;2 $$16"
",16#03451589433145915344929335295360:result][l321;b83;a83;*C$7;2 $$17,17#07531550"
"463529505371228428965313:result`-line][l160;t4167;*C+117 $$18,5#88603949442205825"
"958800053222425:package`-title][{_}%EN-US [s13;%00-00 [%00-00 template<class ][%0"
"0-00*@4 T][%00-00 >]&][s14;:`:`:Swap`(T`&`,T`&`):%00-00 [%00-00 void ][%00-00* Sw"
"ap][%00-00 (][%00-00*@4 T][%00-00 `& ][%00-00*@3 a][%00-00 , ][%00-00*@4 T][%00-0"
"0 `& ][%00-00*@3 b][%00-00 )]&][s6;%00-00 [%00-00 Swaps values. Specific types mi"
"ght specialize ][%00-00* Swap][%00-00  with more effective variants.]&][s11; T mu"
"st have either deep copy operator or pick operator.&][s1;%00-00 [%00-00*C@4 T][%0"
"0-00 -|Type of values.]&][s1;%00-00 [%00-00*C@3 a][%00-00 -|First value to swap.]"
"&][s1;%00-00 [%00-00*C@3 b][%00-00 -|Second value to swap.]&][s13;:template`<clas"
"s I`> void IterSwap`(I a`, I b`):%00-00 [%00-00 template<class ][%00-00*@4 I][%00"
"-00 >]&][s14;:template`<class I`> void IterSwap`(I a`, I b`):%00-00 [%00-00 void "
"][%00-00* IterSwap][%00-00 (][%00-00*@4 I][%00-00*  ][%00")
TOPIC_TEXT(
"-00*@3 a][%00-00 , ][%00-00*@4 I][%00-00*  ][%00-00*@3 b][%00-00 )]&][s6;%00-00 "
"[%00-00 Swaps values pointed to by iterators. Specific types might specialize ][%"
"00-00* IterSwap][%00-00  with more effective variants.]&][s11; Swap must be defin"
"ed for type pointed to by I.&][s1;%00-00 [%00-00*C@4 I][%00-00 -|Iterator type.]&"
"][s1;%00-00 [%00-00*C@3 a][%00-00 -|Iterator pointing to first value.]&][s1;%00-0"
"0 [%00-00*C@3 b][%00-00 -|Iterator pointing to second value.]&][s13;%00-00 [%00-0"
"0 template<class ][%00-00*@4 C][%00-00 , class ][%00-00*@4 T][%00-00 , class ][%0"
"0-00*@4 L][%00-00 >]&][s14;:template`<class T`> int sgn`(T a`):%00-00 [%00-00 int"
" ][%00-00* FindLowerBound][%00-00 (const ][%00-00*@4 C][%00-00 `& ][%00-00*@3 v]["
"%00-00 , int ][%00-00*@3 pos][%00-00 , int ][%00-00*@3 count][%00-00 , const ][%0"
"0-00*@4 T][%00-00 `& ][%00-00*@3 val][%00-00 , const ][%00-00*@4 L][%00-00 `& ][%"
"00-00*@3 less][%00-00 )]&][s6;%00-00 [%00-00 Finds first position in range of con"
"tainer sorted by ][%00-00* less][%00-00  predicate where ][%00-00* val][%00-00  c"
"an be inserted without breaking the ordering.]&][s1;%00-00 [%00-00*C@4 C][%00-00 "
"-|Type of container.]&][s1;%00-00 [%00-00*C@4 T][%00-00 -|Type of value.]&][s1;%0"
"0-00 [%00-00*C@3 v][%00-00 -|Container.]&][s1;%00-00 [%00-00*C@3 pos][%00-00 -|Be"
"ginning of range.]&][s1;%00-00 [%00-00*C@3 count][%00-00 -|Number of elements in "
"range.]&][s1;%00-00 [%00-00*C@3 val][%00-00 -|Value to find.]&][s1;%00-00 [%00-00"
"*C@3 less][%00-00 -|Ordering predicate.]&][s1;%00-00 [%00-00*/ Return value][%00-"
"00 -|Position in container.]&][s13;:template`<class C`, class T`, class L`> int F"
"indLowerBound`(const C`& v`, const T`& val`, const L`& less`):%00-00 [%00-00 temp"
"late<class ][%00-00*@4 C][%00-00 , class ][%00-00*@4 T][%00-00 , class ][%00-00*@"
"4 L][%00-00 >]&][s14;:template`<class C`, class T`, class L`> int FindLowerBound`"
"(const C`& v`, const T`& val`, const L`& less`):%00-00 [%00-00 int ][%00-00* Find"
"LowerBound][%00-00 (const ][%00-00*@4 C][%00-00 `& ][%00-")
TOPIC_TEXT(
"00*@3 v][%00-00 , const ][%00-00*@4 T][%00-00 `& ][%00-00*@3 val][%00-00 , const"
" ][%00-00*@4 L][%00-00 `& ][%00-00*@3 less][%00-00 )]&][s6;%00-00 [%00-00 Finds f"
"irst position in sorted by ][%00-00* less][%00-00  predicate where ][%00-00* val]"
"[%00-00  can be inserted without breaking the ordering.]&][s1;%00-00 [%00-00*C@4 "
"C][%00-00 -|Type of container.]&][s1;%00-00 [%00-00*C@4 T][%00-00 -|Type of value"
".]&][s1;%00-00 [%00-00*C@3 v][%00-00 -|Container.]&][s1;%00-00 [%00-00*C@3 val][%"
"00-00 -|Value to find.]&][s1;%00-00 [%00-00*C@3 less][%00-00 -|Ordering predicate"
".]&][s1;%00-00 [%00-00*/ Return value][%00-00 -|Position in container.]&][s13;:te"
"mplate`<class C`, class T`> int FindLowerBound`(const C`& v`, const T`& val`):%00"
"-00 [%00-00 template<class ][%00-00*@4 C][%00-00 , class ][%00-00*@4 T][%00-00 >]"
"&][s14;:template`<class C`, class T`> int FindLowerBound`(const C`& v`, const T`&"
" val`):%00-00 [%00-00 int ][%00-00* FindLowerBound][%00-00 (const ][%00-00*@4 C]["
"%00-00 `& ][%00-00*@3 v][%00-00 , const ][%00-00*@4 T][%00-00 `& ][%00-00*@3 val]"
"[%00-00 )]&][s6;%00-00 [%00-00 Finds first position in sorted by ][%00-00*/ opera"
"tor<][%00-00  predicate where ][%00-00* val][%00-00  can be inserted without brea"
"king the ordering.]&][s1;%00-00 [%00-00*C@4 C][%00-00 -|Type of container.]&][s1;"
"%00-00 [%00-00*C@4 T][%00-00 -|Type of value.]&][s1;%00-00 [%00-00*C@3 v][%00-00 "
"-|Container.]&][s1;%00-00 [%00-00*C@3 val][%00-00 -|Value to find.]&][s1;%00-00 ["
"%00-00*/ Return value][%00-00 -|Position in container.]&][s13;:template`<class C`"
", class T`, class L`> int FindUpperBound`(const C`& v`, int l`, int h`, const T`&"
" val`, const L`& less`):%00-00 [%00-00 template<class ][%00-00*@4 C][%00-00 , cla"
"ss ][%00-00*@4 T][%00-00 , class ][%00-00*@4 L][%00-00 >]&][s14;:template`<class "
"C`, class T`, class L`> int FindUpperBound`(const C`& v`, int l`, int h`, const T"
"`& val`, const L`& less`):%00-00 [%00-00 int ][%00-00* FindUpperBound][%00-00 (co"
"nst ][%00-00*@4 C][%00-00 `& ][%00-00*@3 v][%00-00 , int ")
TOPIC_TEXT(
"][%00-00*@3 pos][%00-00 , int ][%00-00*@3 count][%00-00 , const ][%00-00*@4 T][%"
"00-00 `& ][%00-00*@3 val][%00-00 , const ][%00-00*@4 L][%00-00 `& ][%00-00*@3 les"
"s][%00-00 )]&][s6;%00-00 [%00-00 Finds last position in range of container sorted"
" by ][%00-00* less][%00-00  predicate where ][%00-00* val][%00-00  can be inserte"
"d without breaking the ordering.]&][s1;%00-00 [%00-00*C@4 C][%00-00 -|Type of con"
"tainer.]&][s1;%00-00 [%00-00*C@4 T][%00-00 -|Type of value.]&][s1;%00-00 [%00-00*"
"C@3 v][%00-00 -|Container.]&][s1;%00-00 [%00-00*C@3 pos][%00-00 -|Beginning of ra"
"nge.]&][s1;%00-00 [%00-00*C@3 count][%00-00 -|Number of elements in range.]&][s1;"
"%00-00 [%00-00*C@3 val][%00-00 -|Value to find.]&][s1;%00-00 [%00-00*C@3 less][%0"
"0-00 -|Ordering predicate.]&][s1;%00-00 [%00-00*/ Return value][%00-00 -|Position"
" in container.]&][s13;:template`<class C`, class T`, class L`> int FindUpperBound"
"`(const C`& v`, const T`& val`, const L`& less`):%00-00 [%00-00 template<class ]["
"%00-00*@4 C][%00-00 , class ][%00-00*@4 T][%00-00 , class ][%00-00*@4 L][%00-00 >"
"]&][s14;:template`<class C`, class T`, class L`> int FindUpperBound`(const C`& v`"
", const T`& val`, const L`& less`):%00-00 [%00-00 int ][%00-00* FindUpperBound][%"
"00-00 (const ][%00-00*@4 C][%00-00 `& ][%00-00*@3 v][%00-00 , const ][%00-00*@4 T"
"][%00-00 `& ][%00-00*@3 val][%00-00 , const ][%00-00*@4 L][%00-00 `& ][%00-00*@3 "
"less][%00-00 )]&][s6;%00-00 [%00-00 Finds last position in sorted by ][%00-00* le"
"ss][%00-00  predicate where ][%00-00* val][%00-00  can be inserted without breaki"
"ng the ordering.]&][s1;%00-00 [%00-00*C@4 C][%00-00 -|Type of container.]&][s1;%0"
"0-00 [%00-00*C@4 T][%00-00 -|Type of value.]&][s1;%00-00 [%00-00*C@3 v][%00-00 -|"
"Container.]&][s1;%00-00 [%00-00*C@3 val][%00-00 -|Value to find.]&][s1;%00-00 [%0"
"0-00*C@3 less][%00-00 -|Ordering predicate.]&][s1;%00-00 [%00-00*/ Return value]["
"%00-00 -|Position in container.]&][s13;:template`<class C`, class T`> int FindUpp"
"erBound`(const C`& v`, const T`& val`):%00-00 [%00-00 tem")
TOPIC_TEXT(
"plate<class ][%00-00*@4 C][%00-00 , class ][%00-00*@4 T][%00-00 >]&][s14;:templa"
"te`<class C`, class T`> int FindUpperBound`(const C`& v`, const T`& val`):%00-00 "
"[%00-00 int ][%00-00* FindUpperBound][%00-00 (const ][%00-00*@4 C][%00-00 `& ][%0"
"0-00*@3 v][%00-00 , const ][%00-00*@4 T][%00-00 `& ][%00-00*@3 val][%00-00 )]&][s"
"6;%00-00 [%00-00 Finds last position in sorted by ][%00-00*/ operator<][%00-00  p"
"redicate where ][%00-00* val][%00-00  can be inserted without breaking the orderi"
"ng.]&][s1;%00-00 [%00-00*C@4 C][%00-00 -|Type of container.]&][s1;%00-00 [%00-00*"
"C@4 T][%00-00 -|Type of value.]&][s1;%00-00 [%00-00*C@3 v][%00-00 -|Container.]&]"
"[s1;%00-00 [%00-00*C@3 val][%00-00 -|Value to find.]&][s1;%00-00 [%00-00*/ Return"
" value][%00-00 -|Position in container.]&][s13;:template`<class C`, class T`, cla"
"ss L`> int FindBinary`(const C`& v`, const T`& val`, int l`, int h`, const L`& le"
"ss`):%00-00 [%00-00 template<class ][%00-00*@4 C][%00-00 , class ][%00-00*@4 T][%"
"00-00 , class ][%00-00*@4 L][%00-00 >]&][s14;:template`<class C`, class T`, class"
" L`> int FindBinary`(const C`& v`, const T`& val`, int l`, int h`, const L`& less"
"`):%00-00 [%00-00 int ][%00-00* FindBinary][%00-00 (const ][%00-00*@4 C][%00-00 `"
"& ][%00-00*@3 v][%00-00 , const ][%00-00*@4 T][%00-00 `& ][%00-00*@3 val][%00-00 "
", int ][%00-00*@3 pos][%00-00 , int ][%00-00*@3 count][%00-00 , const ][%00-00*@4"
" L][%00-00 `& ][%00-00*@3 less][%00-00 )]&][s6;%00-00 [%00-00 Finds position of e"
"lement with specified value in a range of container sorted by ][%00-00* less][%00"
"-00  predicate. If no such element exists, negative value is returned.]&][s1;%00-"
"00 [%00-00*C@4 C][%00-00 -|Type of container.]&][s1;%00-00 [%00-00*C@4 T][%00-00 "
"-|Type of value.]&][s1;%00-00 [%00-00*C@3 v][%00-00 -|Container.]&][s1;%00-00 [%0"
"0-00*C@3 pos][%00-00 -|Beginning of range.]&][s1;%00-00 [%00-00*C@3 count][%00-00"
" -|Number of elements in range.]&][s1;%00-00 [%00-00*C@3 val][%00-00 -|Value to f"
"ind.]&][s1;%00-00 [%00-00*C@3 less][%00-00 -|Ordering pre")
TOPIC_TEXT(
"dicate.]&][s1;%00-00 [%00-00*/ Return value][%00-00 -|Position in container.]&]["
"s13;:template`<class C`, class T`, class L`> int FindBinary`(const C`& v`, const "
"T`& val`, const L`& less`):%00-00 [%00-00 template<class ][%00-00*@4 C][%00-00 , "
"class ][%00-00*@4 T][%00-00 , class ][%00-00*@4 L][%00-00 >]&][s14;:template`<cla"
"ss C`, class T`, class L`> int FindBinary`(const C`& v`, const T`& val`, const L`"
"& less`):%00-00 [%00-00 int ][%00-00* FindBinary][%00-00 (const ][%00-00*@4 C][%0"
"0-00 `& ][%00-00*@3 v][%00-00 , const ][%00-00*@4 T][%00-00 `& ][%00-00*@3 val][%"
"00-00 , const ][%00-00*@4 L][%00-00 `& ][%00-00*@3 less][%00-00 )]&][s6;%00-00 [%"
"00-00 Finds position of element with specified value in the container sorted by ]"
"[%00-00* less][%00-00  predicate. If no such element exists, negative value is re"
"turned.]&][s1;%00-00 [%00-00*C@4 C][%00-00 -|Type of container.]&][s1;%00-00 [%00"
"-00*C@4 T][%00-00 -|Type of value.]&][s1;%00-00 [%00-00*C@3 v][%00-00 -|Container"
".]&][s1;%00-00 [%00-00*C@3 val][%00-00 -|Value to find.]&][s1;%00-00 [%00-00*C@3 "
"less][%00-00 -|Ordering predicate.]&][s1;%00-00 [%00-00*/ Return value][%00-00 -|"
"Position in container.]&][s13;:template`<class C`, class T`> int FindBinary`(cons"
"t C`& v`, const T`& val`):%00-00 [%00-00 template<class ][%00-00*@4 C][%00-00 , c"
"lass ][%00-00*@4 T][%00-00 >]&][s14;:template`<class C`, class T`> int FindBinary"
"`(const C`& v`, const T`& val`):%00-00 [%00-00 int ][%00-00* FindBinary][%00-00 ("
"const ][%00-00*@4 C][%00-00 `& ][%00-00*@3 v][%00-00 , const ][%00-00*@4 T][%00-0"
"0 `& ][%00-00*@3 val][%00-00 )]&][s6;%00-00 [%00-00 Finds position of element wit"
"h specified value in the container sorted by ][%00-00*/ operator<][%00-00  predic"
"ate. If no such element exists, negative value is returned.]&][s1;%00-00 [%00-00*"
"C@4 C][%00-00 -|Type of container.]&][s1;%00-00 [%00-00*C@4 T][%00-00 -|Type of v"
"alue.]&][s1;%00-00 [%00-00*C@3 v][%00-00 -|Container.]&][s1;%00-00 [%00-00*C@3 va"
"l][%00-00 -|Value to find.]&][s1;%00-00 [%00-00*/ Return ")
TOPIC_TEXT(
"value][%00-00 -|Position in container.]&][s13;:template`<class C`> C`& AppendSor"
"ted`(C`& dest`, const C`& src`):~~~.992;%00-00 [%00-00 template<class ][%00-00*@4"
" C][%00-00 >]&][s14;:template`<class C`> C`& AppendSorted`(C`& dest`, const C`& s"
"rc`):~~~.992;%00-00 [%00-00*@4 C][%00-00 `& ][%00-00* AppendSorted][%00-00 (][%00"
"-00*@4 C][%00-00 `& ][%00-00*@3 dest][%00-00 , const ][%00-00*@4 C][%00-00 `& ][%"
"00-00*@3 src][%00-00 , const ][%00-00*@4 L][%00-00 `& ][%00-00*@3 less][%00-00 )]"
"&][s6;%00-00 [%00-00 Adds source NTL container to destination NTL container. Both"
" containers must be sorted in ascending order. After operation, destination conta"
"iner is sorted in ascending order and contains values from both containers. Dupli"
"cate values are preserved. Ordering predicate is determined by ][%00-00* less][%0"
"0-00 .]&][s1;%00-00 [%00-00*C@4 C][%00-00 -|Type of container.]&][s1;%00-00 [%00-"
"00*C@3 dest][%00-00 -|Destination container.]&][s1;%00-00 [%00-00*C@3 src][%00-00"
" -|Source container.]&][s1;%00-00 [%00-00*C@3 less][%00-00 -|Ordering predicate.]"
"&][s1;%00-00C [%00-00*/A Return value][%00-00A -|Destination container.][%00-00 t"
"emplate<class ][%00-00*@4 C][%00-00 >]&][s13;:template`<class C`> C`& AppendSorte"
"d`(C`& dest`, const C`& src`):~~~.992;%00-00 [%00-00 template<class ][%00-00*@4 C"
"][%00-00 >]&][s14;~~~.992;%00-00 [%00-00*@4 C][%00-00 `& ][%00-00* AppendSorted]["
"%00-00 (][%00-00*@4 C][%00-00 `& ][%00-00*@3 dest][%00-00 , const ][%00-00*@4 C]["
"%00-00 `& ][%00-00*@3 src][%00-00 )]&][s6;~~~.992;%00-00 [%00-00 Adds source NTL "
"container to destination NTL container. Both containers must be sorted in ascendi"
"ng order. After operation, destination container is sorted in ascending order and"
" contains values from both containers. Duplicate values are preserved. Ordering i"
"s determined by ][%00-00*/ operator<][%00-00 .]&][s1;%00-00 [%00-00*C@4 C][%00-00"
" -|Type of container.]&][s1;%00-00 [%00-00*C@3 dest][%00-00 -|Destination contain"
"er.]&][s1;%00-00 [%00-00*C@3 src][%00-00 -|Source contain")
TOPIC_TEXT(
"er.]&][s1;%00-00C [%00-00*/A Return value][%00-00A -|Destination container.][%00"
"-00 template<class ][%00-00*@4 C][%00-00 >]&][s13;%00-00 [%00-00 template<class ]"
"[%00-00*@4 C][%00-00 , class ][%00-00*@4 L][%00-00 >]&][s14;%00-00 [%00-00*@4 C]["
"%00-00 `& ][%00-00* UnionSorted][%00-00 (][%00-00*@4 C][%00-00 `& ][%00-00*@3 des"
"t][%00-00 , const ][%00-00*@4 C][%00-00 `& ][%00-00*@3 src][%00-00 , const ][%00-"
"00*@4 L][%00-00 `& ][%00-00*@3 less][%00-00 )]&][s6;%00-00 [%00-00 Adds source NT"
"L container to destination NTL container. Both containers must be sorted in ascen"
"ding order and values must be unique. After operation, destination container is s"
"orted in ascending order and contains unique values from both containers. Orderin"
"g is determined by ][%00-00* less][%00-00 .]&][s1;%00-00 [%00-00*C@4 C][%00-00 -|"
"Type of container.]&][s1;%00-00 [%00-00*C@3 dest][%00-00 -|Destination container."
"]&][s1;%00-00 [%00-00*C@3 src][%00-00 -|Source container.]&][s1;%00-00 [%00-00*C@"
"3 less][%00-00 -|Ordering predicate.]&][s1;%00-00 [%00-00*/ Return value][%00-00 "
"-|Destination container.]&][s13;:template`<class C`> C`& UnionSorted`(C`& dest`, "
"const C`& src`):%00-00 [%00-00 template<class ][%00-00*@4 C][%00-00 >]&][s14;:tem"
"plate`<class C`> C`& UnionSorted`(C`& dest`, const C`& src`):~~~.992;%00-00 [%00-"
"00*@4 C][%00-00 `& ][%00-00* UnionSorted][%00-00 (][%00-00*@4 C][%00-00 `& ][%00-"
"00*@3 dest][%00-00 , const ][%00-00*@4 C][%00-00 `& ][%00-00*@3 src][%00-00 )]&]["
"s6;%00-00 [%00-00 Adds source NTL container to destination NTL container. Both co"
"ntainers must be sorted in ascending order and values must be unique. After opera"
"tion, destination container is sorted in ascending order and contains unique valu"
"es from both containers. Ordering is determined by ][%00-00*/ operator<][%00-00 ."
"]&][s1;%00-00 [%00-00*C@4 C][%00-00 -|Type of container.]&][s1;%00-00 [%00-00*C@3"
" dest][%00-00 -|Destination container.]&][s1;%00-00 [%00-00*C@3 src][%00-00 -|Sou"
"rce container.]&][s1;%00-00 [%00-00*/ Return value][%00-0")
TOPIC_TEXT(
"0 -|Destination container.]&][s13;%00-00 [%00-00 template<class ][%00-00*@4 C][%"
"00-00 , class ][%00-00*@4 L][%00-00 >]&][s14;%00-00 [%00-00*@4 C][%00-00 `& ][%00"
"-00* RemoveSorted][%00-00 (][%00-00*@4 C][%00-00 `& ][%00-00*@3 from][%00-00 , co"
"nst ][%00-00*@4 C][%00-00 `& ][%00-00*@3 what][%00-00 , const ][%00-00*@4 L][%00-"
"00 `& ][%00-00*@3 less][%00-00 )]&][s6;%00-00 [%00-00 Removes elements of source "
"container from destination container. Both containers must be sorted in ascending"
" order and values must be unique. Ordering is determined by ][%00-00* less][%00-0"
"0 .]&][s1;%00-00 [%00-00*C@4 C][%00-00 -|Type of container.]&][s1;%00-00 [%00-00*"
"C@3 from][%00-00 -|Destination container.]&][s1;%00-00 [%00-00*C@3 what][%00-00 -"
"|Source container.]&][s1;%00-00 [%00-00*C@3 less][%00-00 -|Ordering predicate.]&]"
"[s1;%00-00 [%00-00*/ Return value][%00-00 -|Destination container.]&][s13;:templa"
"te`<class C`> C`& RemoveSorted`(C`& from`, const C`& what`):%00-00 [%00-00 templa"
"te<class ][%00-00*@4 C][%00-00 >]&][s14;:template`<class C`> C`& RemoveSorted`(C`"
"& from`, const C`& what`):%00-00 [%00-00*@4 C][%00-00 `& ][%00-00* RemoveSorted]["
"%00-00 (][%00-00*@4 C][%00-00 `& ][%00-00*@3 from][%00-00 , const ][%00-00*@4 C]["
"%00-00 `& ][%00-00*@3 what][%00-00 )]&][s6;%00-00 [%00-00 Removes elements of sou"
"rce container from destination container. Both containers must be sorted in ascen"
"ding order and values must be unique. Ordering is determined by ][%00-00*/ operat"
"or<][%00-00 .]&][s1;%00-00 [%00-00*C@4 C][%00-00 -|Type of container.]&][s1;%00-0"
"0 [%00-00*C@3 from][%00-00 -|Destination container.]&][s1;%00-00 [%00-00*C@3 what"
"][%00-00 -|Source container.]&][s1;%00-00 [%00-00*/ Return value][%00-00 -|Destin"
"ation container.]&][s13;:template`<class D`, class S`, class L`> D`& IntersectSor"
"ted`(D`& dest`, const S`& src`, const L`& less`):%00-00 [%00-00 template<class ]["
"%00-00*@4 D][%00-00 , class ][%00-00*@4 S][%00-00 , class ][%00-00*@4 L][%00-00 >"
"]&][s14;:template`<class D`, class S`, class L`> D`& Inte")
TOPIC_TEXT(
"rsectSorted`(D`& dest`, const S`& src`, const L`& less`):%00-00 [%00-00*@4 D][%0"
"0-00 `& ][%00-00* IntersectSorted][%00-00 (][%00-00*@4 D][%00-00 `& ][%00-00*@3 d"
"est][%00-00 , const ][%00-00*@4 S][%00-00 `& ][%00-00*@3 src][%00-00 , const ][%0"
"0-00*@4 L][%00-00 `& ][%00-00*@3 less][%00-00 )]&][s6;%00-00 [%00-00 Removes elem"
"ents from destination container that are not contained in source container. Both "
"containers must be sorted in ascending order and values must be unique. Ordering "
"is determined by ][%00-00* less][%00-00 .]&][s1;%00-00 [%00-00*C@4 D][%00-00 -|Ty"
"pe of destination container.]&][s1;%00-00 [%00-00*C@4 S][%00-00 -|Type of source "
"container.]&][s1;%00-00 [%00-00*C@3 dest][%00-00 -|Destination container.]&][s1;%"
"00-00 [%00-00*C@3 src][%00-00 -|Source container.]&][s1;%00-00 [%00-00*C@3 less]["
"%00-00 -|Destination container.]&][s13;:template`<class D`, class S`> D`& Interse"
"ctSorted`(D`& dest`, const S`& src`):%00-00 [%00-00 template<class ][%00-00*@4 D]"
"[%00-00 , class ][%00-00*@4 S][%00-00 >]&][s14;:template`<class D`, class S`> D`&"
" IntersectSorted`(D`& dest`, const S`& src`):%00-00 [%00-00*@4 D][%00-00 `& ][%00"
"-00* IntersectSorted][%00-00 (][%00-00*@4 D][%00-00 `& ][%00-00*@3 dest][%00-00 ,"
" const ][%00-00*@4 S][%00-00 `& ][%00-00*@3 src][%00-00 )]&][s6;%00-00 [%00-00 Re"
"moves elements from destination container that are not contained in source contai"
"ner. Both containers must be sorted in ascending order and values must be unique."
" Ordering is determined by ][%00-00*/ operator<][%00-00 .]&][s1;%00-00 [%00-00*C@"
"4 D][%00-00 -|Type of destination container.]&][s1;%00-00 [%00-00*C@4 S][%00-00 -"
"|Type of source container.]&][s1;%00-00 [%00-00*C@3 dest][%00-00 -|Destination co"
"ntainer.]&][s1;%00-00 [%00-00*C@3 src][%00-00 -|Source container.]&][s1;%00-00 [%"
"00-00*/ Return value][%00-00 -|Destination container.]&][s13;:template`<class T`>"
" void StreamContainer`(Stream`& s`, T`& cont`):%00-00 [%00-00 template<class ][%0"
"0-00*@4 T][%00-00 , class ][%00-00*@4 Less][%00-00 >]&][s")
TOPIC_TEXT(
"14;:template`<class T`> void StreamContainer`(Stream`& s`, T`& cont`):%00-00 [%0"
"0-00 void ][%00-00* Sort][%00-00 (][%00-00*@4 T][%00-00 `& ][%00-00*@3 c][%00-00 "
", const ][%00-00*@4 Less][%00-00 `& ][%00-00*@3 less][%00-00 )]&][s6;%00-00 [%00-"
"00 Sorts container. Ordering is determined by ][%00-00* less][%00-00 .]&][s11; It"
"erSwap must be defined for T`::Iterator.&][s1;%00-00 [%00-00*C@4 T][%00-00 -|Type"
" of container.]&][s1;%00-00 [%00-00*C@3 c][%00-00 -|Container.]&][s1;%00-00 [%00-"
"00*C@3 less][%00-00 -|Ordering predicate.]&][s13;:template`<class T`> void Sort`("
"T`& c`):%00-00 [%00-00 template<class ][%00-00*@4 T][%00-00 >]&][s14;:template`<c"
"lass T`> void Sort`(T`& c`):%00-00 [%00-00 void ][%00-00* Sort][%00-00 (][%00-00*"
"@4 T][%00-00 `& ][%00-00*@3 c][%00-00 )]&][s6;%00-00 [%00-00 Sorts container. Ord"
"ering is determined by ][%00-00*/ operato<][%00-00 .]&][s6;%00-00*1 [%00-00 IterS"
"wap must be defined for T`::Iterator.]&][s1;%00-00 [%00-00*C@4 T][%00-00 -|Type o"
"f container.]&][s1;%00-00 [%00-00*C@3 c][%00-00 -|Container.]&][s13;:template`<cl"
"ass II`, class VI`, class K`, class Less`> void `_`_IndexSort`(II begin`, II end`"
", VI pair`, const Less`& less`, const K `*`):%00-00 [%00-00 template<class ][%00-"
"00*@4 KC][%00-00 , class ][%00-00*@4 VC][%00-00 , class ][%00-00*@4 Less][%00-00 "
">]&][s14;:template`<class II`, class VI`, class K`, class Less`> void `_`_IndexSo"
"rt`(II begin`, II end`, VI pair`, const Less`& less`, const K `*`):%00-00 [%00-00"
" void ][%00-00* IndexSort][%00-00 (][%00-00*@4 KC][%00-00 `& ][%00-00*@3 keys][%0"
"0-00 , ][%00-00*@4 VC][%00-00 `& ][%00-00*@3 values][%00-00 , const ][%00-00*@4 L"
"ess][%00-00 `& ][%00-00*@3 less][%00-00 )]&][s6;%00-00 [%00-00 Sorts pair of cont"
"ainers. Both containers must have same number of items. Resulting order is determ"
"ined by ][%00-00* keys][%00-00  container. Ordering is determined by ][%00-00* le"
"ss][%00-00 .]&][s1;%00-00 [%00-00*C@4 KC][%00-00 -|Type of keys container.]&][s1;"
"%00-00 [%00-00*C@4 VC][%00-00 -|Type of values.]&][s1;%00")
TOPIC_TEXT(
"-00 [%00-00*C@3 keys][%00-00 -|Container of keys.]&][s1;%00-00 [%00-00*C@3 value"
"s][%00-00 -|Container of values.]&][s1;%00-00 [%00-00*C@3 less][%00-00 -|Ordering"
" predicate.]&][s13;:template`<class KC`, class VC`> void IndexSort`(KC`& keys`, V"
"C`& values`):%00-00 [%00-00 template<class ][%00-00*@4 KC][%00-00 , class ][%00-0"
"0*@4 VC][%00-00 >]&][s14;:template`<class KC`, class VC`> void IndexSort`(KC`& ke"
"ys`, VC`& values`):%00-00 [%00-00 void ][%00-00* IndexSort][%00-00 (][%00-00*@4 K"
"C][%00-00 `& ][%00-00*@3 keys][%00-00 , ][%00-00*@4 VC][%00-00 `& ][%00-00*@3 val"
"ues][%00-00 )]&][s6;%00-00 [%00-00 Sorts pair of containers. Both containers must"
" have same number of items. Resulting order is determined by ][%00-00* keys][%00-"
"00  container. Ordering is determined by ][%00-00*/ operator<][%00-00 .]&][s1;%00"
"-00 [%00-00*C@4 KC][%00-00 -|Type of keys container.]&][s1;%00-00 [%00-00*C@4 VC]"
"[%00-00 -|Type of values container.]&][s1;%00-00 [%00-00*C@3 keys][%00-00 -|Conta"
"iner of keys.]&][s1;%00-00 [%00-00*C@3 values][%00-00 -|Container of values.]&][s"
"13;:template`<class I`, class V`, class Less`> void `_`_SortOrder`(int `*begin`, "
"int `*end`, I data`, const Less`& less`, const V `*`):%00-00 [%00-00 template<cla"
"ss ][%00-00*@4 C][%00-00 , class ][%00-00*@4 Less][%00-00 >]&][s14;:template`<cla"
"ss I`, class V`, class Less`> void `_`_SortOrder`(int `*begin`, int `*end`, I dat"
"a`, const Less`& less`, const V `*`):%00-00 [%00-00 Vector<int> ][%00-00* GetSort"
"Order][%00-00 (const ][%00-00*@4 C][%00-00 `& ][%00-00*@3 container][%00-00 , con"
"st ][%00-00*@4 Less][%00-00 `& ][%00-00*@3 less][%00-00 )]&][s6;%00-00 [%00-00 Cr"
"eates ascending order of values in container. Ordering is determined by ][%00-00*"
" less][%00-00 .]&][s1;%00-00 [%00-00*C@4 C][%00-00 -|Type of container.]&][s1;%00"
"-00 [%00-00*C@3 container][%00-00 -|Source container.]&][s1;%00-00 [%00-00*C@3 le"
"ss][%00-00 -|Ordering predicate.]&][s1;%00-00 [%00-00*/ Return value][%00-00 -|Ve"
"ctor of positions of source container in sorted order.]&]")
TOPIC_TEXT(
"[s13;:template`<class C`> Vector`<int`> GetSortOrder`(const C`& container`):%00-"
"00 [%00-00 template<class ][%00-00*@4 C][%00-00 >]&][s14;:template`<class C`> Vec"
"tor`<int`> GetSortOrder`(const C`& container`):%00-00 [%00-00 Vector<int> ][%00-0"
"0* GetSortOrder][%00-00 (const ][%00-00*@4 C][%00-00 `& ][%00-00*@3 container][%0"
"0-00 )]&][s6;%00-00 [%00-00 Creates ascending order of values in container. Order"
"ing is determined by ][%00-00*/ operator<][%00-00 .]&][s1;%00-00 [%00-00*C@4 C][%"
"00-00 -|Type of container.]&][s1;%00-00 [%00-00*C@3 container][%00-00 -|Source co"
"ntainer.]&][s1;%00-00 [%00-00*/ Return value][%00-00 -|Vector of positions of sou"
"rce container in sorted order.]&][s13;:template`<class DC`, class I`, class F`> v"
"oid GetFieldContainer`(DC`& dest`, I begin`, I end`, F field`):%00-00 [%00-00 tem"
"plate<class ][%00-00*@4 O][%00-00 , class ][%00-00*@4 T][%00-00 , class ][%00-00*"
"@4 R][%00-00 >]&][s14;:template`<class DC`, class I`, class F`> void GetFieldCont"
"ainer`(DC`& dest`, I begin`, I end`, F field`):%00-00 [%00-00/ type][%00-00  ][%0"
"0-00* FieldRelation][%00-00 (][%00-00*@4 O][%00-00  (][%00-00*@4 T][%00-00 `::*]["
"%00-00*@3 member][%00-00 ), const ][%00-00*@4 R][%00-00 `& ][%00-00*@3 relation]["
"%00-00 )]&][s6;%00-00 [%00-00 Creates ordering predicate for ][%00-00* T][%00-00 "
" based on value of member variable of][%00-00*  T][%00-00 .]&][s1;%00-00 [%00-00*"
"C@4 T][%00-00 -|Type of element.]&][s1;%00-00 [%00-00*C@3 member][%00-00 -|Member"
" variable of T.]&][s1;%00-00 [%00-00*C@3 relation][%00-00 -|Ordering relation for"
" ][%00-00* member][%00-00 .]&][s1;%00-00 [%00-00*/ Return value][%00-00 -|Orderin"
"g predicate.]&][s13;:template`<class O`, class T`, class R`> MethodRelationCls`<O"
" `(T`:`:`*`)`(`)`, T`, R`> MethodRelation`(O `(T`:`:`*method`)`(`)`, const R`& re"
"lation`):%00-00 [%00-00 template<class ][%00-00*@4 O][%00-00 , class ][%00-00*@4 "
"T][%00-00 , class ][%00-00*@4 R][%00-00 >]&][s14;:template`<class O`, class T`, c"
"lass R`> MethodRelationCls`<O `(T`:`:`*`)`(`)`, T`, R`> M")
TOPIC_TEXT(
"ethodRelation`(O `(T`:`:`*method`)`(`)`, const R`& relation`):%00-00 [%00-00/ ty"
"pe][%00-00  ][%00-00* MethodRelation][%00-00 (][%00-00*@4 O][%00-00  (][%00-00*@4"
" T][%00-00 `::*][%00-00*@3 method][%00-00 )(), const ][%00-00*@4 R][%00-00 `& ][%"
"00-00*@3 relation][%00-00 )]&][s6;%00-00 [%00-00 Creates ordering predicate for ]"
"[%00-00* T][%00-00  based on value returned by non-const method of ][%00-00* T][%"
"00-00 .]&][s1;%00-00 [%00-00*C@4 T][%00-00 -|Type of element.]&][s1;%00-00 [%00-0"
"0*C@3 method][%00-00 -|Method of T.]&][s1;%00-00 [%00-00*C@3 relation][%00-00 -|O"
"rdering relation for value returned by method.]&][s1;%00-00 [%00-00*/ Return valu"
"e][%00-00 -|Ordering predicate.]&][s13;:template`<class O`, class T`, class R`> M"
"ethodRelationCls`<O `(T`:`:`*`)`(`) const`, T`, R`> MethodRelation`(O `(T`:`:`*me"
"thod`)`(`) const`, const R`& relation`):%00-00 [%00-00 template<class ][%00-00*@4"
" O][%00-00 , class ][%00-00*@4 T][%00-00 , class ][%00-00*@4 R][%00-00 >]&][s14;:"
"template`<class O`, class T`, class R`> MethodRelationCls`<O `(T`:`:`*`)`(`) cons"
"t`, T`, R`> MethodRelation`(O `(T`:`:`*method`)`(`) const`, const R`& relation`):"
"%00-00 [%00-00/ type][%00-00  ][%00-00* MethodRelation][%00-00 (][%00-00*@4 O][%0"
"0-00  (][%00-00*@4 T][%00-00 `::*][%00-00*@3 method][%00-00 )() const, const ][%0"
"0-00*@4 R][%00-00 `& ][%00-00*@3 relation][%00-00 )]&][s6;%00-00 [%00-00 Creates "
"ordering predicate for ][%00-00* T][%00-00  based on value returned by const meth"
"od of ][%00-00* T][%00-00 .]&][s1;%00-00 [%00-00*C@4 T][%00-00 -|Type of element."
"]&][s1;%00-00 [%00-00*C@3 method][%00-00 -|Method of T.]&][s1;%00-00 [%00-00*C@3 "
"relation][%00-00 -|Ordering relation for value returned by method.]&][s1;%00-00 ["
"%00-00*/ Return value][%00-00 -|Ordering predicate.]")
